diff --git a/node_modules/@sentry/react-native/.DS_Store b/node_modules/@sentry/react-native/.DS_Store
new file mode 100644
index 0000000..23b36a2
Binary files /dev/null and b/node_modules/@sentry/react-native/.DS_Store differ
diff --git a/node_modules/@sentry/react-native/dist/.DS_Store b/node_modules/@sentry/react-native/dist/.DS_Store
new file mode 100644
index 0000000..3d2b55f
Binary files /dev/null and b/node_modules/@sentry/react-native/dist/.DS_Store differ
diff --git a/node_modules/@sentry/react-native/dist/js/.DS_Store b/node_modules/@sentry/react-native/dist/js/.DS_Store
new file mode 100644
index 0000000..4da17a8
Binary files /dev/null and b/node_modules/@sentry/react-native/dist/js/.DS_Store differ
diff --git a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts
index 394ee8c..d3a82cb 100644
--- a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts
+++ b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts
@@ -1,11 +1,11 @@
 import type { MetroConfig } from 'metro';
 import type { MetroSerializer } from './utils';
 /**
- * This function will overwrite any existing custom serializer with default Expo and Sentry serializers.
+ * This config will overwrite any existing custom serializer with default Expo and Sentry serializers.
  *
  * To use custom serializers, use `createSentryMetroSerializer(customSerializer)` instead.
  */
-export declare function withSentryExpoSerializers(config: MetroConfig): MetroConfig;
+export declare function getSentryExpoConfig(projectRoot: string): MetroConfig;
 /**
  * Creates a Metro serializer that adds Debug ID module to the plain bundle.
  * The Debug ID module is a virtual module that provides a debug ID in runtime.
diff --git a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts.map b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts.map
index d1af67d..29cb065 100644
--- a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts.map
+++ b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"sentryMetroSerializer.d.ts","sourceRoot":"","sources":["../../../src/js/tools/sentryMetroSerializer.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,WAAW,EAAuB,MAAM,OAAO,CAAC;AAI9D,OAAO,KAAK,EAAU,eAAe,EAA4D,MAAM,SAAS,CAAC;AAYjH;;;;GAIG;AACH,wBAAgB,yBAAyB,CAAC,MAAM,EAAE,WAAW,GAAG,WAAW,CAW1E;AAeD;;;;;GAKG;AACH,eAAO,MAAM,2BAA2B,sBAAuB,eAAe,KAAG,eAsDhF,CAAC"}
\ No newline at end of file
+{"version":3,"file":"sentryMetroSerializer.d.ts","sourceRoot":"","sources":["../../../src/js/tools/sentryMetroSerializer.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,WAAW,EAAsC,MAAM,OAAO,CAAC;AAG7E,OAAO,KAAK,EAAU,eAAe,EAA4D,MAAM,SAAS,CAAC;AAYjH;;;;GAIG;AACH,wBAAgB,mBAAmB,CAAC,WAAW,EAAE,MAAM,GAAG,WAAW,CAGpE;AA2CD;;;;;GAKG;AACH,eAAO,MAAM,2BAA2B,sBAAuB,eAAe,KAAG,eAsDhF,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js
index bbb4f6a..3bba4fc 100644
--- a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js
+++ b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js
@@ -1,8 +1,7 @@
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.createSentryMetroSerializer = exports.withSentryExpoSerializers = void 0;
+exports.createSentryMetroSerializer = exports.getSentryExpoConfig = void 0;
 const tslib_1 = require("tslib");
 const crypto = require("crypto");
-const metro_1 = require("metro");
 const countLines = require("metro/src/lib/countLines");
 const utils_1 = require("./utils");
 const utils_2 = require("./vendor/metro/utils");
@@ -12,28 +11,35 @@ const PRELUDE_MODULE_PATH = '__prelude__';
 const SOURCE_MAP_COMMENT = '//# sourceMappingURL=';
 const DEBUG_ID_COMMENT = '//# debugId=';
 /**
- * This function will overwrite any existing custom serializer with default Expo and Sentry serializers.
+ * This config will overwrite any existing custom serializer with default Expo and Sentry serializers.
  *
  * To use custom serializers, use `createSentryMetroSerializer(customSerializer)` instead.
  */
-function withSentryExpoSerializers(config) {
-    const { withExpoSerializers } = loadExpoSerializersModule();
-    const sentryConfig = {
-        serializer: {
-            customSerializer: (0, exports.createSentryMetroSerializer)(),
-        },
-    };
-    const finalConfig = (0, metro_1.mergeConfig)(config, sentryConfig);
-    return withExpoSerializers(finalConfig);
+function getSentryExpoConfig(projectRoot) {
+    const { getDefaultConfig } = loadExpoMetroConfigModule();
+    return getDefaultConfig(projectRoot, { unstable_beforeAssetSerializationPlugins: [unstable_beforeAssetSerializationPlugin] });
+}
+exports.getSentryExpoConfig = getSentryExpoConfig;
+function unstable_beforeAssetSerializationPlugin({ graph, premodules, debugId }) {
+    if (graph.transformOptions.hot || !debugId) {
+        return premodules;
+    }
+    const debugIdModuleExists = premodules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;
+    if (debugIdModuleExists) {
+        // eslint-disable-next-line no-console
+        console.warn('Debug ID module found. Skipping Sentry Debug ID module...');
+        return premodules;
+    }
+    const debugIdModule = createDebugIdModule(debugId);
+    return [...addDebugIdModule(premodules, debugIdModule)];
 }
-exports.withSentryExpoSerializers = withSentryExpoSerializers;
-function loadExpoSerializersModule() {
+function loadExpoMetroConfigModule() {
     try {
         // eslint-disable-next-line @typescript-eslint/no-var-requires
-        return require('@expo/metro-config/build/serializer/withExpoSerializers');
+        return require('expo/metro-config');
     }
     catch (e) {
-        throw new Error('Unable to load `withExpoSerializers` from `@expo/metro-config`. Make sure you have Expo installed.');
+        throw new Error('Unable to load `expo/metro-config`. Make sure you have Expo installed.');
     }
 }
 /**
diff --git a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js.map b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js.map
index 456f581..d82aaad 100644
--- a/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js.map
+++ b/node_modules/@sentry/react-native/dist/js/tools/sentryMetroSerializer.js.map
@@ -1 +1 @@
-{"version":3,"file":"sentryMetroSerializer.js","sourceRoot":"","sources":["../../../src/js/tools/sentryMetroSerializer.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AAEjC,iCAAoC;AACpC,uDAAuD;AAGvD,mCAA0G;AAC1G,gDAAoE;AAIpE,MAAM,qBAAqB,GAAG,2BAA2B,CAAC;AAC1D,MAAM,oBAAoB,GAAG,aAAa,CAAC;AAC3C,MAAM,mBAAmB,GAAG,aAAa,CAAC;AAC1C,MAAM,kBAAkB,GAAG,uBAAuB,CAAC;AACnD,MAAM,gBAAgB,GAAG,cAAc,CAAC;AAExC;;;;GAIG;AACH,SAAgB,yBAAyB,CAAC,MAAmB;IAC3D,MAAM,EAAE,mBAAmB,EAAE,GAAG,yBAAyB,EAAE,CAAC;IAE5D,MAAM,YAAY,GAAG;QACnB,UAAU,EAAE;YACV,gBAAgB,EAAE,IAAA,mCAA2B,GAAE;SAChD;KACa,CAAC;IAEjB,MAAM,WAAW,GAAG,IAAA,mBAAW,EAAC,MAAM,EAAE,YAAY,CAAC,CAAC;IACtD,OAAO,mBAAmB,CAAC,WAAW,CAAC,CAAC;AAC1C,CAAC;AAXD,8DAWC;AAED,SAAS,yBAAyB;IAGhC,IAAI;QACF,8DAA8D;QAC9D,OAAO,OAAO,CAAC,yDAAyD,CAAC,CAAC;KAC3E;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,IAAI,KAAK,CACb,oGAAoG,CACrG,CAAC;KACH;AACH,CAAC;AAED;;;;;GAKG;AACI,MAAM,2BAA2B,GAAG,CAAC,gBAAkC,EAAmB,EAAE;IACjG,MAAM,UAAU,GAAG,gBAAgB,IAAI,IAAA,oCAA4B,GAAE,CAAC;IACtE,OAAO,UAAgB,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO;;YAC3D,IAAI,KAAK,CAAC,gBAAgB,CAAC,GAAG,EAAE;gBAC9B,OAAO,UAAU,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC3D;YAED,MAAM,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC;YACvG,IAAI,mBAAmB,EAAE;gBACvB,sCAAsC;gBACtC,OAAO,CAAC,IAAI,CAAC,2DAA2D,CAAC,CAAC;gBAC1E,OAAO,UAAU,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC3D;YAED,MAAM,aAAa,GAAG,mBAAmB,CAAC,qBAAqB,CAAC,CAAC;YACjE,OAAO,CAAC,oBAAoB,GAAG,0BAA0B,CAAC,aAAa,CAAC,CAAC;YACzE,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;YAEvE,yBAAyB;YACzB,MAAM,gBAAgB,GAAG,UAAU,CAAC,UAAU,EAAE,kBAAkB,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YACpF,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG,MAAM,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;YAEnG,qCAAqC;YACrC,MAAM,OAAO,GAAG,IAAA,wCAAgC,EAAC,UAAU,CAAC,CAAC;YAC7D,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAM,IAAI,KAAK,CACb,iHAAiH,CAClH,CAAC;aACH;YACD,gFAAgF;YAChF,sCAAsC;YACtC,OAAO,CAAC,GAAG,CAAC,OAAO,GAAG,oBAAoB,OAAO,EAAE,CAAC,CAAC;YAErD,MAAM,cAAc,GAAG,GAAG,gBAAgB,GAAG,OAAO,EAAE,CAAC;YACvD,MAAM,uBAAuB,GAAG,UAAU,CAAC,WAAW,CAAC,kBAAkB,CAAC,CAAC;YAC3E,MAAM,qBAAqB,GACzB,uBAAuB,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,sEAAsE;oBACtE,GAAG,UAAU,KAAK,cAAc,EAAE;gBACpC,CAAC,CAAC,2EAA2E;oBAC3E,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,uBAAuB,CAAC,GAAG,cAAc,KAAK,UAAU,CAAC,SAAS,CAC3F,uBAAuB,CACxB,EAAE,CAAC;YAEV,MAAM,SAAS,GAAc,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YACzD,sFAAsF;YACtF,SAAS,CAAC,UAAU,CAAC,GAAG,OAAO,CAAC;YAChC,SAAS,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC;YAE/B,OAAO;gBACL,IAAI,EAAE,qBAAqB;gBAC3B,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;aAC/B,CAAC;QACJ,CAAC;KAAA,CAAC;AACJ,CAAC,CAAC;AAtDW,QAAA,2BAA2B,+BAsDtC;AAEF;;;;;;;GAOG;AACH,SAAS,0BAA0B,CAAC,aAA8E;IAChH,OAAO,CAAC,MAAc,EAAE,EAAE;QACxB,MAAM,OAAO,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACzC,aAAa,CAAC,SAAS,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;QACtF,MAAM,CAAC,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAChD,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,gBAAgB,CACvB,UAA0C,EAC1C,aAAsC;IAEtC,MAAM,kBAAkB,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC;IAC3C,IACE,kBAAkB,CAAC,MAAM,GAAG,CAAC;QAC7B,kBAAkB,CAAC,CAAC,CAAC,KAAK,SAAS;QACnC,kBAAkB,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,mBAAmB,EAClD;QACA,sEAAsE;QACtE,kBAAkB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1C,kBAAkB,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;KACvC;SAAM;QACL,kBAAkB,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;KAC3C;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED,SAAe,uBAAuB,CAAC,gBAAuC;;QAC5E,IAAI,OAAO,gBAAgB,KAAK,QAAQ,EAAE;YACxC,OAAO,EAAE,IAAI,EAAE,gBAAgB,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;SAC9C;QAED,IAAI,KAAK,IAAI,gBAAgB,EAAE;YAC7B,OAAO,EAAE,IAAI,EAAE,gBAAgB,CAAC,IAAI,EAAE,GAAG,EAAE,gBAAgB,CAAC,GAAG,EAAE,CAAC;SACnE;QAED,MAAM,aAAa,GAAG,MAAM,gBAAgB,CAAC;QAC7C,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;YACrC,OAAO,EAAE,IAAI,EAAE,aAAa,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;SAC3C;QAED,OAAO,EAAE,IAAI,EAAE,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,CAAC,GAAG,EAAE,CAAC;IAC9D,CAAC;CAAA;AAED,SAAS,mBAAmB,CAAC,OAAe;IAC1C,IAAI,WAAW,GAAG,IAAA,4BAAoB,EAAC,OAAO,CAAC,CAAC;IAEhD,OAAO;QACL,SAAS,EAAE,CAAC,IAAY,EAAE,EAAE;YAC1B,WAAW,GAAG,IAAI,CAAC;QACrB,CAAC;QACD,YAAY,EAAE,IAAI,GAAG,EAAE;QACvB,SAAS,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;QACzC,mBAAmB,EAAE,IAAA,iBAAS,GAAE;QAChC,IAAI,EAAE,oBAAoB;QAC1B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,mBAAmB;gBACzB,IAAI,EAAE;oBACJ,IAAI,EAAE,WAAW;oBACjB,SAAS,EAAE,UAAU,CAAC,WAAW,CAAC;oBAClC,GAAG,EAAE,EAAE;iBACR;aACF;SACF;KACF,CAAC;AACJ,CAAC;AAED,SAAS,gBAAgB,CAAC,MAAc;IACtC,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACtC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACxB,KAAK,MAAM,CAAC,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE;QACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KACnB;IACD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEzB,MAAM,OAAO,GAAG,IAAA,oBAAY,EAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IACjD,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,aAAa,CAAC,IAAY,EAAE,OAAe;IAClD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,qBAAqB,EAAE,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;AACvE,CAAC","sourcesContent":["import * as crypto from 'crypto';\nimport type { MetroConfig, MixedOutput, Module } from 'metro';\nimport { mergeConfig } from 'metro';\nimport * as countLines from 'metro/src/lib/countLines';\n\nimport type { Bundle, MetroSerializer, MetroSerializerOutput, SerializedBundle, VirtualJSOutput } from './utils';\nimport { createDebugIdSnippet, createSet, determineDebugIdFromBundleSource, stringToUUID } from './utils';\nimport { createDefaultMetroSerializer } from './vendor/metro/utils';\n\ntype SourceMap = Record<string, unknown>;\n\nconst DEBUG_ID_PLACE_HOLDER = '__debug_id_place_holder__';\nconst DEBUG_ID_MODULE_PATH = '__debugid__';\nconst PRELUDE_MODULE_PATH = '__prelude__';\nconst SOURCE_MAP_COMMENT = '//# sourceMappingURL=';\nconst DEBUG_ID_COMMENT = '//# debugId=';\n\n/**\n * This function will overwrite any existing custom serializer with default Expo and Sentry serializers.\n *\n * To use custom serializers, use `createSentryMetroSerializer(customSerializer)` instead.\n */\nexport function withSentryExpoSerializers(config: MetroConfig): MetroConfig {\n  const { withExpoSerializers } = loadExpoSerializersModule();\n\n  const sentryConfig = {\n    serializer: {\n      customSerializer: createSentryMetroSerializer(),\n    },\n  } as MetroConfig;\n\n  const finalConfig = mergeConfig(config, sentryConfig);\n  return withExpoSerializers(finalConfig);\n}\n\nfunction loadExpoSerializersModule(): {\n  withExpoSerializers: (config: MetroConfig) => MetroConfig;\n} {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require('@expo/metro-config/build/serializer/withExpoSerializers');\n  } catch (e) {\n    throw new Error(\n      'Unable to load `withExpoSerializers` from `@expo/metro-config`. Make sure you have Expo installed.',\n    );\n  }\n}\n\n/**\n * Creates a Metro serializer that adds Debug ID module to the plain bundle.\n * The Debug ID module is a virtual module that provides a debug ID in runtime.\n *\n * RAM Bundles do not support custom serializers.\n */\nexport const createSentryMetroSerializer = (customSerializer?: MetroSerializer): MetroSerializer => {\n  const serializer = customSerializer || createDefaultMetroSerializer();\n  return async function (entryPoint, preModules, graph, options) {\n    if (graph.transformOptions.hot) {\n      return serializer(entryPoint, preModules, graph, options);\n    }\n\n    const debugIdModuleExists = preModules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;\n    if (debugIdModuleExists) {\n      // eslint-disable-next-line no-console\n      console.warn('Debug ID module found. Skipping Sentry Debug ID module...');\n      return serializer(entryPoint, preModules, graph, options);\n    }\n\n    const debugIdModule = createDebugIdModule(DEBUG_ID_PLACE_HOLDER);\n    options.sentryBundleCallback = createSentryBundleCallback(debugIdModule);\n    const modifiedPreModules = addDebugIdModule(preModules, debugIdModule);\n\n    // Run wrapped serializer\n    const serializerResult = serializer(entryPoint, modifiedPreModules, graph, options);\n    const { code: bundleCode, map: bundleMapString } = await extractSerializerResult(serializerResult);\n\n    // Add debug id comment to the bundle\n    const debugId = determineDebugIdFromBundleSource(bundleCode);\n    if (!debugId) {\n      throw new Error(\n        'Debug ID was not found in the bundle. Call `options.sentryBundleCallback` if you are using a custom serializer.',\n      );\n    }\n    // Only print debug id for command line builds => not hot reload from dev server\n    // eslint-disable-next-line no-console\n    console.log('info ' + `Bundle Debug ID: ${debugId}`);\n\n    const debugIdComment = `${DEBUG_ID_COMMENT}${debugId}`;\n    const indexOfSourceMapComment = bundleCode.lastIndexOf(SOURCE_MAP_COMMENT);\n    const bundleCodeWithDebugId =\n      indexOfSourceMapComment === -1\n        ? // If source map comment is missing lets just add the debug id comment\n          `${bundleCode}\\n${debugIdComment}`\n        : // If source map comment is present lets add the debug id comment before it\n          `${bundleCode.substring(0, indexOfSourceMapComment) + debugIdComment}\\n${bundleCode.substring(\n            indexOfSourceMapComment,\n          )}`;\n\n    const bundleMap: SourceMap = JSON.parse(bundleMapString);\n    // For now we write both fields until we know what will become the standard - if ever.\n    bundleMap['debug_id'] = debugId;\n    bundleMap['debugId'] = debugId;\n\n    return {\n      code: bundleCodeWithDebugId,\n      map: JSON.stringify(bundleMap),\n    };\n  };\n};\n\n/**\n * This function is expected to be called after serializer creates the final bundle object\n * and before the source maps are generated.\n *\n * It injects a debug ID into the bundle and returns the modified bundle.\n *\n * Access it via `options.sentryBundleCallback` in your custom serializer.\n */\nfunction createSentryBundleCallback(debugIdModule: Module<VirtualJSOutput> & { setSource: (code: string) => void }) {\n  return (bundle: Bundle) => {\n    const debugId = calculateDebugId(bundle);\n    debugIdModule.setSource(injectDebugId(debugIdModule.getSource().toString(), debugId));\n    bundle.pre = injectDebugId(bundle.pre, debugId);\n    return bundle;\n  };\n}\n\nfunction addDebugIdModule(\n  preModules: readonly Module<MixedOutput>[],\n  debugIdModule: Module<VirtualJSOutput>,\n): readonly Module<MixedOutput>[] {\n  const modifiedPreModules = [...preModules];\n  if (\n    modifiedPreModules.length > 0 &&\n    modifiedPreModules[0] !== undefined &&\n    modifiedPreModules[0].path === PRELUDE_MODULE_PATH\n  ) {\n    // prelude module must be first as it measures the bundle startup time\n    modifiedPreModules.unshift(preModules[0]);\n    modifiedPreModules[1] = debugIdModule;\n  } else {\n    modifiedPreModules.unshift(debugIdModule);\n  }\n  return modifiedPreModules;\n}\n\nasync function extractSerializerResult(serializerResult: MetroSerializerOutput): Promise<SerializedBundle> {\n  if (typeof serializerResult === 'string') {\n    return { code: serializerResult, map: '{}' };\n  }\n\n  if ('map' in serializerResult) {\n    return { code: serializerResult.code, map: serializerResult.map };\n  }\n\n  const awaitedResult = await serializerResult;\n  if (typeof awaitedResult === 'string') {\n    return { code: awaitedResult, map: '{}' };\n  }\n\n  return { code: awaitedResult.code, map: awaitedResult.map };\n}\n\nfunction createDebugIdModule(debugId: string): Module<VirtualJSOutput> & { setSource: (code: string) => void } {\n  let debugIdCode = createDebugIdSnippet(debugId);\n\n  return {\n    setSource: (code: string) => {\n      debugIdCode = code;\n    },\n    dependencies: new Map(),\n    getSource: () => Buffer.from(debugIdCode),\n    inverseDependencies: createSet(),\n    path: DEBUG_ID_MODULE_PATH,\n    output: [\n      {\n        type: 'js/script/virtual',\n        data: {\n          code: debugIdCode,\n          lineCount: countLines(debugIdCode),\n          map: [],\n        },\n      },\n    ],\n  };\n}\n\nfunction calculateDebugId(bundle: Bundle): string {\n  const hash = crypto.createHash('md5');\n  hash.update(bundle.pre);\n  for (const [, code] of bundle.modules) {\n    hash.update(code);\n  }\n  hash.update(bundle.post);\n\n  const debugId = stringToUUID(hash.digest('hex'));\n  return debugId;\n}\n\nfunction injectDebugId(code: string, debugId: string): string {\n  return code.replace(new RegExp(DEBUG_ID_PLACE_HOLDER, 'g'), debugId);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"sentryMetroSerializer.js","sourceRoot":"","sources":["../../../src/js/tools/sentryMetroSerializer.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AAEjC,uDAAuD;AAGvD,mCAA0G;AAC1G,gDAAoE;AAIpE,MAAM,qBAAqB,GAAG,2BAA2B,CAAC;AAC1D,MAAM,oBAAoB,GAAG,aAAa,CAAC;AAC3C,MAAM,mBAAmB,GAAG,aAAa,CAAC;AAC1C,MAAM,kBAAkB,GAAG,uBAAuB,CAAC;AACnD,MAAM,gBAAgB,GAAG,cAAc,CAAC;AAExC;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,WAAmB;IACrD,MAAM,EAAE,gBAAgB,EAAE,GAAG,yBAAyB,EAAE,CAAC;IACzD,OAAO,gBAAgB,CAAC,WAAW,EAAE,EAAC,wCAAwC,EAAE,CAAC,uCAAuC,CAAC,EAAC,CAAC,CAAC;AAC9H,CAAC;AAHD,kDAGC;AAED,SAAS,uCAAuC,CAAC,EAAC,KAAK,EAAE,UAAU,EAAE,OAAO,EAI3E;IACC,IAAI,KAAK,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE;QAC1C,OAAO,UAAU,CAAC;KACnB;IAED,MAAM,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC;IACvG,IAAI,mBAAmB,EAAE;QACvB,sCAAsC;QACtC,OAAO,CAAC,IAAI,CAAC,2DAA2D,CAAC,CAAC;QAC1E,OAAO,UAAU,CAAC;KACnB;IAED,MAAM,aAAa,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;IACnD,OAAO,CAAC,GAAG,gBAAgB,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC,CAAC;AAC1D,CAAC;AAED,SAAS,yBAAyB;IAWhC,IAAI;QACF,8DAA8D;QAC9D,OAAO,OAAO,CAAC,mBAAmB,CAAC,CAAC;KACrC;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,IAAI,KAAK,CACb,wEAAwE,CACzE,CAAC;KACH;AACH,CAAC;AAED;;;;;GAKG;AACI,MAAM,2BAA2B,GAAG,CAAC,gBAAkC,EAAmB,EAAE;IACjG,MAAM,UAAU,GAAG,gBAAgB,IAAI,IAAA,oCAA4B,GAAE,CAAC;IACtE,OAAO,UAAgB,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO;;YAC3D,IAAI,KAAK,CAAC,gBAAgB,CAAC,GAAG,EAAE;gBAC9B,OAAO,UAAU,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC3D;YAED,MAAM,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC;YACvG,IAAI,mBAAmB,EAAE;gBACvB,sCAAsC;gBACtC,OAAO,CAAC,IAAI,CAAC,2DAA2D,CAAC,CAAC;gBAC1E,OAAO,UAAU,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;aAC3D;YAED,MAAM,aAAa,GAAG,mBAAmB,CAAC,qBAAqB,CAAC,CAAC;YACjE,OAAO,CAAC,oBAAoB,GAAG,0BAA0B,CAAC,aAAa,CAAC,CAAC;YACzE,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;YAEvE,yBAAyB;YACzB,MAAM,gBAAgB,GAAG,UAAU,CAAC,UAAU,EAAE,kBAAkB,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YACpF,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG,MAAM,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;YAEnG,qCAAqC;YACrC,MAAM,OAAO,GAAG,IAAA,wCAAgC,EAAC,UAAU,CAAC,CAAC;YAC7D,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAM,IAAI,KAAK,CACb,iHAAiH,CAClH,CAAC;aACH;YACD,gFAAgF;YAChF,sCAAsC;YACtC,OAAO,CAAC,GAAG,CAAC,OAAO,GAAG,oBAAoB,OAAO,EAAE,CAAC,CAAC;YAErD,MAAM,cAAc,GAAG,GAAG,gBAAgB,GAAG,OAAO,EAAE,CAAC;YACvD,MAAM,uBAAuB,GAAG,UAAU,CAAC,WAAW,CAAC,kBAAkB,CAAC,CAAC;YAC3E,MAAM,qBAAqB,GACzB,uBAAuB,KAAK,CAAC,CAAC;gBAC5B,CAAC,CAAC,sEAAsE;oBACtE,GAAG,UAAU,KAAK,cAAc,EAAE;gBACpC,CAAC,CAAC,2EAA2E;oBAC3E,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,uBAAuB,CAAC,GAAG,cAAc,KAAK,UAAU,CAAC,SAAS,CAC3F,uBAAuB,CACxB,EAAE,CAAC;YAEV,MAAM,SAAS,GAAc,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YACzD,sFAAsF;YACtF,SAAS,CAAC,UAAU,CAAC,GAAG,OAAO,CAAC;YAChC,SAAS,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC;YAE/B,OAAO;gBACL,IAAI,EAAE,qBAAqB;gBAC3B,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;aAC/B,CAAC;QACJ,CAAC;KAAA,CAAC;AACJ,CAAC,CAAC;AAtDW,QAAA,2BAA2B,+BAsDtC;AAEF;;;;;;;GAOG;AACH,SAAS,0BAA0B,CAAC,aAA8E;IAChH,OAAO,CAAC,MAAc,EAAE,EAAE;QACxB,MAAM,OAAO,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACzC,aAAa,CAAC,SAAS,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;QACtF,MAAM,CAAC,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAChD,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,gBAAgB,CACvB,UAA0C,EAC1C,aAAsC;IAEtC,MAAM,kBAAkB,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC;IAC3C,IACE,kBAAkB,CAAC,MAAM,GAAG,CAAC;QAC7B,kBAAkB,CAAC,CAAC,CAAC,KAAK,SAAS;QACnC,kBAAkB,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,mBAAmB,EAClD;QACA,sEAAsE;QACtE,kBAAkB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1C,kBAAkB,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;KACvC;SAAM;QACL,kBAAkB,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;KAC3C;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED,SAAe,uBAAuB,CAAC,gBAAuC;;QAC5E,IAAI,OAAO,gBAAgB,KAAK,QAAQ,EAAE;YACxC,OAAO,EAAE,IAAI,EAAE,gBAAgB,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;SAC9C;QAED,IAAI,KAAK,IAAI,gBAAgB,EAAE;YAC7B,OAAO,EAAE,IAAI,EAAE,gBAAgB,CAAC,IAAI,EAAE,GAAG,EAAE,gBAAgB,CAAC,GAAG,EAAE,CAAC;SACnE;QAED,MAAM,aAAa,GAAG,MAAM,gBAAgB,CAAC;QAC7C,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;YACrC,OAAO,EAAE,IAAI,EAAE,aAAa,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;SAC3C;QAED,OAAO,EAAE,IAAI,EAAE,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,CAAC,GAAG,EAAE,CAAC;IAC9D,CAAC;CAAA;AAED,SAAS,mBAAmB,CAAC,OAAe;IAC1C,IAAI,WAAW,GAAG,IAAA,4BAAoB,EAAC,OAAO,CAAC,CAAC;IAEhD,OAAO;QACL,SAAS,EAAE,CAAC,IAAY,EAAE,EAAE;YAC1B,WAAW,GAAG,IAAI,CAAC;QACrB,CAAC;QACD,YAAY,EAAE,IAAI,GAAG,EAAE;QACvB,SAAS,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;QACzC,mBAAmB,EAAE,IAAA,iBAAS,GAAE;QAChC,IAAI,EAAE,oBAAoB;QAC1B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,mBAAmB;gBACzB,IAAI,EAAE;oBACJ,IAAI,EAAE,WAAW;oBACjB,SAAS,EAAE,UAAU,CAAC,WAAW,CAAC;oBAClC,GAAG,EAAE,EAAE;iBACR;aACF;SACF;KACF,CAAC;AACJ,CAAC;AAED,SAAS,gBAAgB,CAAC,MAAc;IACtC,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACtC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACxB,KAAK,MAAM,CAAC,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE;QACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KACnB;IACD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEzB,MAAM,OAAO,GAAG,IAAA,oBAAY,EAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IACjD,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,aAAa,CAAC,IAAY,EAAE,OAAe;IAClD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,qBAAqB,EAAE,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;AACvE,CAAC","sourcesContent":["import * as crypto from 'crypto';\nimport type { MetroConfig, MixedOutput, Module, ReadOnlyGraph } from 'metro';\nimport * as countLines from 'metro/src/lib/countLines';\n\nimport type { Bundle, MetroSerializer, MetroSerializerOutput, SerializedBundle, VirtualJSOutput } from './utils';\nimport { createDebugIdSnippet, createSet, determineDebugIdFromBundleSource, stringToUUID } from './utils';\nimport { createDefaultMetroSerializer } from './vendor/metro/utils';\n\ntype SourceMap = Record<string, unknown>;\n\nconst DEBUG_ID_PLACE_HOLDER = '__debug_id_place_holder__';\nconst DEBUG_ID_MODULE_PATH = '__debugid__';\nconst PRELUDE_MODULE_PATH = '__prelude__';\nconst SOURCE_MAP_COMMENT = '//# sourceMappingURL=';\nconst DEBUG_ID_COMMENT = '//# debugId=';\n\n/**\n * This config will overwrite any existing custom serializer with default Expo and Sentry serializers.\n *\n * To use custom serializers, use `createSentryMetroSerializer(customSerializer)` instead.\n */\nexport function getSentryExpoConfig(projectRoot: string): MetroConfig {\n  const { getDefaultConfig } = loadExpoMetroConfigModule();\n  return getDefaultConfig(projectRoot, {unstable_beforeAssetSerializationPlugins: [unstable_beforeAssetSerializationPlugin]});\n}\n\nfunction unstable_beforeAssetSerializationPlugin({graph, premodules, debugId}: {\n  graph: ReadOnlyGraph<MixedOutput>;\n  premodules: Module[];\n  debugId?: string;\n}) : Module[] {\n  if (graph.transformOptions.hot || !debugId) {\n    return premodules;\n  }\n\n  const debugIdModuleExists = premodules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;\n  if (debugIdModuleExists) {\n    // eslint-disable-next-line no-console\n    console.warn('Debug ID module found. Skipping Sentry Debug ID module...');\n    return premodules;\n  }\n\n  const debugIdModule = createDebugIdModule(debugId);\n  return [...addDebugIdModule(premodules, debugIdModule)];\n}\n\nfunction loadExpoMetroConfigModule(): {\n  getDefaultConfig: (\n    projectRoot: string,\n    options: {\n      unstable_beforeAssetSerializationPlugins?: ((serializationInput: {\n        graph: ReadOnlyGraph<MixedOutput>;\n        premodules: Module[];\n        debugId?: string;\n    }) => Module[])[];}\n  ) => MetroConfig;\n} {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require('expo/metro-config');\n  } catch (e) {\n    throw new Error(\n      'Unable to load `expo/metro-config`. Make sure you have Expo installed.',\n    );\n  }\n}\n\n/**\n * Creates a Metro serializer that adds Debug ID module to the plain bundle.\n * The Debug ID module is a virtual module that provides a debug ID in runtime.\n *\n * RAM Bundles do not support custom serializers.\n */\nexport const createSentryMetroSerializer = (customSerializer?: MetroSerializer): MetroSerializer => {\n  const serializer = customSerializer || createDefaultMetroSerializer();\n  return async function (entryPoint, preModules, graph, options) {\n    if (graph.transformOptions.hot) {\n      return serializer(entryPoint, preModules, graph, options);\n    }\n\n    const debugIdModuleExists = preModules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;\n    if (debugIdModuleExists) {\n      // eslint-disable-next-line no-console\n      console.warn('Debug ID module found. Skipping Sentry Debug ID module...');\n      return serializer(entryPoint, preModules, graph, options);\n    }\n\n    const debugIdModule = createDebugIdModule(DEBUG_ID_PLACE_HOLDER);\n    options.sentryBundleCallback = createSentryBundleCallback(debugIdModule);\n    const modifiedPreModules = addDebugIdModule(preModules, debugIdModule);\n\n    // Run wrapped serializer\n    const serializerResult = serializer(entryPoint, modifiedPreModules, graph, options);\n    const { code: bundleCode, map: bundleMapString } = await extractSerializerResult(serializerResult);\n\n    // Add debug id comment to the bundle\n    const debugId = determineDebugIdFromBundleSource(bundleCode);\n    if (!debugId) {\n      throw new Error(\n        'Debug ID was not found in the bundle. Call `options.sentryBundleCallback` if you are using a custom serializer.',\n      );\n    }\n    // Only print debug id for command line builds => not hot reload from dev server\n    // eslint-disable-next-line no-console\n    console.log('info ' + `Bundle Debug ID: ${debugId}`);\n\n    const debugIdComment = `${DEBUG_ID_COMMENT}${debugId}`;\n    const indexOfSourceMapComment = bundleCode.lastIndexOf(SOURCE_MAP_COMMENT);\n    const bundleCodeWithDebugId =\n      indexOfSourceMapComment === -1\n        ? // If source map comment is missing lets just add the debug id comment\n          `${bundleCode}\\n${debugIdComment}`\n        : // If source map comment is present lets add the debug id comment before it\n          `${bundleCode.substring(0, indexOfSourceMapComment) + debugIdComment}\\n${bundleCode.substring(\n            indexOfSourceMapComment,\n          )}`;\n\n    const bundleMap: SourceMap = JSON.parse(bundleMapString);\n    // For now we write both fields until we know what will become the standard - if ever.\n    bundleMap['debug_id'] = debugId;\n    bundleMap['debugId'] = debugId;\n\n    return {\n      code: bundleCodeWithDebugId,\n      map: JSON.stringify(bundleMap),\n    };\n  };\n};\n\n/**\n * This function is expected to be called after serializer creates the final bundle object\n * and before the source maps are generated.\n *\n * It injects a debug ID into the bundle and returns the modified bundle.\n *\n * Access it via `options.sentryBundleCallback` in your custom serializer.\n */\nfunction createSentryBundleCallback(debugIdModule: Module<VirtualJSOutput> & { setSource: (code: string) => void }) {\n  return (bundle: Bundle) => {\n    const debugId = calculateDebugId(bundle);\n    debugIdModule.setSource(injectDebugId(debugIdModule.getSource().toString(), debugId));\n    bundle.pre = injectDebugId(bundle.pre, debugId);\n    return bundle;\n  };\n}\n\nfunction addDebugIdModule(\n  preModules: readonly Module<MixedOutput>[],\n  debugIdModule: Module<VirtualJSOutput>,\n): readonly Module<MixedOutput>[] {\n  const modifiedPreModules = [...preModules];\n  if (\n    modifiedPreModules.length > 0 &&\n    modifiedPreModules[0] !== undefined &&\n    modifiedPreModules[0].path === PRELUDE_MODULE_PATH\n  ) {\n    // prelude module must be first as it measures the bundle startup time\n    modifiedPreModules.unshift(preModules[0]);\n    modifiedPreModules[1] = debugIdModule;\n  } else {\n    modifiedPreModules.unshift(debugIdModule);\n  }\n  return modifiedPreModules;\n}\n\nasync function extractSerializerResult(serializerResult: MetroSerializerOutput): Promise<SerializedBundle> {\n  if (typeof serializerResult === 'string') {\n    return { code: serializerResult, map: '{}' };\n  }\n\n  if ('map' in serializerResult) {\n    return { code: serializerResult.code, map: serializerResult.map };\n  }\n\n  const awaitedResult = await serializerResult;\n  if (typeof awaitedResult === 'string') {\n    return { code: awaitedResult, map: '{}' };\n  }\n\n  return { code: awaitedResult.code, map: awaitedResult.map };\n}\n\nfunction createDebugIdModule(debugId: string): Module<VirtualJSOutput> & { setSource: (code: string) => void } {\n  let debugIdCode = createDebugIdSnippet(debugId);\n\n  return {\n    setSource: (code: string) => {\n      debugIdCode = code;\n    },\n    dependencies: new Map(),\n    getSource: () => Buffer.from(debugIdCode),\n    inverseDependencies: createSet(),\n    path: DEBUG_ID_MODULE_PATH,\n    output: [\n      {\n        type: 'js/script/virtual',\n        data: {\n          code: debugIdCode,\n          lineCount: countLines(debugIdCode),\n          map: [],\n        },\n      },\n    ],\n  };\n}\n\nfunction calculateDebugId(bundle: Bundle): string {\n  const hash = crypto.createHash('md5');\n  hash.update(bundle.pre);\n  for (const [, code] of bundle.modules) {\n    hash.update(code);\n  }\n  hash.update(bundle.post);\n\n  const debugId = stringToUUID(hash.digest('hex'));\n  return debugId;\n}\n\nfunction injectDebugId(code: string, debugId: string): string {\n  return code.replace(new RegExp(DEBUG_ID_PLACE_HOLDER, 'g'), debugId);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@sentry/react-native/dist/js/vendor/.DS_Store b/node_modules/@sentry/react-native/dist/js/vendor/.DS_Store
new file mode 100644
index 0000000..1972d3a
Binary files /dev/null and b/node_modules/@sentry/react-native/dist/js/vendor/.DS_Store differ
diff --git a/node_modules/@sentry/react-native/src/js/breadcrumb.ts b/node_modules/@sentry/react-native/src/js/breadcrumb.ts
new file mode 100644
index 0000000..eaf3388
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/breadcrumb.ts
@@ -0,0 +1,42 @@
+import type { Breadcrumb, SeverityLevel } from '@sentry/types';
+import { severityLevelFromString } from '@sentry/utils';
+
+export const DEFAULT_BREADCRUMB_LEVEL: SeverityLevel = 'info';
+
+type BreadcrumbCandidate = {
+  [K in keyof Partial<Breadcrumb>]: unknown;
+};
+
+/**
+ * Convert plain object to a valid Breadcrumb
+ */
+export function breadcrumbFromObject(candidate: BreadcrumbCandidate): Breadcrumb {
+  const breadcrumb: Breadcrumb = {};
+
+  if (typeof candidate.type === 'string') {
+    breadcrumb.type = candidate.type;
+  }
+  if (typeof candidate.level === 'string') {
+    breadcrumb.level = severityLevelFromString(candidate.level);
+  }
+  if (typeof candidate.event_id === 'string') {
+    breadcrumb.event_id = candidate.event_id;
+  }
+  if (typeof candidate.category === 'string') {
+    breadcrumb.category = candidate.category;
+  }
+  if (typeof candidate.message === 'string') {
+    breadcrumb.message = candidate.message;
+  }
+  if (typeof candidate.data === 'object' && candidate.data !== null) {
+    breadcrumb.data = candidate.data;
+  }
+  if (typeof candidate.timestamp === 'string') {
+    const timestampSeconds = Date.parse(candidate.timestamp) / 1000; // breadcrumb timestamp is in seconds
+    if (!isNaN(timestampSeconds)) {
+      breadcrumb.timestamp = timestampSeconds;
+    }
+  }
+
+  return breadcrumb;
+}
diff --git a/node_modules/@sentry/react-native/src/js/client.ts b/node_modules/@sentry/react-native/src/js/client.ts
new file mode 100644
index 0000000..875122b
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/client.ts
@@ -0,0 +1,206 @@
+import { eventFromException, eventFromMessage } from '@sentry/browser';
+import { BaseClient } from '@sentry/core';
+import type {
+  ClientReportEnvelope,
+  ClientReportItem,
+  Envelope,
+  Event,
+  EventHint,
+  Exception,
+  Outcome,
+  SeverityLevel,
+  Thread,
+  UserFeedback,
+} from '@sentry/types';
+import { dateTimestampInSeconds, logger, SentryError } from '@sentry/utils';
+import { Alert } from 'react-native';
+
+import { createIntegration } from './integrations/factory';
+import { defaultSdkInfo } from './integrations/sdkinfo';
+import type { ReactNativeClientOptions } from './options';
+import { ReactNativeTracing } from './tracing';
+import { createUserFeedbackEnvelope, items } from './utils/envelope';
+import { ignoreRequireCycleLogs } from './utils/ignorerequirecyclelogs';
+import { mergeOutcomes } from './utils/outcome';
+import { NATIVE } from './wrapper';
+
+/**
+ * The Sentry React Native SDK Client.
+ *
+ * @see ReactNativeClientOptions for documentation on configuration options.
+ * @see SentryClient for usage documentation.
+ */
+export class ReactNativeClient extends BaseClient<ReactNativeClientOptions> {
+  private _outcomesBuffer: Outcome[];
+
+  /**
+   * Creates a new React Native SDK instance.
+   * @param options Configuration options for this SDK.
+   */
+  public constructor(options: ReactNativeClientOptions) {
+    ignoreRequireCycleLogs();
+    options._metadata = options._metadata || {};
+    options._metadata.sdk = options._metadata.sdk || defaultSdkInfo;
+    super(options);
+
+    this._outcomesBuffer = [];
+    void this._initNativeSdk();
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public eventFromException(exception: unknown, hint: EventHint = {}): PromiseLike<Event> {
+    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public eventFromMessage(message: string, level?: SeverityLevel, hint?: EventHint): PromiseLike<Event> {
+    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace).then(
+      (event: Event) => {
+        // TMP! Remove this function once JS SDK uses threads for messages
+        if (!event.exception?.values || event.exception.values.length <= 0) {
+          return event;
+        }
+        const values = event.exception.values.map(
+          (exception: Exception): Thread => ({
+            stacktrace: exception.stacktrace,
+          }),
+        );
+        (event as { threads?: { values: Thread[] } }).threads = { values };
+        delete event.exception;
+        return event;
+      },
+    );
+  }
+
+  /**
+   * If native client is available it will trigger a native crash.
+   * Use this only for testing purposes.
+   */
+  public nativeCrash(): void {
+    NATIVE.nativeCrash();
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public close(): PromiseLike<boolean> {
+    // As super.close() flushes queued events, we wait for that to finish before closing the native SDK.
+    return super.close().then((result: boolean) => {
+      return NATIVE.closeNativeSdk().then(() => result) as PromiseLike<boolean>;
+    });
+  }
+
+  /**
+   * Sends user feedback to Sentry.
+   */
+  public captureUserFeedback(feedback: UserFeedback): void {
+    const envelope = createUserFeedbackEnvelope(feedback, {
+      metadata: this._options._metadata,
+      dsn: this.getDsn(),
+      tunnel: this._options.tunnel,
+    });
+    this._sendEnvelope(envelope);
+  }
+
+  /**
+   * Sets up the integrations
+   */
+  public setupIntegrations(): void {
+    super.setupIntegrations();
+    const tracing = this.getIntegration(ReactNativeTracing);
+    const routingName = tracing?.options.routingInstrumentation?.name;
+    if (routingName) {
+      this.addIntegration(createIntegration(routingName));
+    }
+    const enableUserInteractionTracing = tracing?.options.enableUserInteractionTracing;
+    if (enableUserInteractionTracing) {
+      this.addIntegration(createIntegration('ReactNativeUserInteractionTracing'));
+    }
+  }
+
+  /**
+   * @inheritdoc
+   */
+  protected _sendEnvelope(envelope: Envelope): void {
+    const outcomes = this._clearOutcomes();
+    this._outcomesBuffer = mergeOutcomes(this._outcomesBuffer, outcomes);
+
+    if (this._options.sendClientReports) {
+      this._attachClientReportTo(this._outcomesBuffer, envelope as ClientReportEnvelope);
+    }
+
+    let shouldClearOutcomesBuffer = true;
+    if (this._transport && this._dsn) {
+      this.emit('beforeEnvelope', envelope);
+
+      this._transport.send(envelope).then(null, reason => {
+        if (reason instanceof SentryError) {
+          // SentryError is thrown by SyncPromise
+          shouldClearOutcomesBuffer = false;
+          // If this is called asynchronously we want the _outcomesBuffer to be cleared
+          logger.error('SentryError while sending event, keeping outcomes buffer:', reason);
+        } else {
+          logger.error('Error while sending event:', reason);
+        }
+      });
+    } else {
+      logger.error('Transport disabled');
+    }
+
+    if (shouldClearOutcomesBuffer) {
+      this._outcomesBuffer = []; // if send fails synchronously the _outcomesBuffer will stay intact
+    }
+  }
+
+  /**
+   * Starts native client with dsn and options
+   */
+  private async _initNativeSdk(): Promise<void> {
+    let didCallNativeInit = false;
+
+    try {
+      didCallNativeInit = await NATIVE.initNativeSdk(this._options);
+    } catch (_) {
+      this._showCannotConnectDialog();
+    } finally {
+      try {
+        this._options.onReady?.({ didCallNativeInit });
+      } catch (error) {
+        logger.error('The OnReady callback threw an error: ', error);
+      }
+    }
+  }
+
+  /**
+   * If the user is in development mode, and the native nagger is enabled then it will show an alert.
+   */
+  private _showCannotConnectDialog(): void {
+    if (__DEV__ && this._options.enableNativeNagger) {
+      Alert.alert(
+        'Sentry',
+        'Warning, could not connect to Sentry native SDK.\nIf you do not want to use the native component please pass `enableNative: false` in the options.\nVisit: https://docs.sentry.io/platforms/react-native/#linking for more details.',
+      );
+    }
+  }
+
+  /**
+   * Attaches a client report from outcomes to the envelope.
+   */
+  private _attachClientReportTo(outcomes: Outcome[], envelope: ClientReportEnvelope): void {
+    if (outcomes.length > 0) {
+      const clientReportItem: ClientReportItem = [
+        { type: 'client_report' },
+        {
+          timestamp: dateTimestampInSeconds(),
+          discarded_events: outcomes,
+        },
+      ];
+
+      envelope[items].push(clientReportItem);
+    }
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/index.ts b/node_modules/@sentry/react-native/src/js/index.ts
new file mode 100644
index 0000000..3997cca
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/index.ts
@@ -0,0 +1,84 @@
+export type {
+  Breadcrumb,
+  Request,
+  SdkInfo,
+  Event,
+  Exception,
+  StackFrame,
+  Stacktrace,
+  Thread,
+  User,
+  UserFeedback,
+} from '@sentry/types';
+
+export {
+  addGlobalEventProcessor,
+  addBreadcrumb,
+  captureException,
+  captureEvent,
+  captureMessage,
+  getHubFromCarrier,
+  getCurrentHub,
+  Hub,
+  Scope,
+  setContext,
+  setExtra,
+  setExtras,
+  setTag,
+  setTags,
+  setUser,
+  startTransaction,
+  startInactiveSpan,
+  startSpan,
+  startSpanManual,
+  getActiveSpan,
+} from '@sentry/core';
+
+import { _addTracingExtensions } from './tracing/addTracingExtensions';
+_addTracingExtensions();
+
+export {
+  Integrations as BrowserIntegrations,
+  ErrorBoundary,
+  withErrorBoundary,
+  createReduxEnhancer,
+  Profiler,
+  useProfiler,
+  withProfiler,
+} from '@sentry/react';
+
+export { lastEventId } from '@sentry/browser';
+
+import * as Integrations from './integrations';
+import { SDK_NAME, SDK_VERSION } from './version';
+export type { ReactNativeOptions } from './options';
+export { ReactNativeClient } from './client';
+
+export {
+  init,
+  wrap,
+  // eslint-disable-next-line deprecation/deprecation
+  setDist,
+  // eslint-disable-next-line deprecation/deprecation
+  setRelease,
+  nativeCrash,
+  flush,
+  close,
+  captureUserFeedback,
+  withScope,
+  configureScope,
+} from './sdk';
+export { TouchEventBoundary, withTouchEventBoundary } from './touchevents';
+
+export {
+  ReactNativeTracing,
+  ReactNavigationV4Instrumentation,
+  // eslint-disable-next-line deprecation/deprecation
+  ReactNavigationV5Instrumentation,
+  ReactNavigationInstrumentation,
+  ReactNativeNavigationInstrumentation,
+  RoutingInstrumentation,
+  sentryTraceGesture,
+} from './tracing';
+export type { ReactNavigationTransactionContext } from './tracing';
+export { Integrations, SDK_NAME, SDK_VERSION };
diff --git a/node_modules/@sentry/react-native/src/js/integrations/debugsymbolicator.ts b/node_modules/@sentry/react-native/src/js/integrations/debugsymbolicator.ts
new file mode 100644
index 0000000..e449c60
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/debugsymbolicator.ts
@@ -0,0 +1,247 @@
+import type { Event, EventHint, EventProcessor, Hub, Integration, StackFrame as SentryStackFrame } from '@sentry/types';
+import { addContextToFrame, logger } from '@sentry/utils';
+
+import { getFramesToPop, isErrorLike } from '../utils/error';
+import { ReactNativeLibraries } from '../utils/rnlibraries';
+import type * as ReactNative from '../vendor/react-native';
+
+const INTERNAL_CALLSITES_REGEX = new RegExp(['ReactNativeRenderer-dev\\.js$', 'MessageQueue\\.js$'].join('|'));
+
+/**
+ * React Native Error
+ */
+export type ReactNativeError = Error & {
+  framesToPop?: number;
+  jsEngine?: string;
+  preventSymbolication?: boolean;
+  componentStack?: string;
+};
+
+/** Tries to symbolicate the JS stack trace on the device. */
+export class DebugSymbolicator implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'DebugSymbolicator';
+  /**
+   * @inheritDoc
+   */
+  public name: string = DebugSymbolicator.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {
+    addGlobalEventProcessor(async (event: Event, hint: EventHint) => {
+      const self = getCurrentHub().getIntegration(DebugSymbolicator);
+
+      if (!self) {
+        return event;
+      }
+
+      if (event.exception && isErrorLike(hint.originalException)) {
+        // originalException is ErrorLike object
+        const symbolicatedFrames = await this._symbolicate(
+          hint.originalException.stack,
+          getFramesToPop(hint.originalException as Error),
+        );
+        symbolicatedFrames && this._replaceExceptionFramesInEvent(event, symbolicatedFrames);
+      } else if (hint.syntheticException && isErrorLike(hint.syntheticException)) {
+        // syntheticException is Error object
+        const symbolicatedFrames = await this._symbolicate(
+          hint.syntheticException.stack,
+          getFramesToPop(hint.syntheticException),
+        );
+
+        if (event.exception) {
+          symbolicatedFrames && this._replaceExceptionFramesInEvent(event, symbolicatedFrames);
+        } else if (event.threads) {
+          // RN JS doesn't have threads
+          // syntheticException is used for Sentry.captureMessage() threads
+          symbolicatedFrames && this._replaceThreadFramesInEvent(event, symbolicatedFrames);
+        }
+      }
+
+      return event;
+    });
+  }
+
+  /**
+   * Symbolicates the stack on the device talking to local dev server.
+   * Mutates the passed event.
+   */
+  private async _symbolicate(rawStack: string, skipFirstFrames: number = 0): Promise<SentryStackFrame[] | null> {
+    try {
+      const parsedStack = this._parseErrorStack(rawStack);
+
+      const prettyStack = await this._symbolicateStackTrace(parsedStack);
+      if (!prettyStack) {
+        logger.error('React Native DevServer could not symbolicate the stack trace.');
+        return null;
+      }
+
+      // This has been changed in an react-native version so stack is contained in here
+      const newStack = prettyStack.stack || prettyStack;
+
+      // https://github.com/getsentry/sentry-javascript/blob/739d904342aaf9327312f409952f14ceff4ae1ab/packages/utils/src/stacktrace.ts#L23
+      // Match SentryParser which counts lines of stack (-1 for first line with the Error message)
+      const skipFirstAdjustedToSentryStackParser = Math.max(skipFirstFrames - 1, 0);
+      const stackWithoutPoppedFrames = skipFirstAdjustedToSentryStackParser
+        ? newStack.slice(skipFirstAdjustedToSentryStackParser)
+        : newStack;
+
+      const stackWithoutInternalCallsites = stackWithoutPoppedFrames.filter(
+        (frame: { file?: string }) => frame.file && frame.file.match(INTERNAL_CALLSITES_REGEX) === null,
+      );
+
+      return await this._convertReactNativeFramesToSentryFrames(stackWithoutInternalCallsites);
+    } catch (error) {
+      if (error instanceof Error) {
+        logger.warn(`Unable to symbolicate stack trace: ${error.message}`);
+      }
+      return null;
+    }
+  }
+
+  /**
+   * Converts ReactNativeFrames to frames in the Sentry format
+   * @param frames ReactNativeFrame[]
+   */
+  private async _convertReactNativeFramesToSentryFrames(frames: ReactNative.StackFrame[]): Promise<SentryStackFrame[]> {
+    return Promise.all(
+      frames.map(async (frame: ReactNative.StackFrame): Promise<SentryStackFrame> => {
+        let inApp = !!frame.column && !!frame.lineNumber;
+        inApp =
+          inApp &&
+          frame.file !== undefined &&
+          !frame.file.includes('node_modules') &&
+          !frame.file.includes('native code');
+
+        const newFrame: SentryStackFrame = {
+          lineno: frame.lineNumber,
+          colno: frame.column,
+          filename: frame.file,
+          function: frame.methodName,
+          in_app: inApp,
+        };
+
+        if (inApp) {
+          await this._addSourceContext(newFrame);
+        }
+
+        return newFrame;
+      }),
+    );
+  }
+
+  /**
+   * Replaces the frames in the exception of a error.
+   * @param event Event
+   * @param frames StackFrame[]
+   */
+  private _replaceExceptionFramesInEvent(event: Event, frames: SentryStackFrame[]): void {
+    if (
+      event.exception &&
+      event.exception.values &&
+      event.exception.values[0] &&
+      event.exception.values[0].stacktrace
+    ) {
+      event.exception.values[0].stacktrace.frames = frames.reverse();
+    }
+  }
+
+  /**
+   * Replaces the frames in the thread of a message.
+   * @param event Event
+   * @param frames StackFrame[]
+   */
+  private _replaceThreadFramesInEvent(event: Event, frames: SentryStackFrame[]): void {
+    if (event.threads && event.threads.values && event.threads.values[0] && event.threads.values[0].stacktrace) {
+      event.threads.values[0].stacktrace.frames = frames.reverse();
+    }
+  }
+
+  /**
+   * This tries to add source context for in_app Frames
+   *
+   * @param frame StackFrame
+   * @param getDevServer function from RN to get DevServer URL
+   */
+  private async _addSourceContext(frame: SentryStackFrame): Promise<void> {
+    let sourceContext: string | null = null;
+
+    const segments = frame.filename?.split('/') ?? [];
+
+    const serverUrl = this._getDevServer()?.url;
+    if (!serverUrl) {
+      return;
+    }
+
+    for (const idx in segments) {
+      if (!Object.prototype.hasOwnProperty.call(segments, idx)) {
+        continue;
+      }
+
+      sourceContext = await this._fetchSourceContext(serverUrl, segments, -idx);
+      if (sourceContext) {
+        break;
+      }
+    }
+
+    if (!sourceContext) {
+      return;
+    }
+
+    const lines = sourceContext.split('\n');
+    addContextToFrame(lines, frame);
+  }
+
+  /**
+   * Get source context for segment
+   */
+  private async _fetchSourceContext(url: string, segments: Array<string>, start: number): Promise<string | null> {
+    const response = await fetch(`${url}${segments.slice(start).join('/')}`, {
+      method: 'GET',
+    });
+
+    if (response.ok) {
+      return response.text();
+    }
+    return null;
+  }
+
+  /**
+   * Loads and calls RN Core Devtools parseErrorStack function.
+   */
+  private _parseErrorStack(errorStack: string): Array<ReactNative.StackFrame> {
+    if (!ReactNativeLibraries.Devtools) {
+      throw new Error('React Native Devtools not available.');
+    }
+    return ReactNativeLibraries.Devtools.parseErrorStack(errorStack);
+  }
+
+  /**
+   * Loads and calls RN Core Devtools symbolicateStackTrace function.
+   */
+  private _symbolicateStackTrace(
+    stack: Array<ReactNative.StackFrame>,
+    extraData?: Record<string, unknown>,
+  ): Promise<ReactNative.SymbolicatedStackTrace> {
+    if (!ReactNativeLibraries.Devtools) {
+      throw new Error('React Native Devtools not available.');
+    }
+    return ReactNativeLibraries.Devtools.symbolicateStackTrace(stack, extraData);
+  }
+
+  /**
+   * Loads and returns the RN DevServer URL.
+   */
+  private _getDevServer(): ReactNative.DevServerInfo | undefined {
+    try {
+      return ReactNativeLibraries.Devtools?.getDevServer();
+    } catch (_oO) {
+      // We can't load devserver URL
+    }
+    return undefined;
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/devicecontext.ts b/node_modules/@sentry/react-native/src/js/integrations/devicecontext.ts
new file mode 100644
index 0000000..df2834a
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/devicecontext.ts
@@ -0,0 +1,100 @@
+/* eslint-disable complexity */
+import type { Event, EventProcessor, Hub, Integration } from '@sentry/types';
+import { logger, severityLevelFromString } from '@sentry/utils';
+import { AppState } from 'react-native';
+
+import { breadcrumbFromObject } from '../breadcrumb';
+import type { NativeDeviceContextsResponse } from '../NativeRNSentry';
+import { NATIVE } from '../wrapper';
+
+/** Load device context from native. */
+export class DeviceContext implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'DeviceContext';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = DeviceContext.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {
+    addGlobalEventProcessor(async (event: Event) => {
+      const self = getCurrentHub().getIntegration(DeviceContext);
+      if (!self) {
+        return event;
+      }
+
+      let native: NativeDeviceContextsResponse | null = null;
+      try {
+        native = await NATIVE.fetchNativeDeviceContexts();
+      } catch (e) {
+        logger.log(`Failed to get device context from native: ${e}`);
+      }
+
+      if (!native) {
+        return event;
+      }
+
+      const nativeUser = native.user;
+      if (!event.user && nativeUser) {
+        event.user = nativeUser;
+      }
+
+      let nativeContexts = native.contexts;
+      if (AppState.currentState !== 'unknown') {
+        nativeContexts = nativeContexts || {};
+        nativeContexts.app = {
+          ...nativeContexts.app,
+          in_foreground: AppState.currentState === 'active',
+        };
+      }
+      if (nativeContexts) {
+        event.contexts = { ...nativeContexts, ...event.contexts };
+        if (nativeContexts.app) {
+          event.contexts.app = { ...nativeContexts.app, ...event.contexts.app };
+        }
+      }
+
+      const nativeTags = native.tags;
+      if (nativeTags) {
+        event.tags = { ...nativeTags, ...event.tags };
+      }
+
+      const nativeExtra = native.extra;
+      if (nativeExtra) {
+        event.extra = { ...nativeExtra, ...event.extra };
+      }
+
+      const nativeFingerprint = native.fingerprint;
+      if (nativeFingerprint) {
+        event.fingerprint = (event.fingerprint ?? []).concat(
+          nativeFingerprint.filter(item => (event.fingerprint ?? []).indexOf(item) < 0),
+        );
+      }
+
+      const nativeLevel = typeof native['level'] === 'string' ? severityLevelFromString(native['level']) : undefined;
+      if (!event.level && nativeLevel) {
+        event.level = nativeLevel;
+      }
+
+      const nativeEnvironment = native['environment'];
+      if (!event.environment && nativeEnvironment) {
+        event.environment = nativeEnvironment;
+      }
+
+      const nativeBreadcrumbs = Array.isArray(native['breadcrumbs'])
+        ? native['breadcrumbs'].map(breadcrumbFromObject)
+        : undefined;
+      if (nativeBreadcrumbs) {
+        event.breadcrumbs = nativeBreadcrumbs;
+      }
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/eventorigin.ts b/node_modules/@sentry/react-native/src/js/integrations/eventorigin.ts
new file mode 100644
index 0000000..3b61e56
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/eventorigin.ts
@@ -0,0 +1,28 @@
+import type { EventProcessor, Integration } from '@sentry/types';
+
+/** Default EventOrigin instrumentation */
+export class EventOrigin implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'EventOrigin';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = EventOrigin.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (e: EventProcessor) => void): void {
+    addGlobalEventProcessor(event => {
+      event.tags = event.tags ?? {};
+
+      event.tags['event.origin'] = 'javascript';
+      event.tags['event.environment'] = 'javascript';
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/factory.ts b/node_modules/@sentry/react-native/src/js/integrations/factory.ts
new file mode 100644
index 0000000..6dbea2e
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/factory.ts
@@ -0,0 +1,17 @@
+import type { Integration } from '@sentry/types';
+
+/**
+ * Creates an integration out of the provided name and setup function.
+ * @hidden
+ */
+export function createIntegration(
+  name: Integration['name'],
+  setupOnce: Integration['setupOnce'] = () => {
+    /* noop */
+  },
+): Integration {
+  return {
+    name: name,
+    setupOnce,
+  };
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/index.ts b/node_modules/@sentry/react-native/src/js/integrations/index.ts
new file mode 100644
index 0000000..061bc5e
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/index.ts
@@ -0,0 +1,9 @@
+export { DebugSymbolicator } from './debugsymbolicator';
+export { DeviceContext } from './devicecontext';
+export { ReactNativeErrorHandlers } from './reactnativeerrorhandlers';
+export { Release } from './release';
+export { EventOrigin } from './eventorigin';
+export { SdkInfo } from './sdkinfo';
+export { ReactNativeInfo } from './reactnativeinfo';
+export { ModulesLoader } from './modulesloader';
+export { HermesProfiling } from '../profiling/integration';
diff --git a/node_modules/@sentry/react-native/src/js/integrations/modulesloader.ts b/node_modules/@sentry/react-native/src/js/integrations/modulesloader.ts
new file mode 100644
index 0000000..b3f4da0
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/modulesloader.ts
@@ -0,0 +1,43 @@
+import type { Event, EventProcessor, Integration } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { NATIVE } from '../wrapper';
+
+/** Loads runtime JS modules from prepared file. */
+export class ModulesLoader implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'ModulesLoader';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = ModulesLoader.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (e: EventProcessor) => void): void {
+    let isSetup = false;
+    let modules: Record<string, string> | null;
+
+    addGlobalEventProcessor(async (event: Event) => {
+      if (!isSetup) {
+        try {
+          modules = await NATIVE.fetchModules();
+        } catch (e) {
+          logger.log(`Failed to get modules from native: ${e}`);
+        }
+        isSetup = true;
+      }
+      if (modules) {
+        event.modules = {
+          ...modules,
+          ...event.modules,
+        };
+      }
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/nativelinkederrors.ts b/node_modules/@sentry/react-native/src/js/integrations/nativelinkederrors.ts
new file mode 100644
index 0000000..6c0d8d3
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/nativelinkederrors.ts
@@ -0,0 +1,231 @@
+import { exceptionFromError } from '@sentry/browser';
+import type {
+  DebugImage,
+  Event,
+  EventHint,
+  EventProcessor,
+  Exception,
+  ExtendedError,
+  Hub,
+  Integration,
+  StackFrame,
+  StackParser,
+} from '@sentry/types';
+import { isInstanceOf, isPlainObject } from '@sentry/utils';
+
+import type { NativeStackFrames } from '../NativeRNSentry';
+import { NATIVE } from '../wrapper';
+
+const DEFAULT_KEY = 'cause';
+const DEFAULT_LIMIT = 5;
+
+interface LinkedErrorsOptions {
+  key: string;
+  limit: number;
+}
+
+/**
+ * Processes JS and RN native linked errors.
+ */
+export class NativeLinkedErrors implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'NativeLinkedErrors';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = NativeLinkedErrors.id;
+
+  private readonly _key: LinkedErrorsOptions['key'];
+  private readonly _limit: LinkedErrorsOptions['limit'];
+  private _nativePackage: string | null = null;
+
+  /**
+   * @inheritDoc
+   */
+  public constructor(options: Partial<LinkedErrorsOptions> = {}) {
+    this._key = options.key || DEFAULT_KEY;
+    this._limit = options.limit || DEFAULT_LIMIT;
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {
+    const client = getCurrentHub().getClient();
+    if (!client) {
+      return;
+    }
+
+    addGlobalEventProcessor(async (event: Event, hint?: EventHint) => {
+      if (this._nativePackage === null) {
+        this._nativePackage = await this._fetchNativePackage();
+      }
+      const self = getCurrentHub().getIntegration(NativeLinkedErrors);
+      return self ? this._handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;
+    });
+  }
+
+  /**
+   * Enriches passed event with linked exceptions and native debug meta images.
+   */
+  private async _handler(
+    parser: StackParser,
+    key: string,
+    limit: number,
+    event: Event,
+    hint?: EventHint,
+  ): Promise<Event | null> {
+    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
+      return event;
+    }
+    const { exceptions: linkedErrors, debugImages } = await this._walkErrorTree(
+      parser,
+      limit,
+      hint.originalException as ExtendedError,
+      key,
+    );
+    event.exception.values = [...event.exception.values, ...linkedErrors];
+
+    event.debug_meta = event.debug_meta || {};
+    event.debug_meta.images = event.debug_meta.images || [];
+    event.debug_meta.images.push(...(debugImages || []));
+
+    return event;
+  }
+
+  /**
+   * Walks linked errors and created Sentry exceptions chain.
+   * Collects debug images from native errors stack frames.
+   */
+  private async _walkErrorTree(
+    parser: StackParser,
+    limit: number,
+    error: ExtendedError,
+    key: string,
+    exceptions: Exception[] = [],
+    debugImages: DebugImage[] = [],
+  ): Promise<{
+    exceptions: Exception[];
+    debugImages?: DebugImage[];
+  }> {
+    const linkedError = error[key];
+    if (!linkedError || exceptions.length + 1 >= limit) {
+      return {
+        exceptions,
+        debugImages,
+      };
+    }
+
+    let exception: Exception;
+    let exceptionDebugImages: DebugImage[] | undefined;
+    if ('stackElements' in linkedError) {
+      // isJavaException
+      exception = this._exceptionFromJavaStackElements(linkedError);
+    } else if ('stackReturnAddresses' in linkedError) {
+      // isObjCException
+      const { appleException, appleDebugImages } = await this._exceptionFromAppleStackReturnAddresses(linkedError);
+      exception = appleException;
+      exceptionDebugImages = appleDebugImages;
+    } else if (isInstanceOf(linkedError, Error)) {
+      exception = exceptionFromError(parser, error[key]);
+    } else if (isPlainObject(linkedError)) {
+      exception = {
+        type: typeof linkedError.name === 'string' ? linkedError.name : undefined,
+        value: typeof linkedError.message === 'string' ? linkedError.message : undefined,
+      };
+    } else {
+      return {
+        exceptions,
+        debugImages,
+      };
+    }
+
+    return this._walkErrorTree(
+      parser,
+      limit,
+      linkedError,
+      key,
+      [...exceptions, exception],
+      [...debugImages, ...(exceptionDebugImages || [])],
+    );
+  }
+
+  /**
+   * Converts a Java Throwable to an SentryException
+   */
+  private _exceptionFromJavaStackElements(javaThrowable: {
+    name: string;
+    message: string;
+    stackElements: {
+      className: string;
+      fileName: string;
+      methodName: string;
+      lineNumber: number;
+    }[];
+  }): Exception {
+    return {
+      type: javaThrowable.name,
+      value: javaThrowable.message,
+      stacktrace: {
+        frames: javaThrowable.stackElements
+          .map(
+            stackElement =>
+              <StackFrame>{
+                platform: 'java',
+                module: stackElement.className,
+                filename: stackElement.fileName,
+                lineno: stackElement.lineNumber >= 0 ? stackElement.lineNumber : undefined,
+                function: stackElement.methodName,
+                in_app:
+                  this._nativePackage !== null && stackElement.className.startsWith(this._nativePackage)
+                    ? true
+                    : undefined,
+              },
+          )
+          .reverse(),
+      },
+    };
+  }
+
+  /**
+   * Converts StackAddresses to a SentryException with DebugMetaImages
+   */
+  private async _exceptionFromAppleStackReturnAddresses(objCException: {
+    name: string;
+    message: string;
+    stackReturnAddresses: number[];
+  }): Promise<{
+    appleException: Exception;
+    appleDebugImages: DebugImage[];
+  }> {
+    const nativeStackFrames = await this._fetchNativeStackFrames(objCException.stackReturnAddresses);
+
+    return {
+      appleException: {
+        type: objCException.name,
+        value: objCException.message,
+        stacktrace: {
+          frames: (nativeStackFrames && nativeStackFrames.frames.reverse()) || [],
+        },
+      },
+      appleDebugImages: (nativeStackFrames && (nativeStackFrames.debugMetaImages as DebugImage[])) || [],
+    };
+  }
+
+  /**
+   * Fetches the native package/image name from the native layer
+   */
+  private _fetchNativePackage(): Promise<string | null> {
+    return NATIVE.fetchNativePackageName();
+  }
+
+  /**
+   * Fetches native debug image information on iOS
+   */
+  private _fetchNativeStackFrames(instructionsAddr: number[]): Promise<NativeStackFrames | null> {
+    return NATIVE.fetchNativeStackFramesBy(instructionsAddr);
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/reactnativeerrorhandlers.ts b/node_modules/@sentry/react-native/src/js/integrations/reactnativeerrorhandlers.ts
new file mode 100644
index 0000000..e9ef217
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/reactnativeerrorhandlers.ts
@@ -0,0 +1,266 @@
+import { getCurrentHub } from '@sentry/core';
+import type { EventHint, Integration, SeverityLevel } from '@sentry/types';
+import { addExceptionMechanism, logger } from '@sentry/utils';
+
+import type { ReactNativeClient } from '../client';
+import { createSyntheticError, isErrorLike } from '../utils/error';
+import { ReactNativeLibraries } from '../utils/rnlibraries';
+import { RN_GLOBAL_OBJ } from '../utils/worldwide';
+
+/** ReactNativeErrorHandlers Options */
+interface ReactNativeErrorHandlersOptions {
+  onerror: boolean;
+  onunhandledrejection: boolean;
+  patchGlobalPromise: boolean;
+}
+
+interface PromiseRejectionTrackingOptions {
+  onUnhandled: (id: string, error: unknown) => void;
+  onHandled: (id: string) => void;
+}
+
+/** ReactNativeErrorHandlers Integration */
+export class ReactNativeErrorHandlers implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'ReactNativeErrorHandlers';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = ReactNativeErrorHandlers.id;
+
+  /** ReactNativeOptions */
+  private readonly _options: ReactNativeErrorHandlersOptions;
+
+  /** Constructor */
+  public constructor(options?: Partial<ReactNativeErrorHandlersOptions>) {
+    this._options = {
+      onerror: true,
+      onunhandledrejection: true,
+      patchGlobalPromise: true,
+      ...options,
+    };
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(): void {
+    this._handleUnhandledRejections();
+    this._handleOnError();
+  }
+
+  /**
+   * Handle Promises
+   */
+  private _handleUnhandledRejections(): void {
+    if (this._options.onunhandledrejection) {
+      if (this._options.patchGlobalPromise) {
+        this._polyfillPromise();
+      }
+
+      this._attachUnhandledRejectionHandler();
+      this._checkPromiseAndWarn();
+    }
+  }
+  /**
+   * Polyfill the global promise instance with one we can be sure that we can attach the tracking to.
+   *
+   * In newer RN versions >=0.63, the global promise is not the same reference as the one imported from the promise library.
+   * This is due to a version mismatch between promise versions.
+   * Originally we tried a solution where we would have you put a package resolution to ensure the promise instances match. However,
+   * - Using a package resolution requires the you to manually troubleshoot.
+   * - The package resolution fix no longer works with 0.67 on iOS Hermes.
+   */
+  private _polyfillPromise(): void {
+    if (!ReactNativeLibraries.Utilities) {
+      logger.warn('Could not polyfill Promise. React Native Libraries Utilities not found.');
+      return;
+    }
+
+    const Promise = this._getPromisePolyfill();
+
+    // As of RN 0.67 only done and finally are used
+    // eslint-disable-next-line import/no-extraneous-dependencies
+    require('promise/setimmediate/done');
+    // eslint-disable-next-line import/no-extraneous-dependencies
+    require('promise/setimmediate/finally');
+
+    ReactNativeLibraries.Utilities.polyfillGlobal('Promise', () => Promise);
+  }
+
+  /**
+   * Single source of truth for the Promise implementation we want to use.
+   * This is important for verifying that the rejected promise tracing will work as expected.
+   */
+  private _getPromisePolyfill(): unknown {
+    /* eslint-disable import/no-extraneous-dependencies,@typescript-eslint/no-var-requires */
+    // Below, we follow the exact way React Native initializes its promise library, and we globally replace it.
+    return require('promise/setimmediate/es6-extensions');
+  }
+
+  /**
+   * Attach the unhandled rejection handler
+   */
+  private _attachUnhandledRejectionHandler(): void {
+    const tracking = this._loadRejectionTracking();
+
+    const promiseRejectionTrackingOptions: PromiseRejectionTrackingOptions = {
+      onUnhandled: (id, rejection = {}) => {
+        // eslint-disable-next-line no-console
+        console.warn(`Possible Unhandled Promise Rejection (id: ${id}):\n${rejection}`);
+      },
+      onHandled: id => {
+        // eslint-disable-next-line no-console
+        console.warn(
+          `Promise Rejection Handled (id: ${id})\n` +
+            'This means you can ignore any previous messages of the form ' +
+            `"Possible Unhandled Promise Rejection (id: ${id}):"`,
+        );
+      },
+    };
+
+    tracking.enable({
+      allRejections: true,
+      onUnhandled: (id: string, error: unknown) => {
+        if (__DEV__) {
+          promiseRejectionTrackingOptions.onUnhandled(id, error);
+        }
+
+        getCurrentHub().captureException(error, {
+          data: { id },
+          originalException: error,
+          syntheticException: isErrorLike(error) ? undefined : createSyntheticError(),
+        });
+      },
+      onHandled: (id: string) => {
+        promiseRejectionTrackingOptions.onHandled(id);
+      },
+    });
+  }
+  /**
+   * Checks if the promise is the same one or not, if not it will warn the user
+   */
+  private _checkPromiseAndWarn(): void {
+    try {
+      // `promise` package is a dependency of react-native, therefore it is always available.
+      // but it is possible that the user has installed a different version of promise
+      // or dependency that uses a different version.
+      // We have to check if the React Native Promise and the `promise` package Promise are using the same reference.
+      // If they are not, likely there are multiple versions of the `promise` package installed.
+      const ReactNativePromise = ReactNativeLibraries.Promise;
+      // eslint-disable-next-line @typescript-eslint/no-var-requires,import/no-extraneous-dependencies
+      const PromisePackagePromise = require('promise/setimmediate/es6-extensions');
+      const UsedPromisePolyfill = this._getPromisePolyfill();
+
+      if (ReactNativePromise !== PromisePackagePromise) {
+        logger.warn(
+          'You appear to have multiple versions of the "promise" package installed. ' +
+            'This may cause unexpected behavior like undefined `Promise.allSettled`. ' +
+            'Please install the `promise` package manually using the exact version as the React Native package. ' +
+            'See https://docs.sentry.io/platforms/react-native/troubleshooting/ for more details.',
+        );
+      }
+
+      // This only make sense if the user disabled the integration Polyfill
+      if (UsedPromisePolyfill !== RN_GLOBAL_OBJ.Promise) {
+        logger.warn(
+          'Unhandled promise rejections will not be caught by Sentry. ' +
+            'See https://docs.sentry.io/platforms/react-native/troubleshooting/ for more details.',
+        );
+      } else {
+        logger.log('Unhandled promise rejections will be caught by Sentry.');
+      }
+    } catch (e) {
+      // Do Nothing
+      logger.warn(
+        'Unhandled promise rejections will not be caught by Sentry. ' +
+          'See https://docs.sentry.io/platforms/react-native/troubleshooting/ for more details.',
+      );
+    }
+  }
+  /**
+   * Handle errors
+   */
+  private _handleOnError(): void {
+    if (this._options.onerror) {
+      let handlingFatal = false;
+
+      const errorUtils = RN_GLOBAL_OBJ.ErrorUtils;
+      if (!errorUtils) {
+        logger.warn('ErrorUtils not found. Can be caused by different environment for example react-native-web.');
+        return;
+      }
+
+      const defaultHandler = errorUtils.getGlobalHandler && errorUtils.getGlobalHandler();
+
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+      errorUtils.setGlobalHandler(async (error: any, isFatal?: boolean) => {
+        // We want to handle fatals, but only in production mode.
+        const shouldHandleFatal = isFatal && !__DEV__;
+        if (shouldHandleFatal) {
+          if (handlingFatal) {
+            logger.log('Encountered multiple fatals in a row. The latest:', error);
+            return;
+          }
+          handlingFatal = true;
+        }
+
+        const currentHub = getCurrentHub();
+        const client = currentHub.getClient<ReactNativeClient>();
+        const scope = currentHub.getScope();
+
+        if (!client) {
+          logger.error('Sentry client is missing, the error event might be lost.', error);
+
+          // If there is no client something is fishy, anyway we call the default handler
+          defaultHandler(error, isFatal);
+
+          return;
+        }
+
+        const options = client.getOptions();
+
+        const hint: EventHint = {
+          originalException: error,
+          attachments: scope?.getAttachments(),
+        };
+        const event = await client.eventFromException(error, hint);
+
+        if (isFatal) {
+          event.level = 'fatal' as SeverityLevel;
+
+          addExceptionMechanism(event, {
+            handled: false,
+            type: 'onerror',
+          });
+        }
+
+        currentHub.captureEvent(event, hint);
+
+        if (!__DEV__) {
+          void client.flush(options.shutdownTimeout || 2000).then(() => {
+            defaultHandler(error, isFatal);
+          });
+        } else {
+          // If in dev, we call the default handler anyway and hope the error will be sent
+          // Just for a better dev experience
+          defaultHandler(error, isFatal);
+        }
+      });
+    }
+  }
+
+  /**
+   * Loads and returns rejection tracking module
+   */
+  private _loadRejectionTracking(): {
+    disable: () => void;
+    enable: (arg: unknown) => void;
+  } {
+    // eslint-disable-next-line @typescript-eslint/no-var-requires,import/no-extraneous-dependencies
+    return require('promise/setimmediate/rejection-tracking');
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/reactnativeinfo.ts b/node_modules/@sentry/react-native/src/js/integrations/reactnativeinfo.ts
new file mode 100644
index 0000000..f123b77
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/reactnativeinfo.ts
@@ -0,0 +1,109 @@
+import type { Context, Event, EventHint, EventProcessor, Integration } from '@sentry/types';
+
+import {
+  getHermesVersion,
+  getReactNativeVersion,
+  isExpo,
+  isFabricEnabled,
+  isHermesEnabled,
+  isTurboModuleEnabled,
+} from '../utils/environment';
+import type { ReactNativeError } from './debugsymbolicator';
+
+export interface ReactNativeContext extends Context {
+  js_engine?: string;
+  turbo_module: boolean;
+  fabric: boolean;
+  expo: boolean;
+  hermes_version?: string;
+  react_native_version?: string;
+  component_stack?: string;
+  hermes_debug_info?: boolean;
+}
+
+/** Loads React Native context at runtime */
+export class ReactNativeInfo implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'ReactNativeInfo';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = ReactNativeInfo.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void {
+    addGlobalEventProcessor(async (event: Event, hint?: EventHint) => {
+      const reactNativeError = hint?.originalException ? (hint?.originalException as ReactNativeError) : undefined;
+
+      const reactNativeContext: ReactNativeContext = {
+        turbo_module: isTurboModuleEnabled(),
+        fabric: isFabricEnabled(),
+        react_native_version: getReactNativeVersion(),
+        expo: isExpo(),
+      };
+
+      if (isHermesEnabled()) {
+        reactNativeContext.js_engine = 'hermes';
+        const hermesVersion = getHermesVersion();
+        if (hermesVersion) {
+          reactNativeContext.hermes_version = hermesVersion;
+        }
+        reactNativeContext.hermes_debug_info = !isEventWithHermesBytecodeFrames(event);
+      } else if (reactNativeError?.jsEngine) {
+        reactNativeContext.js_engine = reactNativeError.jsEngine;
+      }
+
+      if (reactNativeContext.js_engine === 'hermes') {
+        event.tags = {
+          hermes: 'true',
+          ...event.tags,
+        };
+      }
+
+      if (reactNativeError?.componentStack) {
+        reactNativeContext.component_stack = reactNativeError.componentStack;
+      }
+
+      event.contexts = {
+        react_native_context: reactNativeContext,
+        ...event.contexts,
+      };
+
+      return event;
+    });
+  }
+}
+
+/**
+ * Guess if the event contains frames with Hermes bytecode
+ * (thus Hermes bundle doesn't contain debug info)
+ * based on the event exception/threads frames.
+ *
+ * This function can be relied on only if Hermes is enabled!
+ *
+ * Hermes bytecode position is always line 1 and column 0-based number.
+ * If Hermes bundle has debug info, the bytecode frames pos are calculated
+ * back to the plain bundle source code positions and line will be > 1.
+ *
+ * Line 1 contains start time var, it's safe to assume it won't crash.
+ * The above only applies when Hermes is enabled.
+ *
+ * Javascript/Hermes bytecode frames have platform === undefined.
+ * Native (Java, ObjC, C++) frames have platform === 'android'/'ios'/'native'.
+ */
+function isEventWithHermesBytecodeFrames(event: Event): boolean {
+  for (const value of event.exception?.values || event.threads?.values || []) {
+    for (const frame of value.stacktrace?.frames || []) {
+      // platform === undefined we assume it's javascript (only native frames use the platform attribute)
+      if (frame.platform === undefined && frame.lineno === 1) {
+        return true;
+      }
+    }
+  }
+  return false;
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/release.ts b/node_modules/@sentry/react-native/src/js/integrations/release.ts
new file mode 100644
index 0000000..0ca52c1
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/release.ts
@@ -0,0 +1,66 @@
+import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';
+import type { Event, Integration } from '@sentry/types';
+
+import { NATIVE } from '../wrapper';
+
+/** Release integration responsible to load release from file. */
+export class Release implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'Release';
+  /**
+   * @inheritDoc
+   */
+  public name: string = Release.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(): void {
+    addGlobalEventProcessor(async (event: Event) => {
+      const self = getCurrentHub().getIntegration(Release);
+      if (!self) {
+        return event;
+      }
+
+      const options = getCurrentHub().getClient()?.getOptions();
+
+      /*
+        __sentry_release and __sentry_dist is set by the user with setRelease and setDist. If this is used then this is the strongest.
+        Otherwise we check for the release and dist in the options passed on init, as this is stronger than the release/dist from the native build.
+      */
+      if (typeof event.extra?.__sentry_release === 'string') {
+        event.release = `${event.extra.__sentry_release}`;
+      } else if (typeof options?.release === 'string') {
+        event.release = options.release;
+      }
+
+      if (typeof event.extra?.__sentry_dist === 'string') {
+        event.dist = `${event.extra.__sentry_dist}`;
+      } else if (typeof options?.dist === 'string') {
+        event.dist = options.dist;
+      }
+
+      if (event.release && event.dist) {
+        return event;
+      }
+
+      try {
+        const nativeRelease = await NATIVE.fetchNativeRelease();
+        if (nativeRelease) {
+          if (!event.release) {
+            event.release = `${nativeRelease.id}@${nativeRelease.version}+${nativeRelease.build}`;
+          }
+          if (!event.dist) {
+            event.dist = `${nativeRelease.build}`;
+          }
+        }
+      } catch (_Oo) {
+        // Something went wrong, we just continue
+      }
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/rewriteframes.ts b/node_modules/@sentry/react-native/src/js/integrations/rewriteframes.ts
new file mode 100644
index 0000000..77157e2
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/rewriteframes.ts
@@ -0,0 +1,66 @@
+import { RewriteFrames } from '@sentry/integrations';
+import type { StackFrame } from '@sentry/types';
+import { Platform } from 'react-native';
+
+import { isExpo, isHermesEnabled } from '../utils/environment';
+
+export const ANDROID_DEFAULT_BUNDLE_NAME = 'app:///index.android.bundle';
+export const IOS_DEFAULT_BUNDLE_NAME = 'app:///main.jsbundle';
+
+/**
+ * Creates React Native default rewrite frames integration
+ * which appends app:// to the beginning of the filename
+ * and removes file://, 'address at' prefixes, CodePush postfix,
+ * and Expo bundle postfix.
+ */
+export function createReactNativeRewriteFrames(): RewriteFrames {
+  return new RewriteFrames({
+    iteratee: (frame: StackFrame) => {
+      if (frame.platform === 'java' || frame.platform === 'cocoa') {
+        // Because platform is not required in StackFrame type
+        // we assume that if not set it's javascript
+        return frame;
+      }
+
+      if (!frame.filename) {
+        return frame;
+      }
+      delete frame.abs_path;
+
+      frame.filename = frame.filename
+        .replace(/^file:\/\//, '')
+        .replace(/^address at /, '')
+        .replace(/^.*\/[^.]+(\.app|CodePush|.*(?=\/))/, '');
+
+      if (frame.filename === '[native code]' || frame.filename === 'native') {
+        return frame;
+      }
+      // Is React Native frame
+
+      // Check Hermes Bytecode Frame and convert to 1-based column
+      if (isHermesEnabled() && frame.lineno === 1 && frame.colno !== undefined) {
+        // hermes bytecode columns are 0-based, while v8 and jsc are 1-based
+        // Hermes frames without debug info have always line = 1 and col points to a bytecode pos
+        // https://github.com/facebook/react/issues/21792#issuecomment-873171991
+        frame.colno += 1;
+      }
+
+      // Expo adds hash to the end of bundle names
+      if (isExpo() && Platform.OS === 'android') {
+        frame.filename = ANDROID_DEFAULT_BUNDLE_NAME;
+        return frame;
+      }
+
+      if (isExpo() && Platform.OS === 'ios') {
+        frame.filename = IOS_DEFAULT_BUNDLE_NAME;
+        return frame;
+      }
+
+      const appPrefix = 'app://';
+      // We always want to have a triple slash
+      frame.filename =
+        frame.filename.indexOf('/') === 0 ? `${appPrefix}${frame.filename}` : `${appPrefix}/${frame.filename}`;
+      return frame;
+    },
+  });
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/screenshot.ts b/node_modules/@sentry/react-native/src/js/integrations/screenshot.ts
new file mode 100644
index 0000000..699916e
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/screenshot.ts
@@ -0,0 +1,58 @@
+import type { Event, EventHint, EventProcessor, Integration } from '@sentry/types';
+import { resolvedSyncPromise } from '@sentry/utils';
+
+import type { Screenshot as ScreenshotAttachment } from '../wrapper';
+import { NATIVE } from '../wrapper';
+
+/** Adds screenshots to error events */
+export class Screenshot implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'Screenshot';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = Screenshot.id;
+
+  /**
+   * If enabled attaches a screenshot to the event hint.
+   *
+   * @deprecated Screenshots are now added in global event processor.
+   */
+  public static attachScreenshotToEventHint(
+    hint: EventHint,
+    { attachScreenshot }: { attachScreenshot?: boolean },
+  ): PromiseLike<EventHint> {
+    if (!attachScreenshot) {
+      return resolvedSyncPromise(hint);
+    }
+
+    return NATIVE.captureScreenshot().then(screenshots => {
+      if (screenshots !== null && screenshots.length > 0) {
+        hint.attachments = [...screenshots, ...(hint?.attachments || [])];
+      }
+      return hint;
+    });
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (e: EventProcessor) => void): void {
+    addGlobalEventProcessor(async (event: Event, hint: EventHint) => {
+      const hasException = event.exception && event.exception.values && event.exception.values.length > 0;
+      if (!hasException) {
+        return event;
+      }
+
+      const screenshots: ScreenshotAttachment[] | null = await NATIVE.captureScreenshot();
+      if (screenshots && screenshots.length > 0) {
+        hint.attachments = [...screenshots, ...(hint?.attachments || [])];
+      }
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/sdkinfo.ts b/node_modules/@sentry/react-native/src/js/integrations/sdkinfo.ts
new file mode 100644
index 0000000..c2fc143
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/sdkinfo.ts
@@ -0,0 +1,65 @@
+import type { EventProcessor, Integration, Package, SdkInfo as SdkInfoType } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { SDK_NAME, SDK_PACKAGE_NAME, SDK_VERSION } from '../version';
+import { NATIVE } from '../wrapper';
+
+type DefaultSdkInfo = Pick<Required<SdkInfoType>, 'name' | 'packages' | 'version'>;
+
+export const defaultSdkInfo: DefaultSdkInfo = {
+  name: SDK_NAME,
+  packages: [
+    {
+      name: SDK_PACKAGE_NAME,
+      version: SDK_VERSION,
+    },
+  ],
+  version: SDK_VERSION,
+};
+
+/** Default SdkInfo instrumentation */
+export class SdkInfo implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'SdkInfo';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = SdkInfo.id;
+
+  private _nativeSdkPackage: Package | null = null;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (e: EventProcessor) => void): void {
+    addGlobalEventProcessor(async event => {
+      // this._nativeSdkInfo should be defined a following time so this call won't always be awaited.
+      if (this._nativeSdkPackage === null) {
+        try {
+          this._nativeSdkPackage = await NATIVE.fetchNativeSdkInfo();
+        } catch (e) {
+          // If this fails, go ahead as usual as we would rather have the event be sent with a package missing.
+          logger.warn(
+            '[SdkInfo] Native SDK Info retrieval failed...something could be wrong with your Sentry installation:',
+          );
+          logger.warn(e);
+        }
+      }
+
+      event.platform = event.platform || 'javascript';
+      event.sdk = event.sdk || {};
+      event.sdk.name = event.sdk.name || defaultSdkInfo.name;
+      event.sdk.version = event.sdk.version || defaultSdkInfo.version;
+      event.sdk.packages = [
+        // default packages are added by baseclient and should not be added here
+        ...(event.sdk.packages || []),
+        ...((this._nativeSdkPackage && [this._nativeSdkPackage]) || []),
+      ];
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/integrations/viewhierarchy.ts b/node_modules/@sentry/react-native/src/js/integrations/viewhierarchy.ts
new file mode 100644
index 0000000..15b29b0
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/integrations/viewhierarchy.ts
@@ -0,0 +1,54 @@
+import type { Event, EventHint, EventProcessor, Integration } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { NATIVE } from '../wrapper';
+
+/** Adds ViewHierarchy to error events */
+export class ViewHierarchy implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'ViewHierarchy';
+
+  private static _fileName: string = 'view-hierarchy.json';
+  private static _contentType: string = 'application/json';
+  private static _attachmentType: string = 'event.view_hierarchy';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = ViewHierarchy.id;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(addGlobalEventProcessor: (e: EventProcessor) => void): void {
+    addGlobalEventProcessor(async (event: Event, hint: EventHint) => {
+      const hasException = event.exception && event.exception.values && event.exception.values.length > 0;
+      if (!hasException) {
+        return event;
+      }
+
+      let viewHierarchy: Uint8Array | null = null;
+      try {
+        viewHierarchy = await NATIVE.fetchViewHierarchy();
+      } catch (e) {
+        logger.error('Failed to get view hierarchy from native.', e);
+      }
+
+      if (viewHierarchy) {
+        hint.attachments = [
+          {
+            filename: ViewHierarchy._fileName,
+            contentType: ViewHierarchy._contentType,
+            attachmentType: ViewHierarchy._attachmentType,
+            data: viewHierarchy,
+          },
+          ...(hint?.attachments || []),
+        ];
+      }
+
+      return event;
+    });
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/measurements.ts b/node_modules/@sentry/react-native/src/js/measurements.ts
new file mode 100644
index 0000000..d716a11
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/measurements.ts
@@ -0,0 +1,6 @@
+export const APP_START_WARM = 'app_start_warm';
+export const APP_START_COLD = 'app_start_cold';
+
+export const STALL_COUNT = 'stall_count';
+export const STALL_TOTAL_TIME = 'stall_total_time';
+export const STALL_LONGEST_TIME = 'stall_longest_time';
diff --git a/node_modules/@sentry/react-native/src/js/misc.ts b/node_modules/@sentry/react-native/src/js/misc.ts
new file mode 100644
index 0000000..a5a83d0
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/misc.ts
@@ -0,0 +1,18 @@
+import type { EnvelopeItem, Exception } from '@sentry/types';
+
+type EnvelopeItemPayload = EnvelopeItem[1];
+
+/**
+ * Extracts the hard crash information from the event exceptions.
+ * No exceptions or undefined handled are not hard crashes.
+ */
+export function isHardCrash(payload: EnvelopeItemPayload): boolean {
+  const values: Exception[] =
+    typeof payload !== 'string' && 'exception' in payload && payload.exception?.values ? payload.exception.values : [];
+  for (const exception of values) {
+    if (!(exception.mechanism?.handled !== false)) {
+      return true;
+    }
+  }
+  return false;
+}
diff --git a/node_modules/@sentry/react-native/src/js/options.ts b/node_modules/@sentry/react-native/src/js/options.ts
new file mode 100644
index 0000000..dacd461
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/options.ts
@@ -0,0 +1,184 @@
+import type { BrowserTransportOptions } from '@sentry/browser/types/transports/types';
+import type { ProfilerProps } from '@sentry/react/types/profiler';
+import type { CaptureContext, ClientOptions, Options } from '@sentry/types';
+
+import type { TouchEventBoundaryProps } from './touchevents';
+
+export interface BaseReactNativeOptions {
+  /**
+   * Enables native transport + device info + offline caching.
+   * Be careful, disabling this also breaks automatic release setting.
+   * This means you have to manage setting the release yourself.
+   * Defaults to `true`.
+   */
+  enableNative?: boolean;
+
+  /**
+   * Enables native crashHandling. This only works if `enableNative` is `true`.
+   * Defaults to `true`.
+   */
+  enableNativeCrashHandling?: boolean;
+
+  /**
+   * Initializes the native SDK on init.
+   * Set this to `false` if you have an existing native SDK and don't want to re-initialize.
+   *
+   * NOTE: Be careful and only use this if you know what you are doing.
+   * If you use this flag, make sure a native SDK is running before the JS Engine initializes or events might not be captured.
+   * Also, make sure the DSN on both the React Native side and the native side are the same one.
+   * We strongly recommend checking the documentation if you need to use this.
+   *
+   * @default true
+   */
+  autoInitializeNativeSdk?: boolean;
+
+  /** Should the native nagger alert be shown or not. */
+  enableNativeNagger?: boolean;
+
+  /** Should sessions be tracked to Sentry Health or not. */
+  enableAutoSessionTracking?: boolean;
+
+  /** The interval to end a session if the App goes to the background. */
+  sessionTrackingIntervalMillis?: number;
+
+  /** Enable NDK on Android
+   *
+   * @default true
+   */
+  enableNdk?: boolean;
+
+  /** Enable scope sync from Java to NDK on Android
+   * Only has an effect if `enableNdk` is `true`.
+   */
+  enableNdkScopeSync?: boolean;
+
+  /** When enabled, all the threads are automatically attached to all logged events on Android */
+  attachThreads?: boolean;
+
+  /**
+   *  When enabled, certain personally identifiable information (PII) is added by active integrations.
+   *
+   * @default false
+   */
+  sendDefaultPii?: boolean;
+
+  /**
+   * Callback that is called after the RN SDK on the JS Layer has made contact with the Native Layer.
+   */
+  onReady?: (response: {
+    /** `true` if the native SDK has been initialized, `false` otherwise.  */
+    didCallNativeInit: boolean;
+  }) => void;
+
+  /** Enable auto performance tracking by default. Renamed from `enableAutoPerformanceTracking` in v5. */
+  enableAutoPerformanceTracing?: boolean;
+
+  /**
+   * Enables Out of Memory Tracking for iOS and macCatalyst.
+   * See the following link for more information and possible restrictions:
+   * https://docs.sentry.io/platforms/apple/guides/ios/configuration/out-of-memory/
+   *
+   * Renamed from `enableOutOfMemoryTracking` in v5.
+   *
+   * @default true
+   */
+  enableWatchdogTerminationTracking?: boolean;
+
+  /**
+   * Set data to the inital scope
+   * @deprecated Use `Sentry.configureScope(...)`
+   */
+  initialScope?: CaptureContext;
+
+  /**
+   * When enabled, Sentry will overwrite the global Promise instance to ensure that unhandled rejections are correctly tracked.
+   * If you run into issues with Promise polyfills such as `core-js`, make sure you polyfill after Sentry is initialized.
+   * Read more at https://docs.sentry.io/platforms/react-native/troubleshooting/#unhandled-promise-rejections
+   *
+   * When disabled, this option will not disable unhandled rejection tracking. Set `onunhandledrejection: false` on the `ReactNativeErrorHandlers` integration instead.
+   *
+   * @default true
+   */
+  patchGlobalPromise?: boolean;
+
+  /**
+   * The max cache items for capping the number of envelopes.
+   *
+   * @default 30
+   */
+  maxCacheItems?: number;
+
+  /**
+   * When enabled, the SDK tracks when the application stops responding for a specific amount of
+   * time defined by the `appHangTimeoutInterval` option.
+   *
+   * iOS only
+   *
+   * @default true
+   */
+  enableAppHangTracking?: boolean;
+
+  /**
+   * The minimum amount of time an app should be unresponsive to be classified as an App Hanging.
+   * The actual amount may be a little longer.
+   * Avoid using values lower than 100ms, which may cause a lot of app hangs events being transmitted.
+   * Value should be in seconds.
+   *
+   * iOS only
+   *
+   * @default 2
+   */
+  appHangTimeoutInterval?: number;
+
+  /**
+   * The max queue size for capping the number of envelopes waiting to be sent by Transport.
+   */
+  maxQueueSize?: number;
+
+  /**
+   * When enabled and a user experiences an error, Sentry provides the ability to take a screenshot and include it as an attachment.
+   *
+   * @default false
+   */
+  attachScreenshot?: boolean;
+
+  /**
+   * When enabled Sentry includes the current view hierarchy in the error attachments.
+   *
+   * @default false
+   */
+  attachViewHierarchy?: boolean;
+
+  /**
+   * When enabled, Sentry will capture failed XHR/Fetch requests. This option also enabled HTTP Errors on iOS.
+   * [Sentry Android Gradle Plugin](https://docs.sentry.io/platforms/android/configuration/integrations/okhttp/)
+   * is needed to capture HTTP Errors on Android.
+   *
+   * @default false
+   */
+  enableCaptureFailedRequests?: boolean;
+}
+
+export interface ReactNativeTransportOptions extends BrowserTransportOptions {
+  /**
+   * @deprecated use `maxQueueSize` in the root of the SDK options.
+   */
+  bufferSize?: number;
+}
+
+/**
+ * Configuration options for the Sentry ReactNative SDK.
+ * @see ReactNativeFrontend for more information.
+ */
+
+export interface ReactNativeOptions extends Options<ReactNativeTransportOptions>, BaseReactNativeOptions {}
+
+export interface ReactNativeClientOptions extends ClientOptions<ReactNativeTransportOptions>, BaseReactNativeOptions {}
+
+export interface ReactNativeWrapperOptions {
+  /** Props for the root React profiler */
+  profilerProps?: ProfilerProps;
+
+  /** Props for the root touch event boundary */
+  touchEventBoundaryProps?: TouchEventBoundaryProps;
+}
diff --git a/node_modules/@sentry/react-native/src/js/profiling/cache.ts b/node_modules/@sentry/react-native/src/js/profiling/cache.ts
new file mode 100644
index 0000000..f5f340c
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/cache.ts
@@ -0,0 +1,5 @@
+import { makeFifoCache } from '@sentry/utils';
+
+import type { CombinedProfileEvent } from './types';
+
+export const PROFILE_QUEUE = makeFifoCache<string, CombinedProfileEvent>(20);
diff --git a/node_modules/@sentry/react-native/src/js/profiling/constants.ts b/node_modules/@sentry/react-native/src/js/profiling/constants.ts
new file mode 100644
index 0000000..759a835
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/constants.ts
@@ -0,0 +1 @@
+export const MAX_PROFILE_DURATION_MS = 30 * 1e3;
diff --git a/node_modules/@sentry/react-native/src/js/profiling/convertHermesProfile.ts b/node_modules/@sentry/react-native/src/js/profiling/convertHermesProfile.ts
new file mode 100644
index 0000000..e91f6c1
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/convertHermesProfile.ts
@@ -0,0 +1,211 @@
+import type { FrameId, StackId, ThreadCpuFrame, ThreadCpuSample, ThreadCpuStack, ThreadId } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { MAX_PROFILE_DURATION_MS } from './constants';
+import type * as Hermes from './hermes';
+import { DEFAULT_BUNDLE_NAME } from './hermes';
+import type { RawThreadCpuProfile } from './types';
+
+const PLACEHOLDER_THREAD_ID_STRING = '0';
+const MS_TO_NS = 1e6;
+const MAX_PROFILE_DURATION_NS = MAX_PROFILE_DURATION_MS * MS_TO_NS;
+const UNKNOWN_STACK_ID = -1;
+const JS_THREAD_NAME = 'JavaScriptThread';
+const JS_THREAD_PRIORITY = 1;
+
+/**
+ * Converts a Hermes profile to a Sentry profile.
+ *
+ * Maps Hermes samples to Sentry samples.
+ * Maps Hermes stack frames to Sentry frames.
+ * Hermes stack frame is an object representing a function call in the stack
+ * with a link to its parent stack frame. Root of the represented stack tree
+ * is main function call in Hermes that is [root] stack frame.
+ *
+ * @returns Sentry profile or null if no samples are found.
+ */
+export function convertToSentryProfile(hermesProfile: Hermes.Profile): RawThreadCpuProfile | null {
+  if (hermesProfile.samples.length === 0) {
+    logger.warn('[Profiling] No samples found in profile.');
+    return null;
+  }
+
+  const { samples, hermesStacks, jsThreads } = mapSamples(hermesProfile.samples);
+
+  const { frames, hermesStackFrameIdToSentryFrameIdMap } = mapFrames(hermesProfile.stackFrames);
+
+  const { stacks, hermesStackToSentryStackMap } = mapStacks(
+    hermesStacks,
+    hermesProfile.stackFrames,
+    hermesStackFrameIdToSentryFrameIdMap,
+  );
+
+  for (const sample of samples) {
+    const sentryStackId = hermesStackToSentryStackMap.get(sample.stack_id);
+    if (sentryStackId === undefined) {
+      logger.error(`[Profiling] Hermes Stack ID ${sample.stack_id} not found when mapping to Sentry Stack ID.`);
+      sample.stack_id = UNKNOWN_STACK_ID;
+    } else {
+      sample.stack_id = sentryStackId;
+    }
+  }
+
+  const thread_metadata: Record<ThreadId, { name?: string; priority?: number }> = {};
+  for (const jsThreadId of jsThreads) {
+    thread_metadata[jsThreadId] = {
+      name: JS_THREAD_NAME,
+      priority: JS_THREAD_PRIORITY,
+    };
+  }
+  const active_thread_id = Object.keys(thread_metadata)[0] || PLACEHOLDER_THREAD_ID_STRING;
+
+  return {
+    samples,
+    frames,
+    stacks,
+    thread_metadata,
+    active_thread_id,
+  };
+}
+
+/**
+ * Maps Hermes samples to Sentry samples.
+ * Calculates the elapsed time since the first sample based on the absolute timestamps of the Hermes samples.
+ * Hermes stack frame IDs represent the last (leaf, furthest from the main func) frame of the call stack.
+ * @returns the mapped Sentry samples, the set of Hermes stack frame IDs, and the set of JS thread IDs
+ */
+export function mapSamples(
+  hermesSamples: Hermes.Sample[],
+  maxElapsedSinceStartNs: number = MAX_PROFILE_DURATION_NS,
+): {
+  samples: ThreadCpuSample[];
+  hermesStacks: Set<Hermes.StackFrameId>;
+  jsThreads: Set<ThreadId>;
+} {
+  const jsThreads = new Set<ThreadId>();
+  const hermesStacks = new Set<Hermes.StackFrameId>();
+
+  const start = Number(hermesSamples[0].ts);
+  const samples: ThreadCpuSample[] = [];
+  for (const hermesSample of hermesSamples) {
+    jsThreads.add(hermesSample.tid);
+    hermesStacks.add(hermesSample.sf);
+
+    const elapsed_since_start_ns = (Number(hermesSample.ts) - start) * 1e3;
+    if (elapsed_since_start_ns >= maxElapsedSinceStartNs) {
+      logger.warn(
+        `[Profiling] Sample has elapsed time since start ${elapsed_since_start_ns}ns ` +
+          `greater than the max elapsed time ${maxElapsedSinceStartNs}ns.`,
+      );
+      break;
+    }
+
+    samples.push({
+      stack_id: hermesSample.sf,
+      thread_id: hermesSample.tid,
+      elapsed_since_start_ns: elapsed_since_start_ns.toFixed(0),
+    });
+  }
+
+  return {
+    samples,
+    hermesStacks,
+    jsThreads,
+  };
+}
+
+/**
+ * Maps Hermes StackFrames tree represented as an JS object to a Sentry frames array.
+ * Converts line and columns strings to numbers.
+ * @returns the mapped Sentry frames
+ */
+function mapFrames(hermesStackFrames: Record<Hermes.StackFrameId, Hermes.StackFrame>): {
+  frames: ThreadCpuFrame[];
+  hermesStackFrameIdToSentryFrameIdMap: Map<Hermes.StackFrameId, FrameId>;
+} {
+  const frames: ThreadCpuFrame[] = [];
+  const hermesStackFrameIdToSentryFrameIdMap = new Map<Hermes.StackFrameId, FrameId>();
+  for (const key in hermesStackFrames) {
+    // asc order based on the key is not guaranteed
+    if (!Object.prototype.hasOwnProperty.call(hermesStackFrames, key)) {
+      continue;
+    }
+    hermesStackFrameIdToSentryFrameIdMap.set(Number(key), frames.length);
+    frames.push(parseHermesJSStackFrame(hermesStackFrames[key]));
+  }
+
+  return {
+    frames,
+    hermesStackFrameIdToSentryFrameIdMap,
+  };
+}
+
+/**
+ * Maps Hermes stack frame IDs to Sentry stack arrays.
+ * Hermes stack frame IDs represent the last (leaf, furthest from the main func) frame of the call stack.
+ * @returns the mapped Sentry stacks and a map from Hermes stack IDs to Sentry stack IDs (indices in the stacks array)
+ */
+function mapStacks(
+  hermesStacks: Set<Hermes.StackFrameId>,
+  hermesStackFrames: Record<Hermes.StackFrameId, Hermes.StackFrame>,
+  hermesStackFrameIdToSentryFrameIdMap: Map<Hermes.StackFrameId, FrameId>,
+): {
+  stacks: ThreadCpuStack[];
+  hermesStackToSentryStackMap: Map<Hermes.StackFrameId, StackId>;
+} {
+  const hermesStackToSentryStackMap = new Map<Hermes.StackFrameId, StackId>();
+  const stacks: ThreadCpuStack[] = [];
+  for (const hermesStackFunctionFrameId of hermesStacks) {
+    const stackId = stacks.length;
+    hermesStackToSentryStackMap.set(hermesStackFunctionFrameId, stackId);
+    const stack: ThreadCpuStack = [];
+    let currentHermesFrameId: Hermes.StackFrameId | undefined = hermesStackFunctionFrameId;
+    while (currentHermesFrameId !== undefined) {
+      const sentryFrameId = hermesStackFrameIdToSentryFrameIdMap.get(currentHermesFrameId);
+      sentryFrameId !== undefined && stack.push(sentryFrameId);
+      currentHermesFrameId = hermesStackFrames[currentHermesFrameId] && hermesStackFrames[currentHermesFrameId].parent;
+    }
+    stacks.push(stack);
+  }
+
+  return {
+    stacks,
+    hermesStackToSentryStackMap,
+  };
+}
+
+/**
+ * Parses Hermes StackFrame to Sentry StackFrame.
+ * For native frames only function name is returned, for Hermes bytecode the line and column are calculated.
+ */
+export function parseHermesJSStackFrame(frame: Hermes.StackFrame): ThreadCpuFrame {
+  if (frame.category !== 'JavaScript') {
+    // Native
+    if (frame.name === '[root]') {
+      return { function: frame.name, in_app: false };
+    }
+    return { function: frame.name };
+  }
+
+  if (frame.funcVirtAddr !== undefined && frame.offset !== undefined) {
+    // Hermes Bytecode
+    return {
+      function: frame.name,
+      abs_path: DEFAULT_BUNDLE_NAME,
+      // https://github.com/krystofwoldrich/metro/blob/417e6f276ff9422af6039fc4d1bce41fcf7d9f46/packages/metro-symbolicate/src/Symbolication.js#L298-L301
+      // Hermes lineno is hardcoded 1, currently only one bundle symbolication is supported by metro-symbolicate and thus by us.
+      lineno: 1,
+      // Hermes colno is 0-based, while Sentry is 1-based
+      colno: Number(frame.funcVirtAddr) + Number(frame.offset) + 1,
+    };
+  }
+
+  // JavaScript
+  const indexOfLeftParenthesis = frame.name.indexOf('(');
+  return {
+    function: indexOfLeftParenthesis !== -1 ? frame.name.substring(0, indexOfLeftParenthesis) || undefined : frame.name,
+    abs_path: DEFAULT_BUNDLE_NAME,
+    lineno: frame.line !== undefined ? Number(frame.line) : undefined,
+    colno: frame.column !== undefined ? Number(frame.column) : undefined,
+  };
+}
diff --git a/node_modules/@sentry/react-native/src/js/profiling/debugid.ts b/node_modules/@sentry/react-native/src/js/profiling/debugid.ts
new file mode 100644
index 0000000..a4369f7
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/debugid.ts
@@ -0,0 +1,37 @@
+import type { DebugImage } from '@sentry/types';
+import { GLOBAL_OBJ, logger } from '@sentry/utils';
+
+import { DEFAULT_BUNDLE_NAME } from './hermes';
+
+/**
+ * Returns debug meta images of the loaded bundle.
+ */
+export function getDebugMetadata(): DebugImage[] {
+  if (!DEFAULT_BUNDLE_NAME) {
+    return [];
+  }
+
+  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
+  if (!debugIdMap) {
+    return [];
+  }
+
+  const debugIdsKeys = Object.keys(debugIdMap);
+  if (!debugIdsKeys.length) {
+    return [];
+  }
+
+  if (debugIdsKeys.length > 1) {
+    logger.warn(
+      '[Profiling] Multiple debug images found, but only one one bundle is supported. Using the first one...',
+    );
+  }
+
+  return [
+    {
+      code_file: DEFAULT_BUNDLE_NAME,
+      debug_id: debugIdMap[debugIdsKeys[0]],
+      type: 'sourcemap',
+    },
+  ];
+}
diff --git a/node_modules/@sentry/react-native/src/js/profiling/hermes.ts b/node_modules/@sentry/react-native/src/js/profiling/hermes.ts
new file mode 100644
index 0000000..d2ed0fe
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/hermes.ts
@@ -0,0 +1,54 @@
+import { Platform } from 'react-native';
+
+import { ANDROID_DEFAULT_BUNDLE_NAME, IOS_DEFAULT_BUNDLE_NAME } from '../integrations/rewriteframes';
+
+export type StackFrameId = number;
+export type MicrosecondsSinceBoot = string;
+
+export interface TraceEvent {
+  name: string;
+  ph: string;
+  cat: string;
+  pid: number;
+  ts: MicrosecondsSinceBoot;
+  tid: string;
+  args: {
+    name?: string;
+  };
+}
+
+export interface Sample {
+  cpu: string;
+  name: string;
+  ts: MicrosecondsSinceBoot;
+  pid: number;
+  tid: string;
+  weight: string;
+  sf: StackFrameId;
+}
+
+export interface StackFrame {
+  // Hermes Bytecode
+  funcVirtAddr?: string;
+  offset?: string;
+
+  // JavaScript
+  line?: string;
+  column?: string;
+  funcLine?: string;
+  funcColumn?: string;
+
+  // Common
+  name: string;
+  category: string;
+  parent?: number;
+}
+
+export interface Profile {
+  traceEvents: TraceEvent[];
+  samples: Sample[];
+  stackFrames: Record<string, StackFrame>;
+}
+
+export const DEFAULT_BUNDLE_NAME =
+  Platform.OS === 'android' ? ANDROID_DEFAULT_BUNDLE_NAME : Platform.OS === 'ios' ? IOS_DEFAULT_BUNDLE_NAME : undefined;
diff --git a/node_modules/@sentry/react-native/src/js/profiling/integration.ts b/node_modules/@sentry/react-native/src/js/profiling/integration.ts
new file mode 100644
index 0000000..1923a5a
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/integration.ts
@@ -0,0 +1,319 @@
+/* eslint-disable complexity */
+import type { Hub } from '@sentry/core';
+import { getActiveTransaction } from '@sentry/core';
+import type {
+  Envelope,
+  Event,
+  EventProcessor,
+  Integration,
+  Profile,
+  ThreadCpuProfile,
+  Transaction,
+} from '@sentry/types';
+import { logger, uuid4 } from '@sentry/utils';
+import { Platform } from 'react-native';
+
+import { isHermesEnabled } from '../utils/environment';
+import { NATIVE } from '../wrapper';
+import { PROFILE_QUEUE } from './cache';
+import { MAX_PROFILE_DURATION_MS } from './constants';
+import { convertToSentryProfile } from './convertHermesProfile';
+import type { NativeProfileEvent } from './nativeTypes';
+import type { CombinedProfileEvent, HermesProfileEvent } from './types';
+import {
+  addProfilesToEnvelope,
+  createHermesProfilingEvent,
+  enrichCombinedProfileWithEventContext,
+  findProfiledTransactionsFromEnvelope,
+} from './utils';
+
+const MS_TO_NS: number = 1e6;
+
+/**
+ * Profiling integration creates a profile for each transaction and adds it to the event envelope.
+ *
+ * @experimental
+ */
+export class HermesProfiling implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'HermesProfiling';
+
+  /**
+   * @inheritDoc
+   */
+  public name: string = HermesProfiling.id;
+
+  private _getCurrentHub?: () => Hub;
+
+  private _currentProfile:
+    | {
+        profile_id: string;
+        startTimestampNs: number;
+      }
+    | undefined;
+
+  private _currentProfileTimeout: number | undefined;
+
+  /**
+   * @inheritDoc
+   */
+  public setupOnce(_: (e: EventProcessor) => void, getCurrentHub: () => Hub): void {
+    if (!isHermesEnabled()) {
+      logger.log('[Profiling] Hermes is not enabled, not adding profiling integration.');
+      return;
+    }
+
+    this._getCurrentHub = getCurrentHub;
+    const client = getCurrentHub().getClient();
+
+    if (!client || typeof client.on !== 'function') {
+      return;
+    }
+
+    this._startCurrentProfileForActiveTransaction();
+    client.on('startTransaction', this._startCurrentProfile);
+
+    client.on('finishTransaction', this._finishCurrentProfile);
+
+    client.on('beforeEnvelope', (envelope: Envelope) => {
+      if (!PROFILE_QUEUE.size()) {
+        return;
+      }
+
+      const profiledTransactions = findProfiledTransactionsFromEnvelope(envelope);
+      if (!profiledTransactions.length) {
+        logger.log('[Profiling] no profiled transactions found in envelope');
+        return;
+      }
+
+      const profilesToAddToEnvelope: Profile[] = [];
+      for (const profiledTransaction of profiledTransactions) {
+        const profile = this._createProfileEventFor(profiledTransaction);
+        if (profile) {
+          profilesToAddToEnvelope.push(profile);
+        }
+      }
+      addProfilesToEnvelope(envelope, profilesToAddToEnvelope);
+    });
+  }
+
+  private _startCurrentProfileForActiveTransaction = (): void => {
+    if (this._currentProfile) {
+      return;
+    }
+    const transaction = this._getCurrentHub && getActiveTransaction(this._getCurrentHub());
+    transaction && this._startCurrentProfile(transaction);
+  };
+
+  private _startCurrentProfile = (transaction: Transaction): void => {
+    this._finishCurrentProfile();
+
+    const shouldStartProfiling = this._shouldStartProfiling(transaction);
+    if (!shouldStartProfiling) {
+      return;
+    }
+
+    this._currentProfileTimeout = setTimeout(this._finishCurrentProfile, MAX_PROFILE_DURATION_MS);
+    this._startNewProfile(transaction);
+  };
+
+  private _shouldStartProfiling = (transaction: Transaction): boolean => {
+    if (!transaction.sampled) {
+      logger.log('[Profiling] Transaction is not sampled, skipping profiling');
+      return false;
+    }
+
+    const client = this._getCurrentHub && this._getCurrentHub().getClient();
+    const options = client && client.getOptions();
+
+    const profilesSampleRate =
+      options && options._experiments && typeof options._experiments.profilesSampleRate === 'number'
+        ? options._experiments.profilesSampleRate
+        : undefined;
+    if (profilesSampleRate === undefined) {
+      logger.log('[Profiling] Profiling disabled, enable it by setting `profilesSampleRate` option to SDK init call.');
+      return false;
+    }
+
+    // Check if we should sample this profile
+    if (Math.random() > profilesSampleRate) {
+      logger.log('[Profiling] Skip profiling transaction due to sampling.');
+      return false;
+    }
+
+    return true;
+  };
+
+  /**
+   * Starts a new profile and links it to the transaction.
+   */
+  private _startNewProfile = (transaction: Transaction): void => {
+    const profileStartTimestampNs = startProfiling();
+    if (!profileStartTimestampNs) {
+      return;
+    }
+
+    this._currentProfile = {
+      profile_id: uuid4(),
+      startTimestampNs: profileStartTimestampNs,
+    };
+    transaction.setContext('profile', { profile_id: this._currentProfile.profile_id });
+    // @ts-expect-error profile_id is not part of the metadata type
+    transaction.setMetadata({ profile_id: this._currentProfile.profile_id });
+    logger.log('[Profiling] started profiling: ', this._currentProfile.profile_id);
+  };
+
+  /**
+   * Stops profiling and adds the profile to the queue to be processed on beforeEnvelope.
+   */
+  private _finishCurrentProfile = (): void => {
+    this._clearCurrentProfileTimeout();
+    if (this._currentProfile === undefined) {
+      return;
+    }
+
+    const profile = stopProfiling();
+    if (!profile) {
+      logger.warn('[Profiling] Stop failed. Cleaning up...');
+      this._currentProfile = undefined;
+      return;
+    }
+
+    PROFILE_QUEUE.add(this._currentProfile.profile_id, profile);
+
+    logger.log('[Profiling] finished profiling: ', this._currentProfile.profile_id);
+    this._currentProfile = undefined;
+  };
+
+  private _createProfileEventFor = (profiledTransaction: Event): Profile | null => {
+    const profile_id = profiledTransaction?.contexts?.['profile']?.['profile_id'];
+
+    if (typeof profile_id !== 'string') {
+      logger.log('[Profiling] cannot find profile for a transaction without a profile context');
+      return null;
+    }
+
+    // Remove the profile from the transaction context before sending, relay will take care of the rest.
+    if (profiledTransaction?.contexts?.['.profile']) {
+      delete profiledTransaction.contexts.profile;
+    }
+
+    const profile = PROFILE_QUEUE.get(profile_id);
+    PROFILE_QUEUE.delete(profile_id);
+
+    if (!profile) {
+      logger.log(`[Profiling] cannot find profile ${profile_id} for transaction ${profiledTransaction.event_id}`);
+      return null;
+    }
+
+    const profileWithEvent = enrichCombinedProfileWithEventContext(profile_id, profile, profiledTransaction);
+    logger.log(`[Profiling] Created profile ${profile_id} for transaction ${profiledTransaction.event_id}`);
+
+    return profileWithEvent;
+  };
+
+  private _clearCurrentProfileTimeout = (): void => {
+    this._currentProfileTimeout !== undefined && clearTimeout(this._currentProfileTimeout);
+    this._currentProfileTimeout = undefined;
+  };
+}
+
+/**
+ * Starts Profilers and returns the timestamp when profiling started in nanoseconds.
+ */
+export function startProfiling(): number | null {
+  const started = NATIVE.startProfiling();
+  if (!started) {
+    return null;
+  }
+
+  return Date.now() * MS_TO_NS;
+}
+
+/**
+ * Stops Profilers and returns collected combined profile.
+ */
+export function stopProfiling(): CombinedProfileEvent | null {
+  const collectedProfiles = NATIVE.stopProfiling();
+  if (!collectedProfiles) {
+    return null;
+  }
+
+  const hermesProfile = convertToSentryProfile(collectedProfiles.hermesProfile);
+  if (!hermesProfile) {
+    return null;
+  }
+
+  const hermesProfileEvent = createHermesProfilingEvent(hermesProfile);
+  if (!hermesProfileEvent) {
+    return null;
+  }
+
+  if (!collectedProfiles.nativeProfile) {
+    return hermesProfileEvent;
+  }
+
+  return addNativeProfileToHermesProfile(hermesProfileEvent, collectedProfiles.nativeProfile);
+}
+
+/**
+ * Merges Hermes and Native profile events into one.
+ */
+export function addNativeProfileToHermesProfile(
+  hermes: HermesProfileEvent,
+  native: NativeProfileEvent,
+): CombinedProfileEvent {
+  return {
+    ...hermes,
+    profile: addNativeThreadCpuProfileToHermes(hermes.profile, native.profile, hermes.transaction.active_thread_id),
+    debug_meta: {
+      images: native.debug_meta.images,
+    },
+    measurements: native.measurements,
+  };
+}
+
+/**
+ * Merges Hermes And Native profiles into one.
+ */
+export function addNativeThreadCpuProfileToHermes(
+  hermes: ThreadCpuProfile,
+  native: ThreadCpuProfile,
+  hermes_active_thread_id: string | undefined,
+): CombinedProfileEvent['profile'] {
+  // assumes thread ids are unique
+  hermes.thread_metadata = { ...native.thread_metadata, ...hermes.thread_metadata };
+  // assumes queue ids are unique
+  hermes.queue_metadata = { ...native.queue_metadata, ...hermes.queue_metadata };
+
+  // recalculate frames and stacks using offset
+  const framesOffset = hermes.frames.length;
+  const stacksOffset = hermes.stacks.length;
+
+  if (native.frames) {
+    for (const frame of native.frames) {
+      hermes.frames.push({
+        function: frame.function,
+        instruction_addr: frame.instruction_addr,
+        platform: Platform.OS === 'ios' ? 'cocoa' : undefined,
+      });
+    }
+  }
+  hermes.stacks = [
+    ...(hermes.stacks || []),
+    ...(native.stacks || []).map(stack => stack.map(frameId => frameId + framesOffset)),
+  ];
+  hermes.samples = [
+    ...(hermes.samples || []),
+    ...(native.samples || [])
+      .filter(sample => sample.thread_id !== hermes_active_thread_id)
+      .map(sample => ({
+        ...sample,
+        stack_id: stacksOffset + sample.stack_id,
+      })),
+  ];
+
+  return hermes;
+}
diff --git a/node_modules/@sentry/react-native/src/js/profiling/nativeTypes.ts b/node_modules/@sentry/react-native/src/js/profiling/nativeTypes.ts
new file mode 100644
index 0000000..67b3908
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/nativeTypes.ts
@@ -0,0 +1,51 @@
+export interface NativeProfileEvent {
+  profile_id: string;
+  profile: {
+    samples: {
+      stack_id: number;
+      thread_id: string;
+      queue_address?: string;
+      elapsed_since_start_ns: string;
+    }[];
+    stacks: number[][];
+    frames: {
+      function?: string;
+      instruction_addr?: string;
+    }[];
+    thread_metadata: Record<
+      string,
+      {
+        name?: string;
+        priority?: number;
+      }
+    >;
+    queue_metadata?: Record<
+      string,
+      {
+        label: string;
+      }
+    >;
+  };
+  transaction: {
+    active_thread_id: string;
+  };
+  measurements: Record<
+    string,
+    {
+      values: {
+        elapsed_since_start_ns: number;
+        value: number;
+      }[];
+      unit: string;
+    }
+  >;
+  debug_meta: {
+    images: {
+      type: 'macho';
+      debug_id: string;
+      image_addr: string;
+      image_size: number;
+      code_file: string;
+    }[];
+  };
+}
diff --git a/node_modules/@sentry/react-native/src/js/profiling/types.ts b/node_modules/@sentry/react-native/src/js/profiling/types.ts
new file mode 100644
index 0000000..aaff106
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/types.ts
@@ -0,0 +1,22 @@
+import type { Profile, ThreadCpuFrame, ThreadCpuProfile } from '@sentry/types';
+
+import type { NativeProfileEvent } from './nativeTypes';
+
+export interface RawThreadCpuProfile extends ThreadCpuProfile {
+  frames: ThreadCpuFrame[];
+  profile_id?: string;
+  active_thread_id: string;
+}
+
+export type HermesProfileEvent = {
+  platform: 'javascript';
+  version: '1';
+  profile: ThreadCpuProfile;
+  transaction: {
+    active_thread_id: string;
+  };
+};
+
+export type ProfileEvent = Profile;
+
+export type CombinedProfileEvent = HermesProfileEvent & Partial<NativeProfileEvent>;
diff --git a/node_modules/@sentry/react-native/src/js/profiling/utils.ts b/node_modules/@sentry/react-native/src/js/profiling/utils.ts
new file mode 100644
index 0000000..a48d619
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/profiling/utils.ts
@@ -0,0 +1,140 @@
+/* eslint-disable complexity */
+import type { Envelope, Event, Profile, ThreadCpuProfile } from '@sentry/types';
+import { forEachEnvelopeItem, logger } from '@sentry/utils';
+
+import { getDefaultEnvironment } from '../utils/environment';
+import { getDebugMetadata } from './debugid';
+import type { CombinedProfileEvent, HermesProfileEvent, RawThreadCpuProfile } from './types';
+
+/**
+ *
+ */
+export function isValidProfile(profile: ThreadCpuProfile): profile is RawThreadCpuProfile & { profile_id: string } {
+  if (profile.samples.length <= 1) {
+    if (__DEV__) {
+      // Log a warning if the profile has less than 2 samples so users can know why
+      // they are not seeing any profiling data and we cant avoid the back and forth
+      // of asking them to provide us with a dump of the profile data.
+      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');
+    }
+    return false;
+  }
+  return true;
+}
+
+/**
+ * Finds transactions with profile_id context in the envelope
+ * @param envelope
+ * @returns
+ */
+export function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {
+  const events: Event[] = [];
+
+  forEachEnvelopeItem(envelope, (item, type) => {
+    if (type !== 'transaction') {
+      return;
+    }
+
+    // First item is the type
+    for (let j = 1; j < item.length; j++) {
+      const event = item[j];
+
+      // @ts-expect-error accessing private property
+      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {
+        events.push(item[j] as Event);
+      }
+    }
+  });
+
+  return events;
+}
+
+/**
+ * Creates a profiling envelope item, if the profile does not pass validation, returns null.
+ * @param event
+ * @returns {Profile | null}
+ */
+export function enrichCombinedProfileWithEventContext(
+  profile_id: string,
+  profile: CombinedProfileEvent,
+  event: Event,
+): Profile | null {
+  if (!profile.profile || !isValidProfile(profile.profile)) {
+    return null;
+  }
+
+  const trace_id = (event.contexts && event.contexts.trace && event.contexts.trace.trace_id) || '';
+
+  // Log a warning if the profile has an invalid traceId (should be uuidv4).
+  // All profiles and transactions are rejected if this is the case and we want to
+  // warn users that this is happening if they enable debug flag
+  if (trace_id && trace_id.length !== 32) {
+    if (__DEV__) {
+      logger.log(`[Profiling] Invalid traceId: ${trace_id} on profiled event`);
+    }
+  }
+
+  return {
+    ...profile,
+    event_id: profile_id,
+    runtime: {
+      name: 'hermes',
+      version: '', // TODO: get hermes version
+    },
+    timestamp: event.start_timestamp ? new Date(event.start_timestamp * 1000).toISOString() : new Date().toISOString(),
+    release: event.release || '',
+    environment: event.environment || getDefaultEnvironment(),
+    os: {
+      name: (event.contexts && event.contexts.os && event.contexts.os.name) || '',
+      version: (event.contexts && event.contexts.os && event.contexts.os.version) || '',
+      build_number: (event.contexts && event.contexts.os && event.contexts.os.build) || '',
+    },
+    device: {
+      locale: (event.contexts && event.contexts.device && (event.contexts.device.locale as string)) || '',
+      model: (event.contexts && event.contexts.device && event.contexts.device.model) || '',
+      manufacturer: (event.contexts && event.contexts.device && event.contexts.device.manufacturer) || '',
+      architecture: (event.contexts && event.contexts.device && event.contexts.device.arch) || '',
+      is_emulator: (event.contexts && event.contexts.device && event.contexts.device.simulator) || false,
+    },
+    transaction: {
+      name: event.transaction || '',
+      id: event.event_id || '',
+      trace_id,
+      active_thread_id: (profile.transaction && profile.transaction.active_thread_id) || '',
+    },
+    debug_meta: {
+      images: [...getDebugMetadata(), ...((profile.debug_meta && profile.debug_meta.images) || [])],
+    },
+  };
+}
+
+/**
+ * Creates profiling event compatible carrier Object from raw Hermes profile.
+ */
+export function createHermesProfilingEvent(profile: RawThreadCpuProfile): HermesProfileEvent {
+  return {
+    platform: 'javascript',
+    version: '1',
+    profile,
+    transaction: {
+      active_thread_id: profile.active_thread_id,
+    },
+  };
+}
+
+/**
+ * Adds items to envelope if they are not already present - mutates the envelope.
+ * @param envelope
+ */
+export function addProfilesToEnvelope(envelope: Envelope, profiles: Profile[]): Envelope {
+  if (!profiles.length) {
+    return envelope;
+  }
+
+  for (const profile of profiles) {
+    // @ts-expect-error untyped envelope
+    envelope[1].push([{ type: 'profile' }, profile]);
+  }
+  return envelope;
+}
diff --git a/node_modules/@sentry/react-native/src/js/scope.ts b/node_modules/@sentry/react-native/src/js/scope.ts
new file mode 100644
index 0000000..bf8454b
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/scope.ts
@@ -0,0 +1,106 @@
+import { Scope } from '@sentry/core';
+import type { Attachment, Breadcrumb, User } from '@sentry/types';
+
+import { DEFAULT_BREADCRUMB_LEVEL } from './breadcrumb';
+import { convertToNormalizedObject } from './utils/normalize';
+import { NATIVE } from './wrapper';
+
+/**
+ * Extends the scope methods to set scope on the Native SDKs
+ */
+export class ReactNativeScope extends Scope {
+  /**
+   * @inheritDoc
+   */
+  public setUser(user: User | null): this {
+    NATIVE.setUser(user);
+    return super.setUser(user);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public setTag(key: string, value: string): this {
+    NATIVE.setTag(key, value);
+    return super.setTag(key, value);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public setTags(tags: { [key: string]: string }): this {
+    // As native only has setTag, we just loop through each tag key.
+    Object.keys(tags).forEach(key => {
+      NATIVE.setTag(key, tags[key]);
+    });
+    return super.setTags(tags);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  public setExtras(extras: { [key: string]: any }): this {
+    Object.keys(extras).forEach(key => {
+      NATIVE.setExtra(key, extras[key]);
+    });
+    return super.setExtras(extras);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types,@typescript-eslint/no-explicit-any
+  public setExtra(key: string, extra: any): this {
+    NATIVE.setExtra(key, extra);
+    return super.setExtra(key, extra);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this {
+    const mergedBreadcrumb: Breadcrumb = {
+      ...breadcrumb,
+      level: breadcrumb.level || DEFAULT_BREADCRUMB_LEVEL,
+      data: breadcrumb.data ? convertToNormalizedObject(breadcrumb.data) : undefined,
+    };
+
+    super.addBreadcrumb(mergedBreadcrumb, maxBreadcrumbs);
+
+    const finalBreadcrumb = this._breadcrumbs[this._breadcrumbs.length - 1];
+    NATIVE.addBreadcrumb(finalBreadcrumb);
+    return this;
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public clearBreadcrumbs(): this {
+    NATIVE.clearBreadcrumbs();
+    return super.clearBreadcrumbs();
+  }
+
+  /**
+   * @inheritDoc
+   */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  public setContext(key: string, context: { [key: string]: any } | null): this {
+    NATIVE.setContext(key, context);
+    return super.setContext(key, context);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public addAttachment(attachment: Attachment): this {
+    return super.addAttachment(attachment);
+  }
+
+  /**
+   * @inheritDoc
+   */
+  public clearAttachments(): this {
+    return super.clearAttachments();
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/sdk.tsx b/node_modules/@sentry/react-native/src/js/sdk.tsx
new file mode 100644
index 0000000..7382e10
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/sdk.tsx
@@ -0,0 +1,296 @@
+/* eslint-disable complexity */
+import type { Scope } from '@sentry/core';
+import { getIntegrationsToSetup, hasTracingEnabled, Hub, initAndBind, makeMain, setExtra } from '@sentry/core';
+import { HttpClient } from '@sentry/integrations';
+import {
+  defaultIntegrations as reactDefaultIntegrations,
+  defaultStackParser,
+  getCurrentHub,
+  makeFetchTransport,
+} from '@sentry/react';
+import type { Integration, UserFeedback } from '@sentry/types';
+import { logger, stackParserFromStackParserOptions } from '@sentry/utils';
+import * as React from 'react';
+import { Platform } from 'react-native';
+
+import { ReactNativeClient } from './client';
+import {
+  DebugSymbolicator,
+  DeviceContext,
+  EventOrigin,
+  HermesProfiling,
+  ModulesLoader,
+  ReactNativeErrorHandlers,
+  ReactNativeInfo,
+  Release,
+  SdkInfo,
+} from './integrations';
+import { NativeLinkedErrors } from './integrations/nativelinkederrors';
+import { createReactNativeRewriteFrames } from './integrations/rewriteframes';
+import { Screenshot } from './integrations/screenshot';
+import { ViewHierarchy } from './integrations/viewhierarchy';
+import type { ReactNativeClientOptions, ReactNativeOptions, ReactNativeWrapperOptions } from './options';
+import { ReactNativeScope } from './scope';
+import { TouchEventBoundary } from './touchevents';
+import { ReactNativeProfiler, ReactNativeTracing } from './tracing';
+import { DEFAULT_BUFFER_SIZE, makeNativeTransportFactory } from './transports/native';
+import { makeUtf8TextEncoder } from './transports/TextEncoder';
+import { getDefaultEnvironment } from './utils/environment';
+import { safeFactory, safeTracesSampler } from './utils/safe';
+import { NATIVE } from './wrapper';
+
+const IGNORED_DEFAULT_INTEGRATIONS = [
+  'GlobalHandlers', // We will use the react-native internal handlers
+  'TryCatch', // We don't need this
+  'LinkedErrors', // We replace this with `NativeLinkedError`
+];
+const DEFAULT_OPTIONS: ReactNativeOptions = {
+  enableNativeCrashHandling: true,
+  enableNativeNagger: true,
+  autoInitializeNativeSdk: true,
+  enableAutoPerformanceTracing: true,
+  enableWatchdogTerminationTracking: true,
+  patchGlobalPromise: true,
+  transportOptions: {
+    textEncoder: makeUtf8TextEncoder(),
+  },
+  sendClientReports: true,
+  maxQueueSize: DEFAULT_BUFFER_SIZE,
+  attachStacktrace: true,
+  enableCaptureFailedRequests: false,
+  enableNdk: true,
+};
+
+/**
+ * Inits the SDK and returns the final options.
+ */
+export function init(passedOptions: ReactNativeOptions): void {
+  const reactNativeHub = new Hub(undefined, new ReactNativeScope());
+  makeMain(reactNativeHub);
+
+  const maxQueueSize = passedOptions.maxQueueSize
+    // eslint-disable-next-line deprecation/deprecation
+    ?? passedOptions.transportOptions?.bufferSize
+    ?? DEFAULT_OPTIONS.maxQueueSize;
+
+  const enableNative = passedOptions.enableNative === undefined || passedOptions.enableNative
+    ? NATIVE.isNativeAvailable()
+    : false;
+  const options: ReactNativeClientOptions = {
+    ...DEFAULT_OPTIONS,
+    ...passedOptions,
+    enableNative,
+    // If custom transport factory fails the SDK won't initialize
+    transport: passedOptions.transport
+      || makeNativeTransportFactory({
+        enableNative,
+      })
+      || makeFetchTransport,
+    transportOptions: {
+      ...DEFAULT_OPTIONS.transportOptions,
+      ...(passedOptions.transportOptions ?? {}),
+      bufferSize: maxQueueSize,
+    },
+    maxQueueSize,
+    integrations: [],
+    stackParser: stackParserFromStackParserOptions(passedOptions.stackParser || defaultStackParser),
+    beforeBreadcrumb: safeFactory(passedOptions.beforeBreadcrumb, { loggerMessage: 'The beforeBreadcrumb threw an error' }),
+    initialScope: safeFactory(passedOptions.initialScope, { loggerMessage: 'The initialScope threw an error' }),
+    tracesSampler: safeTracesSampler(passedOptions.tracesSampler),
+  };
+  if (!('environment' in options)) {
+    options.environment = getDefaultEnvironment();
+  }
+
+  const defaultIntegrations: Integration[] = passedOptions.defaultIntegrations || [];
+  if (passedOptions.defaultIntegrations === undefined) {
+    defaultIntegrations.push(new ModulesLoader());
+    if (Platform.OS !== 'web') {
+      defaultIntegrations.push(new ReactNativeErrorHandlers({
+        patchGlobalPromise: options.patchGlobalPromise,
+      }));
+    }
+    defaultIntegrations.push(new Release());
+    defaultIntegrations.push(...[
+      ...reactDefaultIntegrations.filter(
+        (i) => !IGNORED_DEFAULT_INTEGRATIONS.includes(i.name)
+      ),
+    ]);
+
+    defaultIntegrations.push(new NativeLinkedErrors());
+    defaultIntegrations.push(new EventOrigin());
+    defaultIntegrations.push(new SdkInfo());
+    defaultIntegrations.push(new ReactNativeInfo());
+
+    if (__DEV__) {
+      defaultIntegrations.push(new DebugSymbolicator());
+    }
+
+    defaultIntegrations.push(createReactNativeRewriteFrames());
+    if (options.enableNative) {
+      defaultIntegrations.push(new DeviceContext());
+    }
+    if (options._experiments && typeof options._experiments.profilesSampleRate === 'number') {
+      defaultIntegrations.push(new HermesProfiling());
+    }
+    if (hasTracingEnabled(options) && options.enableAutoPerformanceTracing) {
+      defaultIntegrations.push(new ReactNativeTracing());
+    }
+    if (options.attachScreenshot) {
+      defaultIntegrations.push(new Screenshot());
+    }
+    if (options.attachViewHierarchy) {
+      defaultIntegrations.push(new ViewHierarchy());
+    }
+    if (options.enableCaptureFailedRequests) {
+      defaultIntegrations.push(new HttpClient());
+    }
+  }
+
+  options.integrations = getIntegrationsToSetup({
+    integrations: safeFactory(passedOptions.integrations, { loggerMessage: 'The integrations threw an error' }),
+    defaultIntegrations,
+  });
+  initAndBind(ReactNativeClient, options);
+}
+
+/**
+ * Inits the Sentry React Native SDK with automatic instrumentation and wrapped features.
+ */
+export function wrap<P extends Record<string, unknown>>(
+  RootComponent: React.ComponentType<P>,
+  options?: ReactNativeWrapperOptions
+): React.ComponentType<P> {
+  const tracingIntegration = getCurrentHub().getIntegration(ReactNativeTracing);
+  if (tracingIntegration) {
+    tracingIntegration.useAppStartWithProfiler = true;
+  }
+
+  const profilerProps = {
+    ...(options?.profilerProps ?? {}),
+    name: RootComponent.displayName ?? 'Root',
+  };
+
+  const RootApp: React.FC<P> = (appProps) => {
+    return (
+      <TouchEventBoundary {...(options?.touchEventBoundaryProps ?? {})}>
+        <ReactNativeProfiler {...profilerProps}>
+          <RootComponent {...appProps} />
+        </ReactNativeProfiler>
+      </TouchEventBoundary>
+    );
+  };
+
+  return RootApp;
+}
+
+/**
+ * Deprecated. Sets the release on the event.
+ * NOTE: Does not set the release on sessions.
+ * @deprecated
+ */
+export function setRelease(release: string): void {
+  setExtra('__sentry_release', release);
+}
+
+/**
+ * Deprecated. Sets the dist on the event.
+ * NOTE: Does not set the dist on sessions.
+ * @deprecated
+ */
+export function setDist(dist: string): void {
+  setExtra('__sentry_dist', dist);
+}
+
+/**
+ * If native client is available it will trigger a native crash.
+ * Use this only for testing purposes.
+ */
+export function nativeCrash(): void {
+  const client = getCurrentHub().getClient<ReactNativeClient>();
+  if (client) {
+    client.nativeCrash();
+  }
+}
+
+/**
+ * Flushes all pending events in the queue to disk.
+ * Use this before applying any realtime updates such as code-push or expo updates.
+ */
+export async function flush(): Promise<boolean> {
+  try {
+    const client = getCurrentHub().getClient<ReactNativeClient>();
+
+    if (client) {
+      const result = await client.flush();
+
+      return result;
+    }
+    // eslint-disable-next-line no-empty
+  } catch (_) { }
+
+  logger.error('Failed to flush the event queue.');
+
+  return false;
+}
+
+/**
+ * Closes the SDK, stops sending events.
+ */
+export async function close(): Promise<void> {
+  try {
+    const client = getCurrentHub().getClient<ReactNativeClient>();
+
+    if (client) {
+      await client.close();
+    }
+  } catch (e) {
+    logger.error('Failed to close the SDK');
+  }
+}
+
+/**
+ * Captures user feedback and sends it to Sentry.
+ */
+export function captureUserFeedback(feedback: UserFeedback): void {
+  getCurrentHub().getClient<ReactNativeClient>()?.captureUserFeedback(feedback);
+}
+
+/**
+ * Creates a new scope with and executes the given operation within.
+ * The scope is automatically removed once the operation
+ * finishes or throws.
+ *
+ * This is essentially a convenience function for:
+ *
+ *     pushScope();
+ *     callback();
+ *     popScope();
+ *
+ * @param callback that will be enclosed into push/popScope.
+ */
+export function withScope(callback: (scope: Scope) => void): ReturnType<Hub['withScope']> {
+  const safeCallback = (scope: Scope): void => {
+    try {
+      callback(scope);
+    } catch (e) {
+      logger.error('Error while running withScope callback', e);
+    }
+  };
+  getCurrentHub().withScope(safeCallback);
+}
+
+/**
+ * Callback to set context information onto the scope.
+ * @param callback Callback function that receives Scope.
+ */
+export function configureScope(callback: (scope: Scope) => void): ReturnType<Hub['configureScope']> {
+  const safeCallback = (scope: Scope): void => {
+    try {
+      callback(scope);
+    } catch (e) {
+      logger.error('Error while running configureScope callback', e);
+    }
+  };
+  getCurrentHub().configureScope(safeCallback);
+}
diff --git a/node_modules/@sentry/react-native/src/js/tools/ModulesCollector.ts b/node_modules/@sentry/react-native/src/js/tools/ModulesCollector.ts
new file mode 100644
index 0000000..739fe44
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/ModulesCollector.ts
@@ -0,0 +1,136 @@
+import { logger } from '@sentry/utils';
+import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
+import { posix, sep } from 'path';
+
+logger.enable();
+
+// eslint-disable-next-line @typescript-eslint/unbound-method
+const { dirname, join, resolve, sep: posixSep } = posix;
+
+interface Package {
+  name?: string;
+  version?: string;
+}
+
+/**
+ * Collects JS modules from source paths.
+ */
+export default class ModulesCollector {
+  /** Collect method */
+  public static collect(sources: unknown[], modulesPaths: string[]): Record<string, string> {
+    const normalizedModulesPaths = modulesPaths.map(modulesPath => resolve(modulesPath.split(sep).join(posixSep)));
+
+    const infos: Record<string, string> = {};
+    const seen: Record<string, true> = {};
+
+    sources.forEach((path: unknown) => {
+      if (typeof path !== 'string') {
+        return;
+      }
+
+      let dir = path; // included source file path
+      let candidate: Package | null = null;
+
+      /** Traverse directories upward in the search of all package.json files */
+      const upDirSearch = (): void => {
+        const parentDir = dir;
+        dir = dirname(parentDir);
+
+        if (normalizedModulesPaths.includes(resolve(dir))) {
+          if (candidate?.name && candidate?.version) {
+            infos[candidate.name] = candidate.version;
+          } else if (candidate?.name) {
+            infos[candidate.name] = 'unknown';
+          }
+          return;
+        }
+
+        if (!dir || parentDir === dir || seen[dir]) {
+          return;
+        }
+        seen[dir] = true;
+
+        const pkgPath = join(dir, 'package.json');
+        if (!existsSync(pkgPath)) {
+          // fast-forward if the package.json doesn't exist
+          return upDirSearch();
+        }
+
+        try {
+          const info: Package = JSON.parse(readFileSync(pkgPath, 'utf8'));
+          candidate = {
+            name: info.name,
+            version: info.version,
+          };
+        } catch (error) {
+          logger.error(`Failed to read ${pkgPath}`);
+        }
+
+        return upDirSearch(); // processed package.json file, continue up search
+      };
+
+      upDirSearch();
+    });
+
+    return infos;
+  }
+
+  /**
+   * Runs collection of modules.
+   */
+  public static run({
+    sourceMapPath,
+    outputModulesPath,
+    modulesPaths,
+    collect,
+  }: Partial<{
+    sourceMapPath: string;
+    outputModulesPath: string;
+    modulesPaths: string[];
+    collect: (sources: unknown[], modulesPaths: string[]) => Record<string, string>;
+  }>): void {
+    if (!sourceMapPath) {
+      logger.error('First argument `source-map-path` is missing!');
+      return;
+    }
+    if (!outputModulesPath) {
+      logger.error('Second argument `modules-output-path` is missing!');
+      return;
+    }
+    if (!modulesPaths || modulesPaths.length === 0) {
+      logger.error('Third argument `modules-paths` is missing!');
+      return;
+    }
+
+    logger.info('Reading source map from', sourceMapPath);
+    logger.info('Saving modules to', outputModulesPath);
+    logger.info('Resolving modules from paths', modulesPaths.join(', '));
+
+    if (!existsSync(sourceMapPath)) {
+      logger.error(`Source map file does not exist at ${sourceMapPath}`);
+      return;
+    }
+    for (const modulesPath of modulesPaths) {
+      if (!existsSync(modulesPath)) {
+        logger.error(`Modules path does not exist at ${modulesPath}`);
+        return;
+      }
+    }
+
+    const map: { sources?: unknown } = JSON.parse(readFileSync(sourceMapPath, 'utf8'));
+    if (!map.sources || !Array.isArray(map.sources)) {
+      logger.error(`Modules not collected. No sources found in the source map (${sourceMapPath})!`);
+      return;
+    }
+
+    const sources: unknown[] = map.sources;
+    const modules = collect ? collect(sources, modulesPaths) : ModulesCollector.collect(sources, modulesPaths);
+
+    const outputModulesDirPath = dirname(outputModulesPath);
+    if (!existsSync(outputModulesDirPath)) {
+      mkdirSync(outputModulesDirPath, { recursive: true });
+    }
+    writeFileSync(outputModulesPath, JSON.stringify(modules, null, 2));
+    logger.info(`Modules collected and saved to: ${outputModulesPath}`);
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tools/collectModules.ts b/node_modules/@sentry/react-native/src/js/tools/collectModules.ts
new file mode 100755
index 0000000..ed386b2
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/collectModules.ts
@@ -0,0 +1,10 @@
+/* eslint-disable @typescript-eslint/no-unsafe-member-access */
+import { argv } from 'process';
+
+import ModulesCollector from './ModulesCollector';
+
+const sourceMapPath: string | undefined = argv[2];
+const outputModulesPath: string | undefined = argv[3];
+const modulesPaths: string[] = argv[4] ? argv[4].split(',') : [];
+
+ModulesCollector.run({ sourceMapPath, outputModulesPath, modulesPaths });
diff --git a/node_modules/@sentry/react-native/src/js/tools/sentryMetroSerializer.ts b/node_modules/@sentry/react-native/src/js/tools/sentryMetroSerializer.ts
new file mode 100644
index 0000000..27600ba
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/sentryMetroSerializer.ts
@@ -0,0 +1,221 @@
+import * as crypto from 'crypto';
+import type { MetroConfig, MixedOutput, Module, ReadOnlyGraph } from 'metro';
+import * as countLines from 'metro/src/lib/countLines';
+
+import type { Bundle, MetroSerializer, MetroSerializerOutput, SerializedBundle, VirtualJSOutput } from './utils';
+import { createDebugIdSnippet, createSet, determineDebugIdFromBundleSource, stringToUUID } from './utils';
+import { createDefaultMetroSerializer } from './vendor/metro/utils';
+
+type SourceMap = Record<string, unknown>;
+
+const DEBUG_ID_PLACE_HOLDER = '__debug_id_place_holder__';
+const DEBUG_ID_MODULE_PATH = '__debugid__';
+const PRELUDE_MODULE_PATH = '__prelude__';
+const SOURCE_MAP_COMMENT = '//# sourceMappingURL=';
+const DEBUG_ID_COMMENT = '//# debugId=';
+
+/**
+ * This config will overwrite any existing custom serializer with default Expo and Sentry serializers.
+ *
+ * To use custom serializers, use `createSentryMetroSerializer(customSerializer)` instead.
+ */
+export function getSentryExpoConfig(projectRoot: string): MetroConfig {
+  const { getDefaultConfig } = loadExpoMetroConfigModule();
+  return getDefaultConfig(projectRoot, {unstable_beforeAssetSerializationPlugins: [unstable_beforeAssetSerializationPlugin]});
+}
+
+function unstable_beforeAssetSerializationPlugin({graph, premodules, debugId}: {
+  graph: ReadOnlyGraph<MixedOutput>;
+  premodules: Module[];
+  debugId?: string;
+}) : Module[] {
+  if (graph.transformOptions.hot || !debugId) {
+    return premodules;
+  }
+
+  const debugIdModuleExists = premodules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;
+  if (debugIdModuleExists) {
+    // eslint-disable-next-line no-console
+    console.warn('Debug ID module found. Skipping Sentry Debug ID module...');
+    return premodules;
+  }
+
+  const debugIdModule = createDebugIdModule(debugId);
+  return [...addDebugIdModule(premodules, debugIdModule)];
+}
+
+function loadExpoMetroConfigModule(): {
+  getDefaultConfig: (
+    projectRoot: string,
+    options: {
+      unstable_beforeAssetSerializationPlugins?: ((serializationInput: {
+        graph: ReadOnlyGraph<MixedOutput>;
+        premodules: Module[];
+        debugId?: string;
+    }) => Module[])[];}
+  ) => MetroConfig;
+} {
+  try {
+    // eslint-disable-next-line @typescript-eslint/no-var-requires
+    return require('expo/metro-config');
+  } catch (e) {
+    throw new Error(
+      'Unable to load `expo/metro-config`. Make sure you have Expo installed.',
+    );
+  }
+}
+
+/**
+ * Creates a Metro serializer that adds Debug ID module to the plain bundle.
+ * The Debug ID module is a virtual module that provides a debug ID in runtime.
+ *
+ * RAM Bundles do not support custom serializers.
+ */
+export const createSentryMetroSerializer = (customSerializer?: MetroSerializer): MetroSerializer => {
+  const serializer = customSerializer || createDefaultMetroSerializer();
+  return async function (entryPoint, preModules, graph, options) {
+    if (graph.transformOptions.hot) {
+      return serializer(entryPoint, preModules, graph, options);
+    }
+
+    const debugIdModuleExists = preModules.findIndex(module => module.path === DEBUG_ID_MODULE_PATH) != -1;
+    if (debugIdModuleExists) {
+      // eslint-disable-next-line no-console
+      console.warn('Debug ID module found. Skipping Sentry Debug ID module...');
+      return serializer(entryPoint, preModules, graph, options);
+    }
+
+    const debugIdModule = createDebugIdModule(DEBUG_ID_PLACE_HOLDER);
+    options.sentryBundleCallback = createSentryBundleCallback(debugIdModule);
+    const modifiedPreModules = addDebugIdModule(preModules, debugIdModule);
+
+    // Run wrapped serializer
+    const serializerResult = serializer(entryPoint, modifiedPreModules, graph, options);
+    const { code: bundleCode, map: bundleMapString } = await extractSerializerResult(serializerResult);
+
+    // Add debug id comment to the bundle
+    const debugId = determineDebugIdFromBundleSource(bundleCode);
+    if (!debugId) {
+      throw new Error(
+        'Debug ID was not found in the bundle. Call `options.sentryBundleCallback` if you are using a custom serializer.',
+      );
+    }
+    // Only print debug id for command line builds => not hot reload from dev server
+    // eslint-disable-next-line no-console
+    console.log('info ' + `Bundle Debug ID: ${debugId}`);
+
+    const debugIdComment = `${DEBUG_ID_COMMENT}${debugId}`;
+    const indexOfSourceMapComment = bundleCode.lastIndexOf(SOURCE_MAP_COMMENT);
+    const bundleCodeWithDebugId =
+      indexOfSourceMapComment === -1
+        ? // If source map comment is missing lets just add the debug id comment
+          `${bundleCode}\n${debugIdComment}`
+        : // If source map comment is present lets add the debug id comment before it
+          `${bundleCode.substring(0, indexOfSourceMapComment) + debugIdComment}\n${bundleCode.substring(
+            indexOfSourceMapComment,
+          )}`;
+
+    const bundleMap: SourceMap = JSON.parse(bundleMapString);
+    // For now we write both fields until we know what will become the standard - if ever.
+    bundleMap['debug_id'] = debugId;
+    bundleMap['debugId'] = debugId;
+
+    return {
+      code: bundleCodeWithDebugId,
+      map: JSON.stringify(bundleMap),
+    };
+  };
+};
+
+/**
+ * This function is expected to be called after serializer creates the final bundle object
+ * and before the source maps are generated.
+ *
+ * It injects a debug ID into the bundle and returns the modified bundle.
+ *
+ * Access it via `options.sentryBundleCallback` in your custom serializer.
+ */
+function createSentryBundleCallback(debugIdModule: Module<VirtualJSOutput> & { setSource: (code: string) => void }) {
+  return (bundle: Bundle) => {
+    const debugId = calculateDebugId(bundle);
+    debugIdModule.setSource(injectDebugId(debugIdModule.getSource().toString(), debugId));
+    bundle.pre = injectDebugId(bundle.pre, debugId);
+    return bundle;
+  };
+}
+
+function addDebugIdModule(
+  preModules: readonly Module<MixedOutput>[],
+  debugIdModule: Module<VirtualJSOutput>,
+): readonly Module<MixedOutput>[] {
+  const modifiedPreModules = [...preModules];
+  if (
+    modifiedPreModules.length > 0 &&
+    modifiedPreModules[0] !== undefined &&
+    modifiedPreModules[0].path === PRELUDE_MODULE_PATH
+  ) {
+    // prelude module must be first as it measures the bundle startup time
+    modifiedPreModules.unshift(preModules[0]);
+    modifiedPreModules[1] = debugIdModule;
+  } else {
+    modifiedPreModules.unshift(debugIdModule);
+  }
+  return modifiedPreModules;
+}
+
+async function extractSerializerResult(serializerResult: MetroSerializerOutput): Promise<SerializedBundle> {
+  if (typeof serializerResult === 'string') {
+    return { code: serializerResult, map: '{}' };
+  }
+
+  if ('map' in serializerResult) {
+    return { code: serializerResult.code, map: serializerResult.map };
+  }
+
+  const awaitedResult = await serializerResult;
+  if (typeof awaitedResult === 'string') {
+    return { code: awaitedResult, map: '{}' };
+  }
+
+  return { code: awaitedResult.code, map: awaitedResult.map };
+}
+
+function createDebugIdModule(debugId: string): Module<VirtualJSOutput> & { setSource: (code: string) => void } {
+  let debugIdCode = createDebugIdSnippet(debugId);
+
+  return {
+    setSource: (code: string) => {
+      debugIdCode = code;
+    },
+    dependencies: new Map(),
+    getSource: () => Buffer.from(debugIdCode),
+    inverseDependencies: createSet(),
+    path: DEBUG_ID_MODULE_PATH,
+    output: [
+      {
+        type: 'js/script/virtual',
+        data: {
+          code: debugIdCode,
+          lineCount: countLines(debugIdCode),
+          map: [],
+        },
+      },
+    ],
+  };
+}
+
+function calculateDebugId(bundle: Bundle): string {
+  const hash = crypto.createHash('md5');
+  hash.update(bundle.pre);
+  for (const [, code] of bundle.modules) {
+    hash.update(code);
+  }
+  hash.update(bundle.post);
+
+  const debugId = stringToUUID(hash.digest('hex'));
+  return debugId;
+}
+
+function injectDebugId(code: string, debugId: string): string {
+  return code.replace(new RegExp(DEBUG_ID_PLACE_HOLDER, 'g'), debugId);
+}
diff --git a/node_modules/@sentry/react-native/src/js/tools/utils.ts b/node_modules/@sentry/react-native/src/js/tools/utils.ts
new file mode 100644
index 0000000..1f67798
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/utils.ts
@@ -0,0 +1,98 @@
+import * as crypto from 'crypto';
+import type { Module, ReadOnlyGraph, SerializerOptions } from 'metro';
+import type CountingSet from 'metro/src/lib/CountingSet';
+
+// Variant of MixedOutput
+// https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/DeltaBundler/types.flow.js#L21
+export type VirtualJSOutput = {
+  type: 'js/script/virtual';
+  data: {
+    code: string;
+    lineCount: number;
+    map: [];
+  };
+};
+
+export type Bundle = {
+  modules: Array<[id: number, code: string]>;
+  post: string;
+  pre: string;
+};
+
+export type SentryMetroSerializerOptionsExtras = {
+  sentryBundleCallback?: (bundle: Bundle) => Bundle;
+};
+
+export type SerializedBundle = { code: string; map: string };
+
+export type MetroSerializerOutput = string | SerializedBundle | Promise<string | SerializedBundle>;
+
+export type MetroSerializer = (
+  entryPoint: string,
+  preModules: ReadonlyArray<Module>,
+  graph: ReadOnlyGraph,
+  options: SerializerOptions & SentryMetroSerializerOptionsExtras,
+) => MetroSerializerOutput;
+
+/**
+ * Returns minified Debug ID code snippet.
+ */
+export function createDebugIdSnippet(debugId: string): string {
+  return `var _sentryDebugIds={},_sentryDebugIdIdentifier="";void 0===_sentryDebugIds&&(_sentryDebugIds={});try{var stack=(new Error).stack;stack&&(_sentryDebugIds[stack]="${debugId}",_sentryDebugIdIdentifier="sentry-dbid-${debugId}")}catch(e){}`;
+}
+
+/**
+ * Deterministically hashes a string and turns the hash into a uuid.
+ *
+ * https://github.com/getsentry/sentry-javascript-bundler-plugins/blob/58271f1af2ade6b3e64d393d70376ae53bc5bd2f/packages/bundler-plugin-core/src/utils.ts#L174
+ */
+export function stringToUUID(str: string): string {
+  const md5sum = crypto.createHash('md5');
+  md5sum.update(str);
+  const md5Hash = md5sum.digest('hex');
+
+  // Position 16 is fixed to either 8, 9, a, or b in the uuid v4 spec (10xx in binary)
+  // RFC 4122 section 4.4
+  const v4variant = ['8', '9', 'a', 'b'][md5Hash.substring(16, 17).charCodeAt(0) % 4] as string;
+
+  return `${md5Hash.substring(0, 8)}-${md5Hash.substring(8, 12)}-4${md5Hash.substring(
+    13,
+    16,
+  )}-${v4variant}${md5Hash.substring(17, 20)}-${md5Hash.substring(20)}`.toLowerCase();
+}
+
+/**
+ * Looks for a particular string pattern (`sdbid-[debug ID]`) in the bundle
+ * source and extracts the bundle's debug ID from it.
+ *
+ * The string pattern is injected via the debug ID injection snipped.
+ *
+ * https://github.com/getsentry/sentry-javascript-bundler-plugins/blob/40f918458ed449d8b3eabaf64d13c08218213f65/packages/bundler-plugin-core/src/debug-id-upload.ts#L293-L294
+ */
+export function determineDebugIdFromBundleSource(code: string): string | undefined {
+  const match = code.match(
+    /sentry-dbid-([0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12})/,
+  );
+  return match ? match[1] : undefined;
+}
+
+/**
+ * CountingSet was added in Metro 0.72.0 before that NodeJS Set was used.
+ *
+ * https://github.com/facebook/metro/blob/fc29a1177f883144674cf85a813b58567f69d545/packages/metro/src/lib/CountingSet.js
+ */
+function resolveSetCreator(): () => CountingSet<string> {
+  try {
+    // eslint-disable-next-line @typescript-eslint/no-var-requires
+    const { default: MetroSet } = require('metro/src/lib/CountingSet');
+    return () => new MetroSet();
+  } catch (e) {
+    if (e instanceof Error && 'code' in e && e.code === 'MODULE_NOT_FOUND') {
+      return () => new Set() as unknown as CountingSet<string>;
+    } else {
+      throw e;
+    }
+  }
+}
+
+export const createSet = resolveSetCreator();
diff --git a/node_modules/@sentry/react-native/src/js/tools/vendor/metro/metro.d.ts b/node_modules/@sentry/react-native/src/js/tools/vendor/metro/metro.d.ts
new file mode 100644
index 0000000..8a0f34c
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/vendor/metro/metro.d.ts
@@ -0,0 +1,71 @@
+// Vendored / modified from @facebook/metro
+
+// https://github.com/facebook/metro/commit/9b85f83c9cc837d8cd897aa7723be7da5b296067
+
+// MIT License
+
+// Copyright (c) Meta Platforms, Inc. and affiliates.
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+declare module 'metro/src/DeltaBundler/Serializers/baseJSBundle' {
+  // https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/DeltaBundler/Serializers/baseJSBundle.js#L25
+  const baseJSBundle: (
+    entryPoint: string,
+    preModules: ReadonlyArray<Module>,
+    graph: ReadOnlyGraph,
+    options: SerializerOptions,
+  ) => {
+    modules: [number, string][];
+    post: string;
+    pre: string;
+  };
+  export = baseJSBundle;
+}
+
+declare module 'metro/src/lib/bundleToString' {
+  // https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/lib/bundleToString.js#L22
+  const baseJSBundle: (bundle: { modules: [number, string][]; post: string; pre: string }) => {
+    code: string;
+    metadata: BundleMetadata;
+  };
+
+  export = baseJSBundle;
+}
+
+declare module 'metro/src/lib/countLines' {
+  // https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/lib/countLines.js#L16
+  const countLines: (code: string) => number;
+  export = countLines;
+}
+
+declare module 'metro/src/DeltaBundler/Serializers/sourceMapString' {
+  import type { MixedOutput, Module } from 'metro';
+
+  // https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/DeltaBundler/Serializers/sourceMapString.js#L19
+  const sourceMapString: (
+    bundle: Module<MixedOutput>[],
+    options: {
+      excludeSource?: boolean;
+      processModuleFilter?: (module: Module<MixedOutput>) => boolean;
+      shouldAddToIgnoreList?: (module: Module<MixedOutput>) => boolean;
+    },
+  ) => string;
+  export = sourceMapString;
+}
diff --git a/node_modules/@sentry/react-native/src/js/tools/vendor/metro/utils.ts b/node_modules/@sentry/react-native/src/js/tools/vendor/metro/utils.ts
new file mode 100644
index 0000000..7f57aa5
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tools/vendor/metro/utils.ts
@@ -0,0 +1,85 @@
+// Vendored / modified from @facebook/metro
+
+// https://github.com/facebook/metro/commit/9b85f83c9cc837d8cd897aa7723be7da5b296067
+
+// MIT License
+
+// Copyright (c) Meta Platforms, Inc. and affiliates.
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+import type { MixedOutput, Module, ReadOnlyGraph } from 'metro';
+import * as baseJSBundle from 'metro/src/DeltaBundler/Serializers/baseJSBundle';
+import * as sourceMapString from 'metro/src/DeltaBundler/Serializers/sourceMapString';
+import * as bundleToString from 'metro/src/lib/bundleToString';
+
+import type { MetroSerializer } from '../../utils';
+
+/**
+ * This function ensures that modules in source maps are sorted in the same
+ * order as in a plain JS bundle.
+ *
+ * https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/Server.js#L984
+ */
+export const getSortedModules = (
+  graph: ReadOnlyGraph,
+  {
+    createModuleId,
+  }: {
+    createModuleId: (file: string) => number;
+  },
+): readonly Module[] => {
+  const modules = [...graph.dependencies.values()];
+  // Sort by IDs
+  return modules.sort(
+    (a: Module<MixedOutput>, b: Module<MixedOutput>) => createModuleId(a.path) - createModuleId(b.path),
+  );
+};
+
+/**
+ * Creates the default Metro plain bundle serializer.
+ * Because Metro exports only the intermediate serializer functions, we need to
+ * assemble the final serializer ourselves. We have to work with the modules the same as Metro does
+ * to avoid unexpected changes in the final bundle.
+ *
+ * This is used when the user does not provide a custom serializer.
+ *
+ * https://github.com/facebook/metro/blob/9b85f83c9cc837d8cd897aa7723be7da5b296067/packages/metro/src/Server.js#L244-L277
+ */
+export const createDefaultMetroSerializer = (): MetroSerializer => {
+  return (entryPoint, preModules, graph, options) => {
+    // baseJSBundle assigns IDs to modules in a consistent order
+    let bundle = baseJSBundle(entryPoint, preModules, graph, options);
+    if (options.sentryBundleCallback && !graph.transformOptions.hot) {
+      bundle = options.sentryBundleCallback(bundle);
+    }
+    const { code } = bundleToString(bundle);
+    if (graph.transformOptions.hot) {
+      // Hot means running in dev server, sourcemaps are generated on demand
+      return code;
+    }
+
+    // Always generate source maps, can't use Sentry without source maps
+    const map = sourceMapString([...preModules, ...getSortedModules(graph, options)], {
+      processModuleFilter: options.processModuleFilter,
+      shouldAddToIgnoreList: options.shouldAddToIgnoreList,
+    });
+    return { code, map };
+  };
+};
diff --git a/node_modules/@sentry/react-native/src/js/touchevents.tsx b/node_modules/@sentry/react-native/src/js/touchevents.tsx
new file mode 100644
index 0000000..fa58273
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/touchevents.tsx
@@ -0,0 +1,266 @@
+import { addBreadcrumb, getCurrentHub } from '@sentry/core';
+import type { SeverityLevel } from '@sentry/types';
+import { logger } from '@sentry/utils';
+import * as React from 'react';
+import type { GestureResponderEvent} from 'react-native';
+import { StyleSheet, View } from 'react-native';
+
+import { createIntegration } from './integrations/factory';
+import { ReactNativeTracing } from './tracing';
+import { UI_ACTION_TOUCH } from './tracing/ops';
+
+export type TouchEventBoundaryProps = {
+  /**
+   * The category assigned to the breadcrumb that is logged by the touch event.
+   */
+  breadcrumbCategory?: string;
+  /**
+   * The type assigned to the breadcrumb that is logged by the touch event.
+   */
+  breadcrumbType?: string;
+  /**
+   * The max number of components to display when logging a touch's component tree.
+   */
+  maxComponentTreeSize?: number;
+  /**
+   * Component name(s) to ignore when logging the touch event. This prevents unhelpful logs such as
+   * "Touch event within element: View" where you still can't tell which View it occurred in.
+   */
+  ignoreNames?: Array<string | RegExp>;
+  /**
+   * Deprecated, use ignoreNames instead
+   * @deprecated
+   */
+  ignoredDisplayNames?: Array<string | RegExp>;
+  /**
+   * React Node wrapped by TouchEventBoundary.
+   */
+  children?: React.ReactNode;
+  /**
+   * Label Name used to identify the touched element.
+   */
+  labelName?: string;
+};
+
+const touchEventStyles = StyleSheet.create({
+  wrapperView: {
+    flex: 1,
+  },
+});
+
+const DEFAULT_BREADCRUMB_CATEGORY = 'touch';
+const DEFAULT_BREADCRUMB_TYPE = 'user';
+const DEFAULT_MAX_COMPONENT_TREE_SIZE = 20;
+
+const SENTRY_LABEL_PROP_KEY = 'sentry-label';
+
+interface ElementInstance {
+  elementType?: {
+    displayName?: string;
+    name?: string;
+  };
+  memoizedProps?: Record<string, unknown>;
+  return?: ElementInstance;
+}
+
+interface PrivateGestureResponderEvent extends GestureResponderEvent {
+  _targetInst?: ElementInstance;
+}
+
+/**
+ * Boundary to log breadcrumbs for interaction events.
+ */
+class TouchEventBoundary extends React.Component<TouchEventBoundaryProps> {
+
+  public static displayName: string = '__Sentry.TouchEventBoundary';
+  public static defaultProps: Partial<TouchEventBoundaryProps> = {
+    breadcrumbCategory: DEFAULT_BREADCRUMB_CATEGORY,
+    breadcrumbType: DEFAULT_BREADCRUMB_TYPE,
+    ignoreNames: [],
+    maxComponentTreeSize: DEFAULT_MAX_COMPONENT_TREE_SIZE,
+  };
+
+  public readonly name: string = 'TouchEventBoundary';
+
+  private _tracingIntegration: ReactNativeTracing | null = null;
+
+  /**
+   * Registers the TouchEventBoundary as a Sentry Integration.
+   */
+  public componentDidMount(): void {
+    const client = getCurrentHub().getClient();
+    client?.addIntegration?.(createIntegration(this.name));
+    if (!this._tracingIntegration && client) {
+      this._tracingIntegration = client.getIntegration(ReactNativeTracing);
+    }
+  }
+
+  /**
+   *
+   */
+  public render(): React.ReactNode {
+    return (
+      <View
+        style={touchEventStyles.wrapperView}
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        onTouchStart={this._onTouchStart.bind(this) as any}
+      >
+        {this.props.children}
+      </View>
+    );
+  }
+
+  /**
+   * Logs the touch event given the component tree names and a label.
+   */
+  private _logTouchEvent(
+    componentTreeNames: string[],
+    activeLabel?: string
+  ): void {
+    const level = 'info' as SeverityLevel;
+    const crumb = {
+      category: this.props.breadcrumbCategory,
+      data: { componentTree: componentTreeNames },
+      level: level,
+      message: activeLabel
+        ? `Touch event within element: ${activeLabel}`
+        : 'Touch event within component tree',
+      type: this.props.breadcrumbType,
+    };
+    addBreadcrumb(crumb);
+
+    logger.log(`[TouchEvents] ${crumb.message}`);
+  }
+
+  /**
+   * Checks if the name is supposed to be ignored.
+   */
+  private _isNameIgnored(name: string): boolean {
+    let ignoreNames = this.props.ignoreNames || [];
+    // eslint-disable-next-line deprecation/deprecation
+    if (this.props.ignoredDisplayNames) {
+      // This is to make it compatible with prior version.
+      // eslint-disable-next-line deprecation/deprecation
+      ignoreNames = [...ignoreNames, ...this.props.ignoredDisplayNames];
+    }
+
+    return ignoreNames.some(
+      (ignoreName: string | RegExp) =>
+        (typeof ignoreName === 'string' && name === ignoreName) ||
+        (ignoreName instanceof RegExp && name.match(ignoreName))
+    );
+  }
+
+  // Originally was going to clean the names of any HOCs as well but decided that it might hinder debugging effectively. Will leave here in case
+  // private readonly _cleanName = (name: string): string =>
+  //   name.replace(/.*\(/g, "").replace(/\)/g, "");
+
+  /**
+   * Traverses through the component tree when a touch happens and logs it.
+   * @param e
+   */
+  // eslint-disable-next-line complexity
+  private _onTouchStart(e: PrivateGestureResponderEvent): void {
+    if (!e._targetInst) {
+      return;
+    }
+
+    let currentInst: ElementInstance | undefined = e._targetInst;
+
+    let activeLabel: string | undefined;
+    let activeDisplayName: string | undefined;
+    const componentTreeNames: string[] = [];
+
+    while (
+      currentInst &&
+      // maxComponentTreeSize will always be defined as we have a defaultProps. But ts needs a check so this is here.
+      this.props.maxComponentTreeSize &&
+      componentTreeNames.length < this.props.maxComponentTreeSize
+    ) {
+      if (
+        // If the loop gets to the boundary itself, break.
+        currentInst.elementType?.displayName ===
+        TouchEventBoundary.displayName
+      ) {
+        break;
+      }
+
+      const props = currentInst.memoizedProps;
+      const sentryLabel =
+        typeof props?.[SENTRY_LABEL_PROP_KEY] !== 'undefined'
+          ? `${props[SENTRY_LABEL_PROP_KEY]}`
+          : undefined;
+
+      // For some reason type narrowing doesn't work as expected with indexing when checking it all in one go in
+      // the "check-label" if sentence, so we have to assign it to a variable here first
+      let labelValue;
+      if (typeof this.props.labelName === 'string')
+        labelValue = props?.[this.props.labelName];
+
+      // Check the label first
+      if (sentryLabel && !this._isNameIgnored(sentryLabel)) {
+        if (!activeLabel) {
+          activeLabel = sentryLabel;
+        }
+        componentTreeNames.push(sentryLabel);
+      } else if (
+        typeof labelValue === 'string' &&
+        !this._isNameIgnored(labelValue)
+      ) {
+        if (!activeLabel) {
+          activeLabel = labelValue;
+        }
+        componentTreeNames.push(labelValue);
+      } else if (currentInst.elementType) {
+        const { elementType } = currentInst;
+
+        if (
+          elementType.displayName &&
+          !this._isNameIgnored(elementType.displayName)
+        ) {
+          // Check display name
+          if (!activeDisplayName) {
+            activeDisplayName = elementType.displayName;
+          }
+          componentTreeNames.push(elementType.displayName);
+        }
+      }
+
+      currentInst = currentInst.return;
+    }
+
+    const finalLabel = activeLabel ?? activeDisplayName;
+
+    if (componentTreeNames.length > 0 || finalLabel) {
+      this._logTouchEvent(componentTreeNames, finalLabel);
+    }
+
+    this._tracingIntegration?.startUserInteractionTransaction({
+      elementId: activeLabel,
+      op: UI_ACTION_TOUCH,
+    });
+  }
+}
+
+/**
+ * Convenience Higher-Order-Component for TouchEventBoundary
+ * @param WrappedComponent any React Component
+ * @param boundaryProps TouchEventBoundaryProps
+ */
+const withTouchEventBoundary = (
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  InnerComponent: React.ComponentType<any>,
+  boundaryProps?: TouchEventBoundaryProps
+): React.FunctionComponent => {
+  const WrappedComponent: React.FunctionComponent = (props) => (
+    <TouchEventBoundary {...(boundaryProps ?? {})}>
+      <InnerComponent {...props} />
+    </TouchEventBoundary>
+  );
+
+  WrappedComponent.displayName = 'WithTouchEventBoundary';
+
+  return WrappedComponent;
+};
+
+export { TouchEventBoundary, withTouchEventBoundary };
diff --git a/node_modules/@sentry/react-native/src/js/tracing/addTracingExtensions.ts b/node_modules/@sentry/react-native/src/js/tracing/addTracingExtensions.ts
new file mode 100644
index 0000000..3244e7d
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/addTracingExtensions.ts
@@ -0,0 +1,86 @@
+import type { Hub, Transaction } from '@sentry/core';
+import { addTracingExtensions, getCurrentHub, getMainCarrier } from '@sentry/core';
+import type { CustomSamplingContext, Span, SpanContext, TransactionContext } from '@sentry/types';
+
+import { DEFAULT } from '../tracing/ops';
+import { ReactNativeTracing } from '../tracing/reactnativetracing';
+
+/**
+ * Adds React Native's extensions. Needs to be called before any transactions are created.
+ */
+export function _addTracingExtensions(): void {
+  addTracingExtensions();
+  const carrier = getMainCarrier();
+  if (carrier.__SENTRY__) {
+    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
+    if (carrier.__SENTRY__.extensions.startTransaction) {
+      const originalStartTransaction = carrier.__SENTRY__.extensions.startTransaction as StartTransactionFunction;
+
+      /*
+        Overwrites the transaction start and finish to start and finish stall tracking.
+        Preferably instead of overwriting add a callback method for this in the Transaction itself.
+      */
+      const _startTransaction = _patchStartTransaction(originalStartTransaction);
+
+      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
+    }
+  }
+}
+
+export type StartTransactionFunction = (
+  this: Hub,
+  transactionContext: TransactionContext,
+  customSamplingContext?: CustomSamplingContext,
+) => Transaction;
+
+/**
+ * Overwrite the startTransaction extension method to start and end stall tracking.
+ */
+const _patchStartTransaction = (originalStartTransaction: StartTransactionFunction): StartTransactionFunction => {
+  /**
+   * Method to overwrite with
+   */
+  function _startTransaction(
+    this: Hub,
+    transactionContext: TransactionContext,
+    customSamplingContext?: CustomSamplingContext,
+  ): Transaction {
+    // Native SDKs require op to be set - for JS Relay sets `default`
+    if (!transactionContext.op) {
+      transactionContext.op = DEFAULT;
+    }
+
+    const transaction: Transaction = originalStartTransaction.apply(this, [transactionContext, customSamplingContext]);
+    const originalStartChild: Transaction['startChild'] = transaction.startChild.bind(transaction);
+    transaction.startChild = (
+      spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'sampled' | 'traceId' | 'parentSpanId'>>,
+    ): Span => {
+      return originalStartChild({
+        ...spanContext,
+        // Native SDKs require op to be set
+        op: spanContext?.op || DEFAULT,
+      });
+    };
+
+    const reactNativeTracing = getCurrentHub().getIntegration(ReactNativeTracing);
+
+    if (reactNativeTracing) {
+      reactNativeTracing.onTransactionStart(transaction);
+
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      const originalFinish = transaction.finish;
+
+      transaction.finish = (endTimestamp: number | undefined) => {
+        if (reactNativeTracing) {
+          reactNativeTracing.onTransactionFinish(transaction);
+        }
+
+        return originalFinish.apply(transaction, [endTimestamp]);
+      };
+    }
+
+    return transaction;
+  }
+
+  return _startTransaction;
+};
diff --git a/node_modules/@sentry/react-native/src/js/tracing/gesturetracing.ts b/node_modules/@sentry/react-native/src/js/tracing/gesturetracing.ts
new file mode 100644
index 0000000..8bc6f9d
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/gesturetracing.ts
@@ -0,0 +1,155 @@
+import { getCurrentHub } from '@sentry/core';
+import type { Breadcrumb, Hub } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { UI_ACTION } from './ops';
+import { ReactNativeTracing } from './reactnativetracing';
+
+export const DEFAULT_BREADCRUMB_CATEGORY = 'gesture';
+export const DEFAULT_BREADCRUMB_TYPE = 'user';
+
+export const GESTURE_POSTFIX_LENGTH = 'GestureHandler'.length;
+export const ACTION_GESTURE_FALLBACK = 'gesture';
+
+/**
+ * Internal interface following RNGH 2 Gesture Event API.
+ * We need to use this to avoid importing RNGH 2 types and depending on it.
+ * https://github.com/software-mansion/react-native-gesture-handler/blob/f0868f7ccf678c947ef65519ebf97ae149a10289/src/handlers/gestures/gesture.ts#L55
+ * @hidden
+ */
+type GestureEvent = Record<string, unknown>;
+
+/**
+ * Internal interface for RNGH 2 Gesture API.
+ * We need to use this to avoid importing RNGH 2 types and depending on it.
+ * https://github.com/software-mansion/react-native-gesture-handler/blob/2.9.0/src/handlers/gestures/gesture.ts#L120
+ * @hidden
+ */
+interface BaseGesture {
+  handlers?: {
+    onBegin?: (event: GestureEvent) => void;
+    onEnd?: (event: GestureEvent) => void;
+  };
+  handlerName: string;
+}
+
+interface GestureTracingOptions {
+  getCurrentHub: () => Hub;
+}
+
+/**
+ * Patches React Native Gesture Handler v2 Gesture to start a transaction on gesture begin with the appropriate label.
+ * Example: ShoppingCartScreen.dismissGesture
+ */
+export function sentryTraceGesture<GestureT>(
+  /**
+   * Label of the gesture to be used in transaction name.
+   * Example: dismissGesture
+   */
+  label: string,
+  gesture: GestureT,
+  options: Partial<GestureTracingOptions> = {},
+): GestureT {
+  const gestureCandidate = gesture as unknown as BaseGesture | undefined | null;
+  if (!gestureCandidate) {
+    logger.warn('[GestureTracing] Gesture can not be undefined');
+    return gesture;
+  }
+  if (!gestureCandidate.handlers) {
+    logger.warn(
+      '[GestureTracing] Can not wrap gesture without handlers. If you want to wrap a gesture composition wrap individual gestures.',
+    );
+    return gesture;
+  }
+  if (!label) {
+    logger.warn('[GestureTracing] Can not wrap gesture without name.');
+    return gesture;
+  }
+  const hub = options.getCurrentHub?.() || getCurrentHub();
+
+  const name =
+    gestureCandidate.handlerName.length > GESTURE_POSTFIX_LENGTH
+      ? gestureCandidate.handlerName
+          .substring(0, gestureCandidate.handlerName.length - GESTURE_POSTFIX_LENGTH)
+          .toLowerCase()
+      : ACTION_GESTURE_FALLBACK;
+
+  const originalOnBegin = gestureCandidate.handlers.onBegin;
+  (gesture as unknown as Required<BaseGesture>).handlers.onBegin = (event: GestureEvent) => {
+    hub
+      .getClient()
+      ?.getIntegration(ReactNativeTracing)
+      ?.startUserInteractionTransaction({ elementId: label, op: `${UI_ACTION}.${name}` });
+
+    addGestureBreadcrumb(`Gesture ${label} begin.`, { event, hub, name });
+
+    if (originalOnBegin) {
+      originalOnBegin(event);
+    }
+  };
+
+  const originalOnEnd = gestureCandidate.handlers.onEnd;
+  (gesture as unknown as Required<BaseGesture>).handlers.onEnd = (event: GestureEvent) => {
+    addGestureBreadcrumb(`Gesture ${label} end.`, { event, hub, name });
+
+    if (originalOnEnd) {
+      originalOnEnd(event);
+    }
+  };
+
+  return gesture;
+}
+
+function addGestureBreadcrumb(
+  message: string,
+  options: {
+    event: Record<string, unknown> | undefined | null;
+    hub: Hub;
+    name: string;
+  },
+): void {
+  const { event, hub, name } = options;
+  const crumb: Breadcrumb = {
+    message,
+    level: 'info',
+    type: DEFAULT_BREADCRUMB_TYPE,
+    category: DEFAULT_BREADCRUMB_CATEGORY,
+  };
+
+  if (event) {
+    const data: Record<string, unknown> = {
+      gesture: name,
+    };
+    for (const key of Object.keys(GestureEventKeys)) {
+      const eventKey = GestureEventKeys[key as keyof typeof GestureEventKeys];
+      if (eventKey in event) {
+        data[eventKey] = event[eventKey];
+      }
+    }
+    crumb.data = data;
+  }
+
+  hub.addBreadcrumb(crumb);
+
+  logger.log(`[GestureTracing] ${crumb.message}`);
+}
+
+/**
+ * Selected keys from RNGH 2 Gesture Event API.
+ * We only want to send relevant data to save on payload size.
+ * @hidden
+ */
+const GestureEventKeys = {
+  NUMBER_OF_POINTERS: 'numberOfPointers',
+  NUMBER_OF_TOUCHES: 'numberOfTouches',
+  FORCE: 'force',
+  FORCE_CHANGE: 'forceChange',
+  ROTATION: 'rotation',
+  ROTATION_CHANGE: 'rotationChange',
+  SCALE: 'scale',
+  SCALE_CHANGE: 'scaleChange',
+  DURATION: 'duration',
+  VELOCITY: 'velocity',
+  VELOCITY_X: 'velocityX',
+  VELOCITY_Y: 'velocityY',
+} as const;
diff --git a/node_modules/@sentry/react-native/src/js/tracing/index.ts b/node_modules/@sentry/react-native/src/js/tracing/index.ts
new file mode 100644
index 0000000..52a659d
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/index.ts
@@ -0,0 +1,20 @@
+export { ReactNativeTracing } from './reactnativetracing';
+
+export type { RoutingInstrumentationInstance } from './routingInstrumentation';
+export { RoutingInstrumentation } from './routingInstrumentation';
+
+export {
+  ReactNavigationInstrumentation,
+  // eslint-disable-next-line deprecation/deprecation
+  ReactNavigationV5Instrumentation,
+} from './reactnavigation';
+export { ReactNavigationV4Instrumentation } from './reactnavigationv4';
+export { ReactNativeNavigationInstrumentation } from './reactnativenavigation';
+
+export type { ReactNavigationCurrentRoute, ReactNavigationRoute, ReactNavigationTransactionContext } from './types';
+
+export { ReactNativeProfiler } from './reactnativeprofiler';
+
+export { sentryTraceGesture } from './gesturetracing';
+
+export * from './ops';
diff --git a/node_modules/@sentry/react-native/src/js/tracing/nativeframes.ts b/node_modules/@sentry/react-native/src/js/tracing/nativeframes.ts
new file mode 100644
index 0000000..fd11407
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/nativeframes.ts
@@ -0,0 +1,253 @@
+import type { Span, Transaction } from '@sentry/core';
+import type { Event, EventProcessor, Measurements, MeasurementUnit } from '@sentry/types';
+import { logger, timestampInSeconds } from '@sentry/utils';
+
+import type { NativeFramesResponse } from '../NativeRNSentry';
+import { NATIVE } from '../wrapper';
+import { instrumentChildSpanFinish } from './utils';
+
+export interface FramesMeasurements extends Measurements {
+  frames_total: { value: number; unit: MeasurementUnit };
+  frames_slow: { value: number; unit: MeasurementUnit };
+  frames_frozen: { value: number; unit: MeasurementUnit };
+}
+
+/**
+ * A margin of error of 50ms is allowed for the async native bridge call.
+ * Anything larger would reduce the accuracy of our frames measurements.
+ */
+const MARGIN_OF_ERROR_SECONDS = 0.05;
+
+/**
+ * Instrumentation to add native slow/frozen frames measurements onto transactions.
+ */
+export class NativeFramesInstrumentation {
+  /** The native frames at the transaction finish time, keyed by traceId. */
+  private _finishFrames: Map<string, { timestamp: number; nativeFrames: NativeFramesResponse | null }> = new Map();
+  /** The listeners for each native frames response, keyed by traceId */
+  private _framesListeners: Map<string, () => void> = new Map();
+  /** The native frames at the finish time of the most recent span. */
+  private _lastSpanFinishFrames?: {
+    timestamp: number;
+    nativeFrames: NativeFramesResponse;
+  };
+
+  public constructor(addGlobalEventProcessor: (e: EventProcessor) => void, doesExist: () => boolean) {
+    logger.log('[ReactNativeTracing] Native frames instrumentation initialized.');
+
+    addGlobalEventProcessor(event => this._processEvent(event, doesExist));
+  }
+
+  /**
+   * To be called when a transaction is started.
+   * Logs the native frames at this start point and instruments child span finishes.
+   */
+  public onTransactionStart(transaction: Transaction): void {
+    void NATIVE.fetchNativeFrames()
+      .then(framesMetrics => {
+        if (framesMetrics) {
+          transaction.setData('__startFrames', framesMetrics);
+        }
+      })
+      .then(undefined, error => {
+        logger.error(`[ReactNativeTracing] Error while fetching native frames: ${error}`);
+      });
+
+    instrumentChildSpanFinish(transaction, (_: Span, endTimestamp?: number) => {
+      if (!endTimestamp) {
+        this._onSpanFinish();
+      }
+    });
+  }
+
+  /**
+   * To be called when a transaction is finished
+   */
+  public onTransactionFinish(transaction: Transaction): void {
+    void this._fetchFramesForTransaction(transaction);
+  }
+
+  /**
+   * Called on a span finish to fetch native frames to support transactions with trimEnd.
+   * Only to be called when a span does not have an end timestamp.
+   */
+  private _onSpanFinish(): void {
+    const timestamp = timestampInSeconds();
+
+    void NATIVE.fetchNativeFrames()
+      .then(nativeFrames => {
+        if (nativeFrames) {
+          this._lastSpanFinishFrames = {
+            timestamp,
+            nativeFrames,
+          };
+        }
+      })
+      .then(undefined, error => {
+        logger.error(`[ReactNativeTracing] Error while fetching native frames: ${error}`);
+      });
+  }
+
+  /**
+   * Returns the computed frames measurements and awaits for them if they are not ready yet.
+   */
+  private async _getFramesMeasurements(
+    traceId: string,
+    finalEndTimestamp: number,
+    startFrames: NativeFramesResponse,
+  ): Promise<FramesMeasurements | null> {
+    if (this._finishFrames.has(traceId)) {
+      return this._prepareMeasurements(traceId, finalEndTimestamp, startFrames);
+    }
+
+    return new Promise(resolve => {
+      const timeout = setTimeout(() => {
+        this._framesListeners.delete(traceId);
+
+        resolve(null);
+      }, 2000);
+
+      this._framesListeners.set(traceId, () => {
+        resolve(this._prepareMeasurements(traceId, finalEndTimestamp, startFrames));
+
+        clearTimeout(timeout);
+        this._framesListeners.delete(traceId);
+      });
+    });
+  }
+
+  /**
+   * Returns the computed frames measurements given ready data
+   */
+  private _prepareMeasurements(
+    traceId: string,
+    finalEndTimestamp: number, // The actual transaction finish time.
+    startFrames: NativeFramesResponse,
+  ): FramesMeasurements | null {
+    let finalFinishFrames: NativeFramesResponse | undefined;
+
+    const finish = this._finishFrames.get(traceId);
+    if (
+      finish &&
+      finish.nativeFrames &&
+      // Must be in the margin of error of the actual transaction finish time (finalEndTimestamp)
+      Math.abs(finish.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS
+    ) {
+      finalFinishFrames = finish.nativeFrames;
+    } else if (
+      this._lastSpanFinishFrames &&
+      Math.abs(this._lastSpanFinishFrames.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS
+    ) {
+      // Fallback to the last span finish if it is within the margin of error of the actual finish timestamp.
+      // This should be the case for trimEnd.
+      finalFinishFrames = this._lastSpanFinishFrames.nativeFrames;
+    } else {
+      return null;
+    }
+
+    const measurements = {
+      frames_total: {
+        value: finalFinishFrames.totalFrames - startFrames.totalFrames,
+        unit: 'none',
+      },
+      frames_frozen: {
+        value: finalFinishFrames.frozenFrames - startFrames.frozenFrames,
+        unit: 'none',
+      },
+      frames_slow: {
+        value: finalFinishFrames.slowFrames - startFrames.slowFrames,
+        unit: 'none',
+      },
+    };
+
+    return measurements;
+  }
+
+  /**
+   * Fetch finish frames for a transaction at the current time. Calls any awaiting listeners.
+   */
+  private async _fetchFramesForTransaction(transaction: Transaction): Promise<void> {
+    const startFrames = transaction.data.__startFrames as NativeFramesResponse | undefined;
+
+    // This timestamp marks when the finish frames were retrieved. It should be pretty close to the transaction finish.
+    const timestamp = timestampInSeconds();
+    let finishFrames: NativeFramesResponse | null = null;
+    if (startFrames) {
+      finishFrames = await NATIVE.fetchNativeFrames();
+    }
+
+    this._finishFrames.set(transaction.traceId, {
+      nativeFrames: finishFrames,
+      timestamp,
+    });
+
+    this._framesListeners.get(transaction.traceId)?.();
+
+    setTimeout(() => this._cancelFinishFrames(transaction), 2000);
+  }
+
+  /**
+   * On a finish frames failure, we cancel the await.
+   */
+  private _cancelFinishFrames(transaction: Transaction): void {
+    if (this._finishFrames.has(transaction.traceId)) {
+      this._finishFrames.delete(transaction.traceId);
+
+      logger.log(
+        `[NativeFrames] Native frames timed out for ${transaction.op} transaction ${transaction.name}. Not adding native frames measurements.`,
+      );
+    }
+  }
+
+  /**
+   * Adds frames measurements to an event. Called from a valid event processor.
+   * Awaits for finish frames if needed.
+   */
+  private async _processEvent(event: Event, doesExist: () => boolean): Promise<Event> {
+    if (!doesExist()) {
+      return event;
+    }
+
+    if (event.type === 'transaction' && event.transaction && event.contexts && event.contexts.trace) {
+      const traceContext = event.contexts.trace as {
+        data?: { [key: string]: unknown };
+        trace_id: string;
+        name?: string;
+        op?: string;
+      };
+
+      const traceId = traceContext.trace_id;
+
+      if (traceId && traceContext.data?.__startFrames && event.timestamp) {
+        const measurements = await this._getFramesMeasurements(
+          traceId,
+          event.timestamp,
+          traceContext.data.__startFrames as NativeFramesResponse,
+        );
+
+        if (!measurements) {
+          logger.log(
+            `[NativeFrames] Could not fetch native frames for ${traceContext.op} transaction ${event.transaction}. Not adding native frames measurements.`,
+          );
+        } else {
+          logger.log(
+            `[Measurements] Adding measurements to ${traceContext.op} transaction ${
+              event.transaction
+            }: ${JSON.stringify(measurements, undefined, 2)}`,
+          );
+
+          event.measurements = {
+            ...(event.measurements ?? {}),
+            ...measurements,
+          };
+
+          this._finishFrames.delete(traceId);
+        }
+
+        delete traceContext.data.__startFrames;
+      }
+    }
+
+    return event;
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/ops.ts b/node_modules/@sentry/react-native/src/js/tracing/ops.ts
new file mode 100644
index 0000000..0f574d8
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/ops.ts
@@ -0,0 +1,9 @@
+export const DEFAULT = 'default';
+export const NAVIGATION = 'navigation';
+
+export const UI_LOAD = 'ui.load';
+export const UI_ACTION = 'ui.action';
+export const UI_ACTION_TOUCH = 'ui.action.touch';
+
+export const APP_START_COLD = 'app.start.cold';
+export const APP_START_WARM = 'app.start.warm';
diff --git a/node_modules/@sentry/react-native/src/js/tracing/reactnativenavigation.ts b/node_modules/@sentry/react-native/src/js/tracing/reactnativenavigation.ts
new file mode 100644
index 0000000..29d83fb
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/reactnativenavigation.ts
@@ -0,0 +1,240 @@
+import type { Transaction as TransactionType, TransactionContext } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import type { EmitterSubscription } from '../utils/rnlibrariesinterface';
+import type { OnConfirmRoute, TransactionCreator } from './routingInstrumentation';
+import { InternalRoutingInstrumentation } from './routingInstrumentation';
+import type { BeforeNavigate, RouteChangeContextData } from './types';
+import { customTransactionSource, defaultTransactionSource, getBlankTransactionContext } from './utils';
+
+interface ReactNativeNavigationOptions {
+  /**
+   * How long the instrumentation will wait for the route to mount after a change has been initiated,
+   * before the transaction is discarded.
+   * Time is in ms.
+   *
+   * Default: 1000
+   */
+  routeChangeTimeoutMs: number;
+  /**
+   * Instrumentation will create a transaction on tab change.
+   * By default only navigation commands create transactions.
+   *
+   * Default: true
+   */
+  enableTabsInstrumentation: boolean;
+}
+
+const defaultOptions: ReactNativeNavigationOptions = {
+  routeChangeTimeoutMs: 1000,
+  enableTabsInstrumentation: true,
+};
+
+interface ComponentEvent {
+  componentId: string;
+}
+
+type ComponentType = 'Component' | 'TopBarTitle' | 'TopBarBackground' | 'TopBarButton';
+
+export interface ComponentWillAppearEvent extends ComponentEvent {
+  componentName: string;
+  passProps?: Record<string | number | symbol, unknown>;
+  componentType: ComponentType;
+}
+
+export interface EventSubscription {
+  remove(): void;
+}
+
+export interface BottomTabPressedEvent {
+  tabIndex: number;
+}
+
+export interface EventsRegistry {
+  registerComponentWillAppearListener(callback: (event: ComponentWillAppearEvent) => void): EmitterSubscription;
+  registerCommandListener(callback: (name: string, params: unknown) => void): EventSubscription;
+  registerBottomTabPressedListener(callback: (event: BottomTabPressedEvent) => void): EmitterSubscription;
+}
+
+export interface NavigationDelegate {
+  events: () => EventsRegistry;
+}
+
+/**
+ * Instrumentation for React Native Navigation. See docs or sample app for usage.
+ *
+ * How this works:
+ * - `_onCommand` is called every time a commands happens and sets an IdleTransaction on the scope without any route context.
+ * - `_onComponentWillAppear` is then called AFTER the state change happens due to a dispatch and sets the route context onto the active transaction.
+ * - If `_onComponentWillAppear` isn't called within `options.routeChangeTimeoutMs` of the dispatch, then the transaction is not sampled and finished.
+ */
+export class ReactNativeNavigationInstrumentation extends InternalRoutingInstrumentation {
+  public static instrumentationName: string = 'react-native-navigation';
+
+  public readonly name: string = ReactNativeNavigationInstrumentation.instrumentationName;
+
+  private _navigation: NavigationDelegate;
+  private _options: ReactNativeNavigationOptions;
+
+  private _prevComponentEvent: ComponentWillAppearEvent | null = null;
+
+  private _latestTransaction?: TransactionType;
+  private _recentComponentIds: string[] = [];
+  private _stateChangeTimeout?: number | undefined;
+
+  public constructor(
+    /** The react native navigation `NavigationDelegate`. This is usually the import named `Navigation`. */
+    navigation: unknown,
+    options: Partial<ReactNativeNavigationOptions> = {},
+  ) {
+    super();
+
+    this._navigation = navigation as NavigationDelegate;
+
+    this._options = {
+      ...defaultOptions,
+      ...options,
+    };
+  }
+
+  /**
+   * Registers the event listeners for React Native Navigation
+   */
+  public registerRoutingInstrumentation(
+    listener: TransactionCreator,
+    beforeNavigate: BeforeNavigate,
+    onConfirmRoute: OnConfirmRoute,
+  ): void {
+    super.registerRoutingInstrumentation(listener, beforeNavigate, onConfirmRoute);
+
+    this._navigation.events().registerCommandListener(this._onNavigation.bind(this));
+
+    if (this._options.enableTabsInstrumentation) {
+      this._navigation.events().registerBottomTabPressedListener(this._onNavigation.bind(this));
+    }
+
+    this._navigation.events().registerComponentWillAppearListener(this._onComponentWillAppear.bind(this));
+  }
+
+  /**
+   * To be called when a navigation is initiated. (Command, BottomTabSelected, etc.)
+   */
+  private _onNavigation(): void {
+    if (this._latestTransaction) {
+      this._discardLatestTransaction();
+    }
+
+    this._latestTransaction = this.onRouteWillChange(
+      getBlankTransactionContext(ReactNativeNavigationInstrumentation.name),
+    );
+
+    this._stateChangeTimeout = setTimeout(
+      this._discardLatestTransaction.bind(this),
+      this._options.routeChangeTimeoutMs,
+    );
+  }
+
+  /**
+   * To be called AFTER the state has been changed to populate the transaction with the current route.
+   */
+  private _onComponentWillAppear(event: ComponentWillAppearEvent): void {
+    if (!this._latestTransaction) {
+      return;
+    }
+
+    // We ignore actions that pertain to the same screen.
+    const isSameComponent = this._prevComponentEvent && event.componentId === this._prevComponentEvent.componentId;
+    if (isSameComponent) {
+      this._discardLatestTransaction();
+      return;
+    }
+
+    this._clearStateChangeTimeout();
+
+    const originalContext = this._latestTransaction.toContext();
+    const routeHasBeenSeen = this._recentComponentIds.includes(event.componentId);
+
+    const data: RouteChangeContextData = {
+      ...originalContext.data,
+      route: {
+        ...event,
+        name: event.componentName,
+        hasBeenSeen: routeHasBeenSeen,
+      },
+      previousRoute: this._prevComponentEvent
+        ? {
+            ...this._prevComponentEvent,
+            name: this._prevComponentEvent?.componentName,
+          }
+        : null,
+    };
+
+    const updatedContext = {
+      ...originalContext,
+      name: event.componentName,
+      tags: {
+        ...originalContext.tags,
+        'routing.route.name': event.componentName,
+      },
+      data,
+    };
+
+    const finalContext = this._prepareFinalContext(updatedContext);
+    this._latestTransaction.updateWithContext(finalContext);
+
+    const isCustomName = updatedContext.name !== finalContext.name;
+    this._latestTransaction.setName(
+      finalContext.name,
+      isCustomName ? customTransactionSource : defaultTransactionSource,
+    );
+
+    this._onConfirmRoute?.(finalContext);
+    this._prevComponentEvent = event;
+
+    this._latestTransaction = undefined;
+  }
+
+  /** Creates final transaction context before confirmation */
+  private _prepareFinalContext(updatedContext: TransactionContext): TransactionContext {
+    let finalContext = this._beforeNavigate?.({ ...updatedContext });
+
+    // This block is to catch users not returning a transaction context
+    if (!finalContext) {
+      logger.error(
+        `[${ReactNativeNavigationInstrumentation.name}] beforeNavigate returned ${finalContext}, return context.sampled = false to not send transaction.`,
+      );
+
+      finalContext = {
+        ...updatedContext,
+        sampled: false,
+      };
+    }
+
+    if (finalContext.sampled === false) {
+      logger.log(
+        `[${ReactNativeNavigationInstrumentation.name}] Will not send transaction "${finalContext.name}" due to beforeNavigate.`,
+      );
+    }
+
+    return finalContext;
+  }
+
+  /** Cancels the latest transaction so it does not get sent to Sentry. */
+  private _discardLatestTransaction(): void {
+    if (this._latestTransaction) {
+      this._latestTransaction.sampled = false;
+      this._latestTransaction.finish();
+      this._latestTransaction = undefined;
+    }
+
+    this._clearStateChangeTimeout();
+  }
+
+  /** Cancels the latest transaction so it does not get sent to Sentry. */
+  private _clearStateChangeTimeout(): void {
+    if (typeof this._stateChangeTimeout !== 'undefined') {
+      clearTimeout(this._stateChangeTimeout);
+      this._stateChangeTimeout = undefined;
+    }
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/reactnativeprofiler.tsx b/node_modules/@sentry/react-native/src/js/tracing/reactnativeprofiler.tsx
new file mode 100644
index 0000000..93f3830
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/reactnativeprofiler.tsx
@@ -0,0 +1,36 @@
+import { getCurrentHub, Profiler } from '@sentry/react';
+
+import { createIntegration } from '../integrations/factory';
+import { ReactNativeTracing } from './reactnativetracing';
+
+/**
+ * Custom profiler for the React Native app root.
+ */
+export class ReactNativeProfiler extends Profiler {
+  public readonly name: string = 'ReactNativeProfiler';
+
+  /**
+   * Get the app root mount time.
+   */
+  public componentDidMount(): void {
+    super.componentDidMount();
+    const hub = getCurrentHub();
+    const client = hub.getClient();
+
+    if (!client) {
+      // We can't use logger here because this will be logged before the `Sentry.init`.
+      // eslint-disable-next-line no-console
+      __DEV__ && console.warn('App Start Span could not be finished. `Sentry.wrap` was called before `Sentry.init`.');
+      return;
+    }
+
+    client.addIntegration && client.addIntegration(createIntegration(this.name));
+
+    const tracingIntegration = hub.getIntegration(ReactNativeTracing);
+    tracingIntegration
+      && this._mountSpan
+      && typeof this._mountSpan.endTimestamp !== 'undefined'
+      // The first root component mount is the app start finish.
+      && tracingIntegration.onAppStartFinish(this._mountSpan.endTimestamp);
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/reactnativetracing.ts b/node_modules/@sentry/react-native/src/js/tracing/reactnativetracing.ts
new file mode 100644
index 0000000..85dedf3
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/reactnativetracing.ts
@@ -0,0 +1,561 @@
+/* eslint-disable max-lines */
+import type { RequestInstrumentationOptions } from '@sentry/browser';
+import { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from '@sentry/browser';
+import type { Hub, IdleTransaction, Transaction } from '@sentry/core';
+import { getActiveTransaction, getCurrentHub, startIdleTransaction } from '@sentry/core';
+import type {
+  Event,
+  EventProcessor,
+  Integration,
+  Transaction as TransactionType,
+  TransactionContext,
+} from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { APP_START_COLD, APP_START_WARM } from '../measurements';
+import type { NativeAppStartResponse } from '../NativeRNSentry';
+import type { RoutingInstrumentationInstance } from '../tracing/routingInstrumentation';
+import { NATIVE } from '../wrapper';
+import { NativeFramesInstrumentation } from './nativeframes';
+import { APP_START_COLD as APP_START_COLD_OP, APP_START_WARM as APP_START_WARM_OP, UI_LOAD } from './ops';
+import { StallTrackingInstrumentation } from './stalltracking';
+import { cancelInBackground, onlySampleIfChildSpans } from './transaction';
+import type { BeforeNavigate, RouteChangeContextData } from './types';
+import { adjustTransactionDuration, getTimeOriginMilliseconds, isNearToNow } from './utils';
+
+export interface ReactNativeTracingOptions extends RequestInstrumentationOptions {
+  /**
+   * @deprecated Replaced by idleTimeoutMs
+   */
+  idleTimeout: number;
+
+  /**
+   * @deprecated Replaced by maxTransactionDurationMs
+   */
+  maxTransactionDuration: number;
+
+  /**
+   * The time to wait in ms until the transaction will be finished. The transaction will use the end timestamp of
+   * the last finished span as the endtime for the transaction.
+   * Time is in ms.
+   *
+   * Default: 1000
+   */
+  idleTimeoutMs: number;
+
+  /**
+   * The maximum duration (transaction duration + idle timeout) of a transaction
+   * before it will be marked as "deadline_exceeded".
+   * If you never want to mark a transaction set it to 0.
+   * Time is in ms.
+   *
+   * Default: 600000
+   */
+  finalTimeoutMs: number;
+
+  /**
+   * The routing instrumentation to be used with the tracing integration.
+   * There is no routing instrumentation if nothing is passed.
+   */
+  routingInstrumentation?: RoutingInstrumentationInstance;
+
+  /**
+   * Does not sample transactions that are from routes that have been seen any more and don't have any spans.
+   * This removes a lot of the clutter as most back navigation transactions are now ignored.
+   *
+   * Default: true
+   */
+  ignoreEmptyBackNavigationTransactions: boolean;
+
+  /**
+   * beforeNavigate is called before a navigation transaction is created and allows users to modify transaction
+   * context data, or drop the transaction entirely (by setting `sampled = false` in the context).
+   *
+   * @param context: The context data which will be passed to `startTransaction` by default
+   *
+   * @returns A (potentially) modified context object, with `sampled = false` if the transaction should be dropped.
+   */
+  beforeNavigate: BeforeNavigate;
+
+  /**
+   * Track the app start time by adding measurements to the first route transaction. If there is no routing instrumentation
+   * an app start transaction will be started.
+   *
+   * Default: true
+   */
+  enableAppStartTracking: boolean;
+
+  /**
+   * Track slow/frozen frames from the native layer and adds them as measurements to all transactions.
+   */
+  enableNativeFramesTracking: boolean;
+
+  /**
+   * Track when and how long the JS event loop stalls for. Adds stalls as measurements to all transactions.
+   */
+  enableStallTracking: boolean;
+
+  /**
+   * Trace User Interaction events like touch and gestures.
+   */
+  enableUserInteractionTracing: boolean;
+}
+
+const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\/(?!\/)/];
+
+const defaultReactNativeTracingOptions: ReactNativeTracingOptions = {
+  ...defaultRequestInstrumentationOptions,
+  idleTimeout: 1000,
+  maxTransactionDuration: 600,
+  idleTimeoutMs: 1000,
+  finalTimeoutMs: 600000,
+  ignoreEmptyBackNavigationTransactions: true,
+  beforeNavigate: context => context,
+  enableAppStartTracking: true,
+  enableNativeFramesTracking: true,
+  enableStallTracking: true,
+  enableUserInteractionTracing: false,
+};
+
+/**
+ * Tracing integration for React Native.
+ */
+export class ReactNativeTracing implements Integration {
+  /**
+   * @inheritDoc
+   */
+  public static id: string = 'ReactNativeTracing';
+  /** We filter out App starts more than 60s */
+  private static _maxAppStart: number = 60000;
+  /**
+   * @inheritDoc
+   */
+  public name: string = ReactNativeTracing.id;
+
+  /** ReactNativeTracing options */
+  public options: ReactNativeTracingOptions;
+
+  public nativeFramesInstrumentation?: NativeFramesInstrumentation;
+  public stallTrackingInstrumentation?: StallTrackingInstrumentation;
+  public useAppStartWithProfiler: boolean = false;
+
+  private _inflightInteractionTransaction?: IdleTransaction;
+  private _getCurrentHub?: () => Hub;
+  private _awaitingAppStartData?: NativeAppStartResponse;
+  private _appStartFinishTimestamp?: number;
+  private _currentRoute?: string;
+  private _hasSetTracePropagationTargets: boolean;
+  private _hasSetTracingOrigins: boolean;
+  private _currentViewName: string | undefined;
+
+  public constructor(options: Partial<ReactNativeTracingOptions> = {}) {
+    this._hasSetTracePropagationTargets = !!(
+      options &&
+      // eslint-disable-next-line deprecation/deprecation
+      options.tracePropagationTargets
+    );
+    this._hasSetTracingOrigins = !!(
+      options &&
+      // eslint-disable-next-line deprecation/deprecation
+      options.tracingOrigins
+    );
+
+    this.options = {
+      ...defaultReactNativeTracingOptions,
+      ...options,
+      finalTimeoutMs:
+        options.finalTimeoutMs ??
+        // eslint-disable-next-line deprecation/deprecation
+        (typeof options.maxTransactionDuration === 'number'
+          ? // eslint-disable-next-line deprecation/deprecation
+            options.maxTransactionDuration * 1000
+          : undefined) ??
+        defaultReactNativeTracingOptions.finalTimeoutMs,
+      idleTimeoutMs:
+        options.idleTimeoutMs ??
+        // eslint-disable-next-line deprecation/deprecation
+        options.idleTimeout ??
+        defaultReactNativeTracingOptions.idleTimeoutMs,
+    };
+  }
+
+  /**
+   *  Registers routing and request instrumentation.
+   */
+  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {
+    const hub = getCurrentHub();
+    const client = hub.getClient();
+    const clientOptions = client && client.getOptions();
+
+    // eslint-disable-next-line @typescript-eslint/unbound-method
+    const {
+      traceFetch,
+      traceXHR,
+      // eslint-disable-next-line deprecation/deprecation
+      tracingOrigins,
+      shouldCreateSpanForRequest,
+      // eslint-disable-next-line deprecation/deprecation
+      tracePropagationTargets: thisOptionsTracePropagationTargets,
+      routingInstrumentation,
+      enableAppStartTracking,
+      enableNativeFramesTracking,
+      enableStallTracking,
+    } = this.options;
+
+    this._getCurrentHub = getCurrentHub;
+
+    const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
+    // There are three ways to configure tracePropagationTargets:
+    // 1. via top level client option `tracePropagationTargets`
+    // 2. via ReactNativeTracing option `tracePropagationTargets`
+    // 3. via ReactNativeTracing option `tracingOrigins` (deprecated)
+    //
+    // To avoid confusion, favour top level client option `tracePropagationTargets`, and fallback to
+    // ReactNativeTracing option `tracePropagationTargets` and then `tracingOrigins` (deprecated).
+    //
+    // If both 1 and either one of 2 or 3 are set (from above), we log out a warning.
+    const tracePropagationTargets =
+      clientOptionsTracePropagationTargets ||
+      (this._hasSetTracePropagationTargets && thisOptionsTracePropagationTargets) ||
+      (this._hasSetTracingOrigins && tracingOrigins) ||
+      DEFAULT_TRACE_PROPAGATION_TARGETS;
+    if (
+      __DEV__ &&
+      (this._hasSetTracePropagationTargets || this._hasSetTracingOrigins) &&
+      clientOptionsTracePropagationTargets
+    ) {
+      logger.warn(
+        '[ReactNativeTracing] The `tracePropagationTargets` option was set in the ReactNativeTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.',
+      );
+    }
+
+    if (enableAppStartTracking) {
+      void this._instrumentAppStart();
+    }
+
+    if (enableNativeFramesTracking) {
+      NATIVE.enableNativeFramesTracking();
+      this.nativeFramesInstrumentation = new NativeFramesInstrumentation(addGlobalEventProcessor, () => {
+        const self = getCurrentHub().getIntegration(ReactNativeTracing);
+
+        if (self) {
+          return !!self.nativeFramesInstrumentation;
+        }
+
+        return false;
+      });
+    } else {
+      NATIVE.disableNativeFramesTracking();
+    }
+
+    if (enableStallTracking) {
+      this.stallTrackingInstrumentation = new StallTrackingInstrumentation();
+    }
+
+    if (routingInstrumentation) {
+      routingInstrumentation.registerRoutingInstrumentation(
+        this._onRouteWillChange.bind(this),
+        this.options.beforeNavigate,
+        this._onConfirmRoute.bind(this),
+      );
+    } else {
+      logger.log('[ReactNativeTracing] Not instrumenting route changes as routingInstrumentation has not been set.');
+    }
+
+    addGlobalEventProcessor(this._getCurrentViewEventProcessor.bind(this));
+
+    instrumentOutgoingRequests({
+      traceFetch,
+      traceXHR,
+      shouldCreateSpanForRequest,
+      tracePropagationTargets,
+    });
+  }
+
+  /**
+   * To be called on a transaction start. Can have async methods
+   */
+  public onTransactionStart(transaction: Transaction): void {
+    if (isNearToNow(transaction.startTimestamp)) {
+      // Only if this method is called at or within margin of error to the start timestamp.
+      this.nativeFramesInstrumentation?.onTransactionStart(transaction);
+      this.stallTrackingInstrumentation?.onTransactionStart(transaction);
+    }
+  }
+
+  /**
+   * To be called on a transaction finish. Cannot have async methods.
+   */
+  public onTransactionFinish(transaction: Transaction, endTimestamp?: number): void {
+    this.nativeFramesInstrumentation?.onTransactionFinish(transaction);
+    this.stallTrackingInstrumentation?.onTransactionFinish(transaction, endTimestamp);
+  }
+
+  /**
+   * Called by the ReactNativeProfiler component on first component mount.
+   */
+  public onAppStartFinish(endTimestamp: number): void {
+    this._appStartFinishTimestamp = endTimestamp;
+  }
+
+  /**
+   * Starts a new transaction for a user interaction.
+   * @param userInteractionId Consists of `op` representation UI Event and `elementId` unique element identifier on current screen.
+   */
+  public startUserInteractionTransaction(userInteractionId: {
+    elementId: string | undefined;
+    op: string;
+  }): TransactionType | undefined {
+    const { elementId, op } = userInteractionId;
+    if (!this.options.enableUserInteractionTracing) {
+      logger.log('[ReactNativeTracing] User Interaction Tracing is disabled.');
+      return;
+    }
+    if (!this.options.routingInstrumentation) {
+      logger.error(
+        '[ReactNativeTracing] User Interaction Tracing is not working because no routing instrumentation is set.',
+      );
+      return;
+    }
+    if (!elementId) {
+      logger.log('[ReactNativeTracing] User Interaction Tracing can not create transaction with undefined elementId.');
+      return;
+    }
+    if (!this._currentRoute) {
+      logger.log('[ReactNativeTracing] User Interaction Tracing can not create transaction without a current route.');
+      return;
+    }
+
+    const hub = this._getCurrentHub?.() || getCurrentHub();
+    const activeTransaction = getActiveTransaction(hub);
+    const activeTransactionIsNotInteraction =
+      activeTransaction?.spanId !== this._inflightInteractionTransaction?.spanId;
+    if (activeTransaction && activeTransactionIsNotInteraction) {
+      logger.warn(
+        `[ReactNativeTracing] Did not create ${op} transaction because active transaction ${activeTransaction.name} exists on the scope.`,
+      );
+      return;
+    }
+
+    if (this._inflightInteractionTransaction) {
+      this._inflightInteractionTransaction.cancelIdleTimeout(undefined, { restartOnChildSpanChange: false });
+      this._inflightInteractionTransaction = undefined;
+    }
+
+    const name = `${this._currentRoute}.${elementId}`;
+    const context: TransactionContext = {
+      name,
+      op,
+      trimEnd: true,
+    };
+    this._inflightInteractionTransaction = this._startIdleTransaction(context);
+    this._inflightInteractionTransaction.registerBeforeFinishCallback((transaction: IdleTransaction) => {
+      this._inflightInteractionTransaction = undefined;
+      this.onTransactionFinish(transaction);
+    });
+    this._inflightInteractionTransaction.registerBeforeFinishCallback(onlySampleIfChildSpans);
+    this.onTransactionStart(this._inflightInteractionTransaction);
+    logger.log(`[ReactNativeTracing] User Interaction Tracing Created ${op} transaction ${name}.`);
+    return this._inflightInteractionTransaction;
+  }
+
+  /**
+   *  Sets the current view name into the app context.
+   *  @param event Le event.
+   */
+  private _getCurrentViewEventProcessor(event: Event): Event {
+    if (event.contexts && this._currentViewName) {
+      event.contexts.app = { view_names: [this._currentViewName], ...event.contexts.app };
+    }
+    return event;
+  }
+
+  /**
+   * Returns the App Start Duration in Milliseconds. Also returns undefined if not able do
+   * define the duration.
+   */
+  private _getAppStartDurationMilliseconds(appStart: NativeAppStartResponse): number | undefined {
+    if (!this._appStartFinishTimestamp) {
+      return undefined;
+    }
+    return this._appStartFinishTimestamp * 1000 - appStart.appStartTime;
+  }
+
+  /**
+   * Instruments the app start measurements on the first route transaction.
+   * Starts a route transaction if there isn't routing instrumentation.
+   */
+  private async _instrumentAppStart(): Promise<void> {
+    if (!this.options.enableAppStartTracking || !NATIVE.enableNative) {
+      return;
+    }
+
+    const appStart = await NATIVE.fetchNativeAppStart();
+
+    if (!appStart || appStart.didFetchAppStart) {
+      return;
+    }
+
+    if (!this.useAppStartWithProfiler) {
+      this._appStartFinishTimestamp = getTimeOriginMilliseconds() / 1000;
+    }
+
+    if (this.options.routingInstrumentation) {
+      this._awaitingAppStartData = appStart;
+    } else {
+      const idleTransaction = this._createRouteTransaction({
+        name: 'App Start',
+        op: UI_LOAD,
+      });
+
+      if (idleTransaction) {
+        this._addAppStartData(idleTransaction, appStart);
+      }
+    }
+  }
+
+  /**
+   * Adds app start measurements and starts a child span on a transaction.
+   */
+  private _addAppStartData(transaction: IdleTransaction, appStart: NativeAppStartResponse): void {
+    const appStartDurationMilliseconds = this._getAppStartDurationMilliseconds(appStart);
+    if (!appStartDurationMilliseconds) {
+      logger.warn('App start was never finished.');
+      return;
+    }
+
+    // we filter out app start more than 60s.
+    // this could be due to many different reasons.
+    // we've seen app starts with hours, days and even months.
+    if (appStartDurationMilliseconds >= ReactNativeTracing._maxAppStart) {
+      return;
+    }
+
+    const appStartTimeSeconds = appStart.appStartTime / 1000;
+
+    transaction.startTimestamp = appStartTimeSeconds;
+
+    const op = appStart.isColdStart ? APP_START_COLD_OP : APP_START_WARM_OP;
+    transaction.startChild({
+      description: appStart.isColdStart ? 'Cold App Start' : 'Warm App Start',
+      op,
+      startTimestamp: appStartTimeSeconds,
+      endTimestamp: this._appStartFinishTimestamp,
+    });
+
+    const measurement = appStart.isColdStart ? APP_START_COLD : APP_START_WARM;
+    transaction.setMeasurement(measurement, appStartDurationMilliseconds, 'millisecond');
+  }
+
+  /** To be called when the route changes, but BEFORE the components of the new route mount. */
+  private _onRouteWillChange(context: TransactionContext): TransactionType | undefined {
+    return this._createRouteTransaction(context);
+  }
+
+  /**
+   * Creates a breadcrumb and sets the current route as a tag.
+   */
+  private _onConfirmRoute(context: TransactionContext): void {
+    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+    this._currentRoute = context.data?.route?.name;
+
+    this._getCurrentHub?.().configureScope(scope => {
+      if (context.data) {
+        const contextData = context.data as RouteChangeContextData;
+
+        scope.addBreadcrumb({
+          category: 'navigation',
+          type: 'navigation',
+          // We assume that context.name is the name of the route.
+          message: `Navigation to ${context.name}`,
+          data: {
+            from: contextData.previousRoute?.name,
+            to: contextData.route.name,
+          },
+        });
+      }
+
+      this._currentViewName = context.name;
+      /**
+       * @deprecated tag routing.route.name will be removed in the future.
+       */
+      scope.setTag('routing.route.name', context.name);
+    });
+  }
+
+  /** Create routing idle transaction. */
+  private _createRouteTransaction(context: TransactionContext): IdleTransaction | undefined {
+    if (!this._getCurrentHub) {
+      logger.warn(`[ReactNativeTracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);
+      return undefined;
+    }
+
+    if (this._inflightInteractionTransaction) {
+      logger.log(
+        `[ReactNativeTracing] Canceling ${this._inflightInteractionTransaction.op} transaction because navigation ${context.op}.`,
+      );
+      this._inflightInteractionTransaction.setStatus('cancelled');
+      this._inflightInteractionTransaction.finish();
+    }
+
+    const { finalTimeoutMs } = this.options;
+
+    const expandedContext = {
+      ...context,
+      trimEnd: true,
+    };
+
+    const idleTransaction = this._startIdleTransaction(expandedContext);
+
+    this.onTransactionStart(idleTransaction);
+
+    logger.log(`[ReactNativeTracing] Starting ${context.op} transaction "${context.name}" on scope`);
+
+    idleTransaction.registerBeforeFinishCallback((transaction, endTimestamp) => {
+      this.onTransactionFinish(transaction, endTimestamp);
+    });
+
+    idleTransaction.registerBeforeFinishCallback(transaction => {
+      if (this.options.enableAppStartTracking && this._awaitingAppStartData) {
+        transaction.op = UI_LOAD;
+        this._addAppStartData(transaction, this._awaitingAppStartData);
+
+        this._awaitingAppStartData = undefined;
+      }
+    });
+
+    idleTransaction.registerBeforeFinishCallback((transaction, endTimestamp) => {
+      adjustTransactionDuration(finalTimeoutMs, transaction, endTimestamp);
+    });
+
+    if (this.options.ignoreEmptyBackNavigationTransactions) {
+      idleTransaction.registerBeforeFinishCallback(transaction => {
+        if (
+          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+          transaction.data?.route?.hasBeenSeen &&
+          (!transaction.spanRecorder ||
+            transaction.spanRecorder.spans.filter(span => span.spanId !== transaction.spanId).length === 0)
+        ) {
+          logger.log(
+            '[ReactNativeTracing] Not sampling transaction as route has been seen before. Pass ignoreEmptyBackNavigationTransactions = false to disable this feature.',
+          );
+          // Route has been seen before and has no child spans.
+          transaction.sampled = false;
+        }
+      });
+    }
+
+    return idleTransaction;
+  }
+
+  /**
+   * Start app state aware idle transaction on the scope.
+   */
+  private _startIdleTransaction(context: TransactionContext): IdleTransaction {
+    const { idleTimeoutMs, finalTimeoutMs } = this.options;
+    const hub = this._getCurrentHub?.() || getCurrentHub();
+    const tx = startIdleTransaction(hub, context, idleTimeoutMs, finalTimeoutMs, true);
+    cancelInBackground(tx);
+    return tx;
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/reactnavigation.ts b/node_modules/@sentry/react-native/src/js/tracing/reactnavigation.ts
new file mode 100644
index 0000000..54ad946
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/reactnavigation.ts
@@ -0,0 +1,313 @@
+/* eslint-disable max-lines */
+import type { Transaction as TransactionType, TransactionContext } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { RN_GLOBAL_OBJ } from '../utils/worldwide';
+import type { OnConfirmRoute, TransactionCreator } from './routingInstrumentation';
+import { InternalRoutingInstrumentation } from './routingInstrumentation';
+import type { BeforeNavigate, ReactNavigationTransactionContext, RouteChangeContextData } from './types';
+import { customTransactionSource, defaultTransactionSource, getBlankTransactionContext } from './utils';
+
+export interface NavigationRoute {
+  name: string;
+  key: string;
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  params?: Record<string, any>;
+}
+
+interface NavigationContainer {
+  addListener: (type: string, listener: () => void) => void;
+  getCurrentRoute: () => NavigationRoute;
+}
+
+interface ReactNavigationOptions {
+  /**
+   * How long the instrumentation will wait for the route to mount after a change has been initiated,
+   * before the transaction is discarded.
+   * Time is in ms.
+   *
+   * Default: 1000
+   */
+  routeChangeTimeoutMs: number;
+}
+
+const defaultOptions: ReactNavigationOptions = {
+  routeChangeTimeoutMs: 1000,
+};
+
+/**
+ * Instrumentation for React-Navigation V5 and above. See docs or sample app for usage.
+ *
+ * How this works:
+ * - `_onDispatch` is called every time a dispatch happens and sets an IdleTransaction on the scope without any route context.
+ * - `_onStateChange` is then called AFTER the state change happens due to a dispatch and sets the route context onto the active transaction.
+ * - If `_onStateChange` isn't called within `STATE_CHANGE_TIMEOUT_DURATION` of the dispatch, then the transaction is not sampled and finished.
+ */
+export class ReactNavigationInstrumentation extends InternalRoutingInstrumentation {
+  public static instrumentationName: string = 'react-navigation-v5';
+
+  public readonly name: string = ReactNavigationInstrumentation.instrumentationName;
+
+  private _navigationContainer: NavigationContainer | null = null;
+
+  private readonly _maxRecentRouteLen: number = 200;
+
+  private _latestRoute?: NavigationRoute;
+  private _latestTransaction?: TransactionType;
+  private _initialStateHandled: boolean = false;
+  private _stateChangeTimeout?: number | undefined;
+  private _recentRouteKeys: string[] = [];
+
+  private _options: ReactNavigationOptions;
+
+  public constructor(options: Partial<ReactNavigationOptions> = {}) {
+    super();
+
+    this._options = {
+      ...defaultOptions,
+      ...options,
+    };
+  }
+
+  /**
+   * Extends by calling _handleInitialState at the end.
+   */
+  public registerRoutingInstrumentation(
+    listener: TransactionCreator,
+    beforeNavigate: BeforeNavigate,
+    onConfirmRoute: OnConfirmRoute,
+  ): void {
+    super.registerRoutingInstrumentation(listener, beforeNavigate, onConfirmRoute);
+
+    // We create an initial state here to ensure a transaction gets created before the first route mounts.
+    if (!this._initialStateHandled) {
+      this._onDispatch();
+      if (this._navigationContainer) {
+        // Navigation container already registered, just populate with route state
+        this._onStateChange();
+
+        this._initialStateHandled = true;
+      }
+    }
+  }
+
+  /**
+   * Pass the ref to the navigation container to register it to the instrumentation
+   * @param navigationContainerRef Ref to a `NavigationContainer`
+   */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
+  public registerNavigationContainer(navigationContainerRef: any): void {
+    /* We prevent duplicate routing instrumentation to be initialized on fast refreshes
+
+      Explanation: If the user triggers a fast refresh on the file that the instrumentation is
+      initialized in, it will initialize a new instance and will cause undefined behavior.
+     */
+    if (!RN_GLOBAL_OBJ.__sentry_rn_v5_registered) {
+      if ('current' in navigationContainerRef) {
+        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+        this._navigationContainer = navigationContainerRef.current;
+      } else {
+        this._navigationContainer = navigationContainerRef;
+      }
+
+      if (this._navigationContainer) {
+        this._navigationContainer.addListener(
+          '__unsafe_action__', // This action is emitted on every dispatch
+          this._onDispatch.bind(this),
+        );
+        this._navigationContainer.addListener(
+          'state', // This action is emitted on every state change
+          this._onStateChange.bind(this),
+        );
+
+        if (!this._initialStateHandled) {
+          if (this._latestTransaction) {
+            // If registerRoutingInstrumentation was called first _onDispatch has already been called
+            this._onStateChange();
+
+            this._initialStateHandled = true;
+          } else {
+            logger.log(
+              '[ReactNavigationInstrumentation] Navigation container registered, but integration has not been setup yet.',
+            );
+          }
+        }
+
+        RN_GLOBAL_OBJ.__sentry_rn_v5_registered = true;
+      } else {
+        logger.warn('[ReactNavigationInstrumentation] Received invalid navigation container ref!');
+      }
+    } else {
+      logger.log(
+        '[ReactNavigationInstrumentation] Instrumentation already exists, but register has been called again, doing nothing.',
+      );
+    }
+  }
+
+  /**
+   * To be called on every React-Navigation action dispatch.
+   * It does not name the transaction or populate it with route information. Instead, it waits for the state to fully change
+   * and gets the route information from there, @see _onStateChange
+   */
+  private _onDispatch(): void {
+    if (this._latestTransaction) {
+      logger.log(
+        '[ReactNavigationInstrumentation] A transaction was detected that turned out to be a noop, discarding.',
+      );
+      this._discardLatestTransaction();
+      this._clearStateChangeTimeout();
+    }
+
+    this._latestTransaction = this.onRouteWillChange(
+      getBlankTransactionContext(ReactNavigationInstrumentation.instrumentationName),
+    );
+
+    this._stateChangeTimeout = setTimeout(
+      this._discardLatestTransaction.bind(this),
+      this._options.routeChangeTimeoutMs,
+    );
+  }
+
+  /**
+   * To be called AFTER the state has been changed to populate the transaction with the current route.
+   */
+  private _onStateChange(): void {
+    // Use the getCurrentRoute method to be accurate.
+    const previousRoute = this._latestRoute;
+
+    if (!this._navigationContainer) {
+      logger.warn(
+        '[ReactNavigationInstrumentation] Missing navigation container ref. Route transactions will not be sent.',
+      );
+
+      return;
+    }
+
+    const route = this._navigationContainer.getCurrentRoute();
+
+    if (route) {
+      if (this._latestTransaction) {
+        if (!previousRoute || previousRoute.key !== route.key) {
+          const originalContext = this._latestTransaction.toContext() as typeof BLANK_TRANSACTION_CONTEXT;
+          const routeHasBeenSeen = this._recentRouteKeys.includes(route.key);
+
+          const data: RouteChangeContextData = {
+            ...originalContext.data,
+            route: {
+              name: route.name,
+              key: route.key,
+              params: route.params ?? {},
+              hasBeenSeen: routeHasBeenSeen,
+            },
+            previousRoute: previousRoute
+              ? {
+                  name: previousRoute.name,
+                  key: previousRoute.key,
+                  params: previousRoute.params ?? {},
+                }
+              : null,
+          };
+
+          const updatedContext: ReactNavigationTransactionContext = {
+            ...originalContext,
+            name: route.name,
+            tags: {
+              ...originalContext.tags,
+              'routing.route.name': route.name,
+            },
+            data,
+          };
+
+          const finalContext = this._prepareFinalContext(updatedContext);
+          this._latestTransaction.updateWithContext(finalContext);
+
+          const isCustomName = updatedContext.name !== finalContext.name;
+          this._latestTransaction.setName(
+            finalContext.name,
+            isCustomName ? customTransactionSource : defaultTransactionSource,
+          );
+
+          this._onConfirmRoute?.(finalContext);
+        }
+
+        this._pushRecentRouteKey(route.key);
+        this._latestRoute = route;
+
+        // Clear the latest transaction as it has been handled.
+        this._latestTransaction = undefined;
+      }
+    }
+  }
+
+  /** Creates final transaction context before confirmation */
+  private _prepareFinalContext(updatedContext: TransactionContext): TransactionContext {
+    let finalContext = this._beforeNavigate?.({ ...updatedContext });
+
+    // This block is to catch users not returning a transaction context
+    if (!finalContext) {
+      logger.error(
+        `[ReactNavigationInstrumentation] beforeNavigate returned ${finalContext}, return context.sampled = false to not send transaction.`,
+      );
+
+      finalContext = {
+        ...updatedContext,
+        sampled: false,
+      };
+    }
+
+    // Note: finalContext.sampled will be false at this point only if the user sets it to be so in beforeNavigate.
+    if (finalContext.sampled === false) {
+      logger.log(
+        `[ReactNavigationInstrumentation] Will not send transaction "${finalContext.name}" due to beforeNavigate.`,
+      );
+    } else {
+      // Clear the timeout so the transaction does not get cancelled.
+      this._clearStateChangeTimeout();
+    }
+
+    return finalContext;
+  }
+
+  /** Pushes a recent route key, and removes earlier routes when there is greater than the max length */
+  private _pushRecentRouteKey = (key: string): void => {
+    this._recentRouteKeys.push(key);
+
+    if (this._recentRouteKeys.length > this._maxRecentRouteLen) {
+      this._recentRouteKeys = this._recentRouteKeys.slice(this._recentRouteKeys.length - this._maxRecentRouteLen);
+    }
+  };
+
+  /** Cancels the latest transaction so it does not get sent to Sentry. */
+  private _discardLatestTransaction(): void {
+    if (this._latestTransaction) {
+      this._latestTransaction.sampled = false;
+      this._latestTransaction.finish();
+      this._latestTransaction = undefined;
+    }
+  }
+
+  /**
+   *
+   */
+  private _clearStateChangeTimeout(): void {
+    if (typeof this._stateChangeTimeout !== 'undefined') {
+      clearTimeout(this._stateChangeTimeout);
+      this._stateChangeTimeout = undefined;
+    }
+  }
+}
+
+/**
+ * Backwards compatibility alias for ReactNavigationInstrumentation
+ * @deprecated Use ReactNavigationInstrumentation
+ */
+export const ReactNavigationV5Instrumentation = ReactNavigationInstrumentation;
+
+export const BLANK_TRANSACTION_CONTEXT = {
+  name: 'Route Change',
+  op: 'navigation',
+  tags: {
+    'routing.instrumentation': ReactNavigationInstrumentation.instrumentationName,
+  },
+  data: {},
+};
diff --git a/node_modules/@sentry/react-native/src/js/tracing/reactnavigationv4.ts b/node_modules/@sentry/react-native/src/js/tracing/reactnavigationv4.ts
new file mode 100644
index 0000000..8d7f302
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/reactnavigationv4.ts
@@ -0,0 +1,346 @@
+/* eslint-disable max-lines */
+import type { Transaction, TransactionContext } from '@sentry/types';
+import { logger } from '@sentry/utils';
+
+import { RN_GLOBAL_OBJ } from '../utils/worldwide';
+import type { OnConfirmRoute, TransactionCreator } from './routingInstrumentation';
+import { InternalRoutingInstrumentation } from './routingInstrumentation';
+import type { BeforeNavigate, ReactNavigationTransactionContext, RouteChangeContextData } from './types';
+import { customTransactionSource, defaultTransactionSource } from './utils';
+
+export interface NavigationRouteV4 {
+  routeName: string;
+  key: string;
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  params?: Record<string, any>;
+}
+
+export interface NavigationStateV4 {
+  index: number;
+  key: string;
+  isTransitioning: boolean;
+  routeName?: string;
+  routes: (NavigationRouteV4 | NavigationStateV4)[];
+}
+
+export interface AppContainerInstance {
+  _navigation: {
+    state: NavigationStateV4;
+    router: {
+      getStateForAction: (
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        action: any,
+        state: NavigationStateV4,
+      ) => NavigationStateV4;
+    };
+  };
+}
+
+interface ReactNavigationV4Options {
+  /**
+   * How long the instrumentation will wait for the route to mount after a change has been initiated,
+   * before the transaction is discarded.
+   * Time is in ms.
+   *
+   * Default: 1000
+   */
+  routeChangeTimeoutMs: number;
+}
+
+const defaultOptions: ReactNavigationV4Options = {
+  routeChangeTimeoutMs: 1000,
+};
+
+/**
+ * Instrumentation for React-Navigation V4.
+ * Register the app container with `registerAppContainer` to use, or see docs for more details.
+ */
+class ReactNavigationV4Instrumentation extends InternalRoutingInstrumentation {
+  public static instrumentationName: string = 'react-navigation-v4';
+
+  public readonly name: string = ReactNavigationV4Instrumentation.instrumentationName;
+
+  private _appContainer: AppContainerInstance | null = null;
+
+  private readonly _maxRecentRouteLen: number = 200;
+
+  private _prevRoute?: NavigationRouteV4;
+  private _recentRouteKeys: string[] = [];
+
+  private _latestTransaction?: Transaction;
+  private _initialStateHandled: boolean = false;
+  private _stateChangeTimeout?: number | undefined;
+
+  private _options: ReactNavigationV4Options;
+
+  public constructor(options: Partial<ReactNavigationV4Options> = {}) {
+    super();
+
+    this._options = {
+      ...defaultOptions,
+      ...options,
+    };
+  }
+
+  /**
+   * Extends by calling _handleInitialState at the end.
+   */
+  public registerRoutingInstrumentation(
+    listener: TransactionCreator,
+    beforeNavigate: BeforeNavigate,
+    onConfirmRoute: OnConfirmRoute,
+  ): void {
+    super.registerRoutingInstrumentation(listener, beforeNavigate, onConfirmRoute);
+
+    // Need to handle the initial state as the router patch will only attach transactions on subsequent route changes.
+    if (!this._initialStateHandled) {
+      this._latestTransaction = this.onRouteWillChange(INITIAL_TRANSACTION_CONTEXT_V4);
+      if (this._appContainer) {
+        this._updateLatestTransaction();
+
+        this._initialStateHandled = true;
+      } else {
+        this._stateChangeTimeout = setTimeout(
+          this._discardLatestTransaction.bind(this),
+          this._options.routeChangeTimeoutMs,
+        );
+      }
+    }
+  }
+
+  /**
+   * Pass the ref to the app container to register it to the instrumentation
+   * @param appContainerRef Ref to an `AppContainer`
+   */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
+  public registerAppContainer(appContainerRef: any): void {
+    /* We prevent duplicate routing instrumentation to be initialized on fast refreshes
+
+      Explanation: If the user triggers a fast refresh on the file that the instrumentation is
+      initialized in, it will initialize a new instance and will cause undefined behavior.
+     */
+    if (!RN_GLOBAL_OBJ.__sentry_rn_v4_registered) {
+      if ('current' in appContainerRef) {
+        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+        this._appContainer = appContainerRef.current;
+      } else {
+        this._appContainer = appContainerRef;
+      }
+
+      if (this._appContainer) {
+        this._patchRouter();
+
+        if (!this._initialStateHandled) {
+          if (this._latestTransaction) {
+            this._updateLatestTransaction();
+          } else {
+            logger.log(
+              '[ReactNavigationV4Instrumentation] App container registered, but integration has not been setup yet.',
+            );
+          }
+          this._initialStateHandled = true;
+        }
+
+        RN_GLOBAL_OBJ.__sentry_rn_v4_registered = true;
+      } else {
+        logger.warn('[ReactNavigationV4Instrumentation] Received invalid app container ref!');
+      }
+    }
+  }
+
+  /**
+   * Updates the latest transaction with the current state and calls beforeNavigate.
+   */
+  private _updateLatestTransaction(): void {
+    // We can assume the ref is present as this is called from registerAppContainer
+    if (this._appContainer && this._latestTransaction) {
+      const state = this._appContainer._navigation.state;
+
+      if (typeof this._stateChangeTimeout !== 'undefined') {
+        clearTimeout(this._stateChangeTimeout);
+        this._stateChangeTimeout = undefined;
+      }
+
+      this._onStateChange(state, true);
+    }
+  }
+
+  /**
+   * Patches the react navigation router so we can listen to the route changes and attach the `IdleTransaction` before the
+   * new screen is mounted.
+   */
+  private _patchRouter(): void {
+    if (this._appContainer) {
+      const originalGetStateForAction = this._appContainer._navigation.router.getStateForAction;
+
+      this._appContainer._navigation.router.getStateForAction = (action, state) => {
+        const newState = originalGetStateForAction(action, state);
+
+        this._onStateChange(newState);
+
+        return newState;
+      };
+    }
+  }
+
+  /**
+   * To be called on navigation state changes and creates the transaction.
+   */
+  private _onStateChange(state: NavigationStateV4 | undefined, updateLatestTransaction: boolean = false): void {
+    // it's not guaranteed that a state is always produced.
+    // see: https://github.com/react-navigation/react-navigation/blob/45d419be93c34e900e8734ce98321ae875ac4997/packages/core/src/routers/SwitchRouter.js?rgh-link-date=2021-09-25T12%3A43%3A36Z#L301
+    if (!state || state === undefined) {
+      logger.warn('[ReactNavigationV4Instrumentation] onStateChange called without a valid state.');
+
+      return;
+    }
+
+    const currentRoute = this._getCurrentRouteFromState(state);
+
+    // If the route is a different key, this is so we ignore actions that pertain to the same screen.
+    if (!this._prevRoute || currentRoute.key !== this._prevRoute.key) {
+      const originalContext = this._getTransactionContext(currentRoute, this._prevRoute);
+
+      let mergedContext = originalContext;
+      if (updateLatestTransaction && this._latestTransaction) {
+        mergedContext = {
+          ...this._latestTransaction.toContext(),
+          ...originalContext,
+        };
+      }
+
+      const finalContext = this._prepareFinalContext(mergedContext);
+
+      if (updateLatestTransaction && this._latestTransaction) {
+        // Update the latest transaction instead of calling onRouteWillChange
+        this._latestTransaction.updateWithContext(finalContext);
+        const isCustomName = mergedContext.name !== finalContext.name;
+        this._latestTransaction.setName(
+          finalContext.name,
+          isCustomName ? customTransactionSource : defaultTransactionSource,
+        );
+      } else {
+        this._latestTransaction = this.onRouteWillChange(finalContext);
+      }
+
+      this._onConfirmRoute?.(finalContext);
+
+      this._pushRecentRouteKey(currentRoute.key);
+      this._prevRoute = currentRoute;
+    }
+  }
+
+  /** Creates final transaction context before confirmation */
+  private _prepareFinalContext(mergedContext: TransactionContext): TransactionContext {
+    let finalContext = this._beforeNavigate?.({ ...mergedContext });
+
+    // This block is to catch users not returning a transaction context
+    if (!finalContext) {
+      logger.error(
+        `[ReactNavigationV4Instrumentation] beforeNavigate returned ${finalContext}, return context.sampled = false to not send transaction.`,
+      );
+
+      finalContext = {
+        ...mergedContext,
+        sampled: false,
+      };
+    }
+
+    if (finalContext.sampled === false) {
+      this._onBeforeNavigateNotSampled(finalContext.name);
+    }
+
+    return finalContext;
+  }
+
+  /**
+   * Gets the transaction context for a `NavigationRouteV4`
+   */
+  private _getTransactionContext(
+    route: NavigationRouteV4,
+    previousRoute?: NavigationRouteV4,
+  ): ReactNavigationTransactionContext {
+    const data: RouteChangeContextData = {
+      route: {
+        name: route.routeName, // Include name here too for use in `beforeNavigate`
+        key: route.key,
+        params: route.params ?? {},
+        hasBeenSeen: this._recentRouteKeys.includes(route.key),
+      },
+      previousRoute: previousRoute
+        ? {
+            name: previousRoute.routeName,
+            key: previousRoute.key,
+            params: previousRoute.params ?? {},
+          }
+        : null,
+    };
+
+    return {
+      name: route.routeName,
+      op: 'navigation',
+      tags: {
+        'routing.instrumentation': ReactNavigationV4Instrumentation.instrumentationName,
+        'routing.route.name': route.routeName,
+      },
+      data,
+    };
+  }
+
+  /**
+   * Gets the current route given a navigation state
+   */
+  private _getCurrentRouteFromState(state: NavigationStateV4): NavigationRouteV4 {
+    const parentRoute = state.routes[state.index];
+
+    if (
+      'index' in parentRoute &&
+      'routes' in parentRoute &&
+      typeof parentRoute.index === 'number' &&
+      Array.isArray(parentRoute.routes)
+    ) {
+      return this._getCurrentRouteFromState(parentRoute);
+    }
+
+    return parentRoute as NavigationRouteV4;
+  }
+
+  /** Pushes a recent route key, and removes earlier routes when there is greater than the max length */
+  private _pushRecentRouteKey = (key: string): void => {
+    this._recentRouteKeys.push(key);
+
+    if (this._recentRouteKeys.length > this._maxRecentRouteLen) {
+      this._recentRouteKeys = this._recentRouteKeys.slice(this._recentRouteKeys.length - this._maxRecentRouteLen);
+    }
+  };
+
+  /** Helper to log a transaction that was not sampled due to beforeNavigate */
+  private _onBeforeNavigateNotSampled = (transactionName: string): void => {
+    logger.log(
+      `[ReactNavigationV4Instrumentation] Will not send transaction "${transactionName}" due to beforeNavigate.`,
+    );
+  };
+
+  /** Cancels the latest transaction so it does not get sent to Sentry. */
+  private _discardLatestTransaction(): void {
+    if (this._latestTransaction) {
+      this._latestTransaction.sampled = false;
+      this._latestTransaction.finish();
+      this._latestTransaction = undefined;
+    }
+  }
+}
+
+const INITIAL_TRANSACTION_CONTEXT_V4: TransactionContext = {
+  name: 'App Launch',
+  op: 'navigation',
+  tags: {
+    'routing.instrumentation': ReactNavigationV4Instrumentation.instrumentationName,
+  },
+  data: {},
+  metadata: {
+    source: 'view',
+  },
+};
+
+export { ReactNavigationV4Instrumentation, INITIAL_TRANSACTION_CONTEXT_V4 };
diff --git a/node_modules/@sentry/react-native/src/js/tracing/routingInstrumentation.ts b/node_modules/@sentry/react-native/src/js/tracing/routingInstrumentation.ts
new file mode 100644
index 0000000..c7778fd
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/routingInstrumentation.ts
@@ -0,0 +1,83 @@
+import type { Hub } from '@sentry/core';
+import type { Transaction, TransactionContext } from '@sentry/types';
+
+import type { BeforeNavigate } from './types';
+
+export type TransactionCreator = (context: TransactionContext) => Transaction | undefined;
+
+export type OnConfirmRoute = (context: TransactionContext) => void;
+
+export interface RoutingInstrumentationInstance {
+  /**
+   * Name of the routing instrumentation
+   */
+  readonly name: string;
+  /**
+   * Registers a listener that's called on every route change with a `TransactionContext`.
+   *
+   * Do not overwrite this unless you know what you are doing.
+   *
+   * @param listener A `RouteListener`
+   * @param beforeNavigate BeforeNavigate
+   * @param inConfirmRoute OnConfirmRoute
+   */
+  registerRoutingInstrumentation(
+    listener: TransactionCreator,
+    beforeNavigate: BeforeNavigate,
+    onConfirmRoute: OnConfirmRoute,
+  ): void;
+  /**
+   * To be called when the route changes, BEFORE the new route mounts.
+   * If this is called after a route mounts the child spans will not be correctly attached.
+   *
+   * @param context A `TransactionContext` used to initialize the transaction.
+   */
+  onRouteWillChange(context: TransactionContext): Transaction | undefined;
+}
+
+/**
+ * Base Routing Instrumentation. Can be used by users to manually instrument custom routers.
+ * Pass this to the tracing integration, and call `onRouteWillChange` every time before a route changes.
+ */
+export class RoutingInstrumentation implements RoutingInstrumentationInstance {
+  public static instrumentationName: string = 'base-routing-instrumentation';
+
+  public readonly name: string = RoutingInstrumentation.instrumentationName;
+
+  protected _getCurrentHub?: () => Hub;
+  protected _beforeNavigate?: BeforeNavigate;
+  protected _onConfirmRoute?: OnConfirmRoute;
+  protected _tracingListener?: TransactionCreator;
+
+  /** @inheritdoc */
+  public registerRoutingInstrumentation(
+    listener: TransactionCreator,
+    beforeNavigate: BeforeNavigate,
+    onConfirmRoute: OnConfirmRoute,
+  ): void {
+    this._tracingListener = listener;
+    this._beforeNavigate = beforeNavigate;
+    this._onConfirmRoute = onConfirmRoute;
+  }
+
+  /** @inheritdoc */
+  public onRouteWillChange(context: TransactionContext): Transaction | undefined {
+    const transaction = this._tracingListener?.(context);
+
+    if (transaction) {
+      this._onConfirmRoute?.(context);
+    }
+
+    return transaction;
+  }
+}
+
+/**
+ * Internal base routing instrumentation where `_onConfirmRoute` is not called in onRouteWillChange
+ */
+export class InternalRoutingInstrumentation extends RoutingInstrumentation {
+  /** @inheritdoc */
+  public onRouteWillChange(context: TransactionContext): Transaction | undefined {
+    return this._tracingListener?.(context);
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/stalltracking.ts b/node_modules/@sentry/react-native/src/js/tracing/stalltracking.ts
new file mode 100644
index 0000000..8d2fef3
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/stalltracking.ts
@@ -0,0 +1,379 @@
+/* eslint-disable max-lines */
+import type { IdleTransaction, Span, Transaction } from '@sentry/core';
+import type { Measurements, MeasurementUnit } from '@sentry/types';
+import { logger, timestampInSeconds } from '@sentry/utils';
+import type { AppStateStatus } from 'react-native';
+import { AppState } from 'react-native';
+
+import { STALL_COUNT, STALL_LONGEST_TIME, STALL_TOTAL_TIME } from '../measurements';
+
+export interface StallMeasurements extends Measurements {
+  [STALL_COUNT]: { value: number; unit: MeasurementUnit };
+  [STALL_TOTAL_TIME]: { value: number; unit: MeasurementUnit };
+  [STALL_LONGEST_TIME]: { value: number; unit: MeasurementUnit };
+}
+
+export type StallTrackingOptions = {
+  /**
+   * How long in milliseconds an event loop iteration can be delayed for before being considered a "stall."
+   * @default 100
+   */
+  minimumStallThreshold: number;
+};
+
+/** Margin of error of 20ms */
+const MARGIN_OF_ERROR_SECONDS = 0.02;
+/** How long between each iteration in the event loop tracker timeout */
+const LOOP_TIMEOUT_INTERVAL_MS = 50;
+/** Limit for how many transactions the stall tracker will track at a time to prevent leaks due to transactions not being finished */
+const MAX_RUNNING_TRANSACTIONS = 10;
+
+/**
+ * Stall measurement tracker inspired by the `JSEventLoopWatchdog` used internally in React Native:
+ * https://github.com/facebook/react-native/blob/006f5afe120c290a37cf6ff896748fbc062bf7ed/Libraries/Interaction/JSEventLoopWatchdog.js
+ *
+ * However, we modified the interval implementation to instead have a fixed loop timeout interval of `LOOP_TIMEOUT_INTERVAL_MS`.
+ * We then would consider that iteration a stall when the total time for that interval to run is greater than `LOOP_TIMEOUT_INTERVAL_MS + minimumStallThreshold`
+ */
+export class StallTrackingInstrumentation {
+  public isTracking: boolean = false;
+
+  private _minimumStallThreshold: number;
+
+  /** Total amount of time of all stalls that occurred during the current tracking session */
+  private _totalStallTime: number = 0;
+  /** Total number of stalls that occurred during the current tracking session */
+  private _stallCount: number = 0;
+
+  /** The last timestamp the iteration ran in milliseconds */
+  private _lastIntervalMs: number = 0;
+  private _timeout: ReturnType<typeof setTimeout> | null = null;
+
+  private _isBackground: boolean = false;
+
+  private _statsByTransaction: Map<
+    Transaction,
+    {
+      longestStallTime: number;
+      atStart: StallMeasurements;
+      atTimestamp: {
+        timestamp: number;
+        stats: StallMeasurements;
+      } | null;
+    }
+  > = new Map();
+
+  public constructor(options: StallTrackingOptions = { minimumStallThreshold: 50 }) {
+    this._minimumStallThreshold = options.minimumStallThreshold;
+
+    this._backgroundEventListener = this._backgroundEventListener.bind(this);
+    // Avoids throwing any error if using React Native on a environment that doesn't implement AppState.
+    if (AppState?.isAvailable) {
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      AppState.addEventListener('change', this._backgroundEventListener);
+    }
+  }
+
+  /**
+   * @inheritDoc
+   * Not used for this integration. Instead call `registerTransactionStart` to start tracking.
+   */
+  public setupOnce(): void {
+    // Do nothing.
+  }
+
+  /**
+   * Register a transaction as started. Starts stall tracking if not already running.
+   * @returns A finish method that returns the stall measurements.
+   */
+  public onTransactionStart(transaction: Transaction): void {
+    if (this._statsByTransaction.has(transaction)) {
+      logger.error(
+        '[StallTracking] Tried to start stall tracking on a transaction already being tracked. Measurements might be lost.',
+      );
+
+      return;
+    }
+
+    this._startTracking();
+    this._statsByTransaction.set(transaction, {
+      longestStallTime: 0,
+      atTimestamp: null,
+      atStart: this._getCurrentStats(transaction),
+    });
+    this._flushLeakedTransactions();
+
+    if (transaction.spanRecorder) {
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      const originalAdd = transaction.spanRecorder.add;
+
+      transaction.spanRecorder.add = (span: Span): void => {
+        originalAdd.apply(transaction.spanRecorder, [span]);
+
+        // eslint-disable-next-line @typescript-eslint/unbound-method
+        const originalSpanFinish = span.finish;
+
+        span.finish = (endTimestamp?: number) => {
+          // We let the span determine its own end timestamp as well in case anything gets changed upstream
+          originalSpanFinish.apply(span, [endTimestamp]);
+
+          // The span should set a timestamp, so this would be defined.
+          if (span.endTimestamp) {
+            this._markSpanFinish(transaction, span.endTimestamp);
+          }
+        };
+      };
+    }
+  }
+
+  /**
+   * Logs a transaction as finished.
+   * Stops stall tracking if no more transactions are running.
+   * @returns The stall measurements
+   */
+  public onTransactionFinish(transaction: Transaction | IdleTransaction, passedEndTimestamp?: number): void {
+    const transactionStats = this._statsByTransaction.get(transaction);
+
+    if (!transactionStats) {
+      // Transaction has been flushed out somehow, we return null.
+      logger.log('[StallTracking] Stall measurements were not added to transaction due to exceeding the max count.');
+
+      this._statsByTransaction.delete(transaction);
+      this._shouldStopTracking();
+
+      return;
+    }
+
+    const endTimestamp = passedEndTimestamp ?? transaction.endTimestamp;
+
+    const spans = transaction.spanRecorder ? transaction.spanRecorder.spans : [];
+    const finishedSpanCount = spans.reduce((count, s) => (s !== transaction && s.endTimestamp ? count + 1 : count), 0);
+
+    const trimEnd = transaction.toContext().trimEnd;
+    const endWillBeTrimmed = trimEnd && finishedSpanCount > 0;
+
+    /*
+      This is not safe in the case that something changes upstream, but if we're planning to move this over to @sentry/javascript anyways,
+      we can have this temporarily for now.
+    */
+    const isIdleTransaction = 'activities' in transaction;
+
+    let statsOnFinish: StallMeasurements | undefined;
+    if (endTimestamp && isIdleTransaction) {
+      /*
+        There is different behavior regarding child spans in a normal transaction and an idle transaction. In normal transactions,
+        the child spans that aren't finished will be dumped, while in an idle transaction they're cancelled and finished.
+
+        Note: `endTimestamp` will always be defined if this is called on an idle transaction finish. This is because we only instrument
+        idle transactions inside `ReactNativeTracing`, which will pass an `endTimestamp`.
+      */
+
+      // There will be cancelled spans, which means that the end won't be trimmed
+      const spansWillBeCancelled = spans.some(
+        s => s !== transaction && s.startTimestamp < endTimestamp && !s.endTimestamp,
+      );
+
+      if (endWillBeTrimmed && !spansWillBeCancelled) {
+        // the last span's timestamp will be used.
+
+        if (transactionStats.atTimestamp) {
+          statsOnFinish = transactionStats.atTimestamp.stats;
+        }
+      } else {
+        // this endTimestamp will be used.
+        statsOnFinish = this._getCurrentStats(transaction);
+      }
+    } else if (endWillBeTrimmed) {
+      // If `trimEnd` is used, and there is a span to trim to. If there isn't, then the transaction should use `endTimestamp` or generate one.
+      if (transactionStats.atTimestamp) {
+        statsOnFinish = transactionStats.atTimestamp.stats;
+      }
+    } else if (!endTimestamp) {
+      statsOnFinish = this._getCurrentStats(transaction);
+    }
+
+    this._statsByTransaction.delete(transaction);
+    this._shouldStopTracking();
+
+    if (!statsOnFinish) {
+      if (typeof endTimestamp !== 'undefined') {
+        logger.log('[StallTracking] Stall measurements not added due to `endTimestamp` being set.');
+      } else if (trimEnd) {
+        logger.log(
+          '[StallTracking] Stall measurements not added due to `trimEnd` being set but we could not determine the stall measurements at that time.',
+        );
+      }
+
+      return;
+    }
+
+    transaction.setMeasurement(
+      STALL_COUNT,
+      statsOnFinish.stall_count.value - transactionStats.atStart.stall_count.value,
+      transactionStats.atStart.stall_count.unit,
+    );
+
+    transaction.setMeasurement(
+      STALL_TOTAL_TIME,
+      statsOnFinish.stall_total_time.value - transactionStats.atStart.stall_total_time.value,
+      transactionStats.atStart.stall_total_time.unit,
+    );
+
+    transaction.setMeasurement(
+      STALL_LONGEST_TIME,
+      statsOnFinish.stall_longest_time.value,
+      statsOnFinish.stall_longest_time.unit,
+    );
+  }
+
+  /**
+   * Switch that enables the iteraction once app moves from background to foreground.
+   */
+  private _backgroundEventListener(state: AppStateStatus): void {
+    if (state === ('active' as AppStateStatus)) {
+      this._isBackground = false;
+      if (this._timeout != null) {
+        this._lastIntervalMs = timestampInSeconds() * 1000;
+        this._iteration();
+      }
+    } else {
+      this._isBackground = true;
+      this._timeout !== null && clearTimeout(this._timeout);
+    }
+  }
+
+  /**
+   * Logs the finish time of the span for use in `trimEnd: true` transactions.
+   */
+  private _markSpanFinish(transaction: Transaction, spanEndTimestamp: number): void {
+    const previousStats = this._statsByTransaction.get(transaction);
+    if (previousStats) {
+      if (Math.abs(timestampInSeconds() - spanEndTimestamp) > MARGIN_OF_ERROR_SECONDS) {
+        logger.log(
+          '[StallTracking] Span end not logged due to end timestamp being outside the margin of error from now.',
+        );
+
+        if (previousStats.atTimestamp && previousStats.atTimestamp.timestamp < spanEndTimestamp) {
+          // We also need to delete the stat for the last span, as the transaction would be trimmed to this span not the last one.
+          this._statsByTransaction.set(transaction, {
+            ...previousStats,
+            atTimestamp: null,
+          });
+        }
+      } else {
+        this._statsByTransaction.set(transaction, {
+          ...previousStats,
+          atTimestamp: {
+            timestamp: spanEndTimestamp,
+            stats: this._getCurrentStats(transaction),
+          },
+        });
+      }
+    }
+  }
+
+  /**
+   * Get the current stats for a transaction at a given time.
+   */
+  private _getCurrentStats(transaction: Transaction): StallMeasurements {
+    return {
+      stall_count: { value: this._stallCount, unit: 'none' },
+      stall_total_time: { value: this._totalStallTime, unit: 'millisecond' },
+      stall_longest_time: {
+        value: this._statsByTransaction.get(transaction)?.longestStallTime ?? 0,
+        unit: 'millisecond',
+      },
+    };
+  }
+
+  /**
+   * Start tracking stalls
+   */
+  private _startTracking(): void {
+    if (!this.isTracking) {
+      this.isTracking = true;
+      this._lastIntervalMs = Math.floor(timestampInSeconds() * 1000);
+
+      this._iteration();
+    }
+  }
+
+  /**
+   * Stops the stall tracking interval and calls reset().
+   */
+  private _stopTracking(): void {
+    this.isTracking = false;
+
+    if (this._timeout !== null) {
+      clearTimeout(this._timeout);
+      this._timeout = null;
+    }
+
+    this._reset();
+  }
+
+  /**
+   * Will stop tracking if there are no more transactions.
+   */
+  private _shouldStopTracking(): void {
+    if (this._statsByTransaction.size === 0) {
+      this._stopTracking();
+    }
+  }
+
+  /**
+   * Clears all the collected stats
+   */
+  private _reset(): void {
+    this._stallCount = 0;
+    this._totalStallTime = 0;
+    this._lastIntervalMs = 0;
+    this._statsByTransaction.clear();
+  }
+
+  /**
+   * Iteration of the stall tracking interval. Measures how long the timer strayed from its expected time of running, and how
+   * long the stall is for.
+   */
+  private _iteration(): void {
+    const now = timestampInSeconds() * 1000;
+    const totalTimeTaken = now - this._lastIntervalMs;
+
+    if (totalTimeTaken >= LOOP_TIMEOUT_INTERVAL_MS + this._minimumStallThreshold) {
+      const stallTime = totalTimeTaken - LOOP_TIMEOUT_INTERVAL_MS;
+      this._stallCount += 1;
+      this._totalStallTime += stallTime;
+
+      for (const [transaction, value] of this._statsByTransaction.entries()) {
+        const longestStallTime = Math.max(value.longestStallTime ?? 0, stallTime);
+
+        this._statsByTransaction.set(transaction, {
+          ...value,
+          longestStallTime,
+        });
+      }
+    }
+
+    this._lastIntervalMs = now;
+
+    if (this.isTracking && !this._isBackground) {
+      this._timeout = setTimeout(this._iteration.bind(this), LOOP_TIMEOUT_INTERVAL_MS);
+    }
+  }
+
+  /**
+   * Deletes leaked transactions (Earliest transactions when we have more than MAX_RUNNING_TRANSACTIONS transactions.)
+   */
+  private _flushLeakedTransactions(): void {
+    if (this._statsByTransaction.size > MAX_RUNNING_TRANSACTIONS) {
+      let counter = 0;
+      const len = this._statsByTransaction.size - MAX_RUNNING_TRANSACTIONS;
+      const transactions = this._statsByTransaction.keys();
+      for (const t of transactions) {
+        if (counter >= len) break;
+        counter += 1;
+        this._statsByTransaction.delete(t);
+      }
+    }
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/tracing/transaction.ts b/node_modules/@sentry/react-native/src/js/tracing/transaction.ts
new file mode 100644
index 0000000..2686fe9
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/transaction.ts
@@ -0,0 +1,36 @@
+import { type BeforeFinishCallback, type IdleTransaction } from '@sentry/core';
+import { logger } from '@sentry/utils';
+import type { AppStateStatus } from 'react-native';
+import { AppState } from 'react-native';
+
+/**
+ * Idle Transaction callback to only sample transactions with child spans.
+ * To avoid side effects of other callbacks this should be hooked as the last callback.
+ */
+export const onlySampleIfChildSpans: BeforeFinishCallback = (transaction: IdleTransaction): void => {
+  const spansCount =
+    transaction.spanRecorder &&
+    transaction.spanRecorder.spans.filter(span => span.spanId !== transaction.spanId).length;
+
+  if (!spansCount || spansCount <= 0) {
+    logger.log(`Not sampling as ${transaction.op} transaction has no child spans.`);
+    transaction.sampled = false;
+  }
+};
+
+/**
+ * Hooks on AppState change to cancel the transaction if the app goes background.
+ */
+export const cancelInBackground = (transaction: IdleTransaction): void => {
+  const subscription = AppState.addEventListener('change', (newState: AppStateStatus) => {
+    if (newState === 'background') {
+      logger.debug(`Setting ${transaction.op} transaction to cancelled because the app is in the background.`);
+      transaction.setStatus('cancelled');
+      transaction.finish();
+    }
+  });
+  transaction.registerBeforeFinishCallback(() => {
+    logger.debug(`Removing AppState listener for ${transaction.op} transaction.`);
+    subscription.remove();
+  });
+};
diff --git a/node_modules/@sentry/react-native/src/js/tracing/types.ts b/node_modules/@sentry/react-native/src/js/tracing/types.ts
new file mode 100644
index 0000000..16f9914
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/types.ts
@@ -0,0 +1,34 @@
+import type { TransactionContext } from '@sentry/types';
+
+export interface ReactNavigationRoute {
+  name: string;
+  key: string;
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  params: Record<string, any>;
+}
+
+export interface ReactNavigationCurrentRoute extends ReactNavigationRoute {
+  hasBeenSeen: boolean;
+}
+
+export type RouteChangeContextData = {
+  previousRoute?: {
+    [key: string]: unknown;
+    name: string;
+  } | null;
+  route: {
+    [key: string]: unknown;
+    name: string;
+    hasBeenSeen: boolean;
+  };
+};
+
+export interface ReactNavigationTransactionContext extends TransactionContext {
+  tags: {
+    'routing.instrumentation': string;
+    'routing.route.name': string;
+  };
+  data: RouteChangeContextData;
+}
+
+export type BeforeNavigate = (context: TransactionContext) => TransactionContext;
diff --git a/node_modules/@sentry/react-native/src/js/tracing/utils.ts b/node_modules/@sentry/react-native/src/js/tracing/utils.ts
new file mode 100644
index 0000000..9d39156
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/tracing/utils.ts
@@ -0,0 +1,84 @@
+import type { IdleTransaction, Span, Transaction } from '@sentry/core';
+import type { TransactionContext, TransactionSource } from '@sentry/types';
+import { timestampInSeconds } from '@sentry/utils';
+
+export const defaultTransactionSource: TransactionSource = 'component';
+export const customTransactionSource: TransactionSource = 'custom';
+
+export const getBlankTransactionContext = (name: string): TransactionContext => {
+  return {
+    name: 'Route Change',
+    op: 'navigation',
+    tags: {
+      'routing.instrumentation': name,
+    },
+    data: {},
+    metadata: {
+      source: defaultTransactionSource,
+    },
+  };
+};
+
+/**
+ * A margin of error of 50ms is allowed for the async native bridge call.
+ * Anything larger would reduce the accuracy of our frames measurements.
+ */
+export const MARGIN_OF_ERROR_SECONDS = 0.05;
+
+const timeOriginMilliseconds = Date.now();
+
+/**
+ *
+ */
+export function adjustTransactionDuration(
+  maxDurationMs: number,
+  transaction: IdleTransaction,
+  endTimestamp: number,
+): void {
+  const diff = endTimestamp - transaction.startTimestamp;
+  const isOutdatedTransaction = endTimestamp && (diff > maxDurationMs || diff < 0);
+  if (isOutdatedTransaction) {
+    transaction.setStatus('deadline_exceeded');
+    transaction.setTag('maxTransactionDurationExceeded', 'true');
+  }
+}
+
+/**
+ * Returns the timestamp where the JS global scope was initialized.
+ */
+export function getTimeOriginMilliseconds(): number {
+  return timeOriginMilliseconds;
+}
+
+/**
+ * Calls the callback every time a child span of the transaction is finished.
+ */
+export function instrumentChildSpanFinish(
+  transaction: Transaction,
+  callback: (span: Span, endTimestamp?: number) => void,
+): void {
+  if (transaction.spanRecorder) {
+    // eslint-disable-next-line @typescript-eslint/unbound-method
+    const originalAdd = transaction.spanRecorder.add;
+
+    transaction.spanRecorder.add = (span: Span): void => {
+      originalAdd.apply(transaction.spanRecorder, [span]);
+
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      const originalSpanFinish = span.finish;
+
+      span.finish = (endTimestamp?: number) => {
+        originalSpanFinish.apply(span, [endTimestamp]);
+
+        callback(span, endTimestamp);
+      };
+    };
+  }
+}
+
+/**
+ * Determines if the timestamp is now or within the specified margin of error from now.
+ */
+export function isNearToNow(timestamp: number): boolean {
+  return Math.abs(timestampInSeconds() - timestamp) <= MARGIN_OF_ERROR_SECONDS;
+}
diff --git a/node_modules/@sentry/react-native/src/js/transports/TextEncoder.ts b/node_modules/@sentry/react-native/src/js/transports/TextEncoder.ts
new file mode 100644
index 0000000..05206d4
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/transports/TextEncoder.ts
@@ -0,0 +1,14 @@
+import type { TextEncoderInternal } from '@sentry/types';
+
+import { utf8ToBytes } from '../vendor';
+
+export const makeUtf8TextEncoder = (): TextEncoderInternal => {
+  const textEncoder = {
+    encode: (text: string) => {
+      const bytes = new Uint8Array(utf8ToBytes(text));
+      return bytes;
+    },
+    encoding: 'utf-8',
+  };
+  return textEncoder;
+};
diff --git a/node_modules/@sentry/react-native/src/js/transports/native.ts b/node_modules/@sentry/react-native/src/js/transports/native.ts
new file mode 100644
index 0000000..9ae0e95
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/transports/native.ts
@@ -0,0 +1,65 @@
+import type { BaseTransportOptions, Envelope, Transport } from '@sentry/types';
+import type { PromiseBuffer } from '@sentry/utils';
+import { makePromiseBuffer } from '@sentry/utils';
+
+import { NATIVE } from '../wrapper';
+
+export const DEFAULT_BUFFER_SIZE = 30;
+
+export type BaseNativeTransport = BaseTransportOptions;
+
+export interface BaseNativeTransportOptions {
+  bufferSize?: number;
+}
+
+/** Native Transport class implementation */
+export class NativeTransport implements Transport {
+  /** A simple buffer holding all requests. */
+  protected readonly _buffer: PromiseBuffer<void>;
+
+  public constructor(options: BaseNativeTransportOptions = {}) {
+    this._buffer = makePromiseBuffer(options.bufferSize || DEFAULT_BUFFER_SIZE);
+  }
+
+  /**
+   * Sends the envelope to the Store endpoint in Sentry.
+   *
+   * @param envelope Envelope that should be sent to Sentry.
+   */
+  public send(envelope: Envelope): PromiseLike<void> {
+    return this._buffer.add(() => NATIVE.sendEnvelope(envelope));
+  }
+
+  /**
+   * Wait for all envelopes to be sent or the timeout to expire, whichever comes first.
+   *
+   * @param timeout Maximum time in ms the transport should wait for envelopes to be flushed. Omitting this parameter will
+   *   cause the transport to wait until all events are sent before resolving the promise.
+   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
+   * still events in the queue when the timeout is reached.
+   */
+  public flush(timeout?: number): PromiseLike<boolean> {
+    return this._buffer.drain(timeout);
+  }
+}
+
+/**
+ * Creates a Native Transport.
+ */
+export function makeNativeTransport(options: BaseNativeTransportOptions = {}): NativeTransport {
+  return new NativeTransport(options);
+}
+
+/**
+ * Creates a Native Transport factory if the native transport is available.
+ */
+export function makeNativeTransportFactory({
+  enableNative,
+}: {
+  enableNative?: boolean;
+}): typeof makeNativeTransport | null {
+  if (enableNative && NATIVE.isNativeAvailable()) {
+    return makeNativeTransport;
+  }
+  return null;
+}
diff --git a/node_modules/@sentry/react-native/src/js/user.ts b/node_modules/@sentry/react-native/src/js/user.ts
new file mode 100644
index 0000000..5380929
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/user.ts
@@ -0,0 +1,4 @@
+import type { User } from '@sentry/types';
+
+/** Requires all the keys defined on User interface to be present on an object */
+export type RequiredKeysUser = { [P in keyof Required<User>]: User[P] | undefined };
diff --git a/node_modules/@sentry/react-native/src/js/utils/envelope.ts b/node_modules/@sentry/react-native/src/js/utils/envelope.ts
new file mode 100644
index 0000000..a5b7386
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/envelope.ts
@@ -0,0 +1,44 @@
+import type { DsnComponents, EventEnvelope, SdkMetadata, UserFeedback, UserFeedbackItem } from '@sentry/types';
+import { createEnvelope, dsnToString } from '@sentry/utils';
+
+export const header = 0;
+export const items = 1;
+
+/**
+ * Creates an envelope from a user feedback.
+ */
+export function createUserFeedbackEnvelope(
+  feedback: UserFeedback,
+  {
+    metadata,
+    tunnel,
+    dsn,
+  }: {
+    metadata: SdkMetadata | undefined;
+    tunnel: string | undefined;
+    dsn: DsnComponents | undefined;
+  },
+): EventEnvelope {
+  const headers: EventEnvelope[0] = {
+    event_id: feedback.event_id,
+    sent_at: new Date().toISOString(),
+    ...(metadata &&
+      metadata.sdk && {
+        sdk: {
+          name: metadata.sdk.name,
+          version: metadata.sdk.version,
+        },
+      }),
+    ...(!!tunnel && !!dsn && { dsn: dsnToString(dsn) }),
+  };
+  const item = createUserFeedbackEnvelopeItem(feedback);
+
+  return createEnvelope(headers, [item]);
+}
+
+function createUserFeedbackEnvelopeItem(feedback: UserFeedback): UserFeedbackItem {
+  const feedbackHeaders: UserFeedbackItem[0] = {
+    type: 'user_report',
+  };
+  return [feedbackHeaders, feedback];
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/environment.ts b/node_modules/@sentry/react-native/src/js/utils/environment.ts
new file mode 100644
index 0000000..241d208
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/environment.ts
@@ -0,0 +1,45 @@
+import { RN_GLOBAL_OBJ } from '../utils/worldwide';
+import { ReactNativeLibraries } from './rnlibraries';
+
+/** Checks if the React Native Hermes engine is running */
+export function isHermesEnabled(): boolean {
+  return !!RN_GLOBAL_OBJ.HermesInternal;
+}
+
+/** Checks if the React Native TurboModules are enabled */
+export function isTurboModuleEnabled(): boolean {
+  return RN_GLOBAL_OBJ.__turboModuleProxy != null;
+}
+
+/** Checks if the React Native Fabric renderer is running */
+export function isFabricEnabled(): boolean {
+  return RN_GLOBAL_OBJ.nativeFabricUIManager != null;
+}
+
+/** Returns React Native Version as semver string */
+export function getReactNativeVersion(): string | undefined {
+  if (!ReactNativeLibraries.ReactNativeVersion) {
+    return undefined;
+  }
+  const RNV = ReactNativeLibraries.ReactNativeVersion.version;
+  return `${RNV.major}.${RNV.minor}.${RNV.patch}${RNV.prerelease != null ? `-${RNV.prerelease}` : ''}`;
+}
+
+/** Checks if Expo is present in the runtime */
+export function isExpo(): boolean {
+  return RN_GLOBAL_OBJ.expo != null;
+}
+
+/** Returns Hermes Version if hermes is present in the runtime */
+export function getHermesVersion(): string | undefined {
+  return (
+    RN_GLOBAL_OBJ.HermesInternal &&
+    RN_GLOBAL_OBJ.HermesInternal.getRuntimeProperties &&
+    RN_GLOBAL_OBJ.HermesInternal.getRuntimeProperties()['OSS Release Version']
+  );
+}
+
+/** Returns default environment based on __DEV__ */
+export function getDefaultEnvironment(): 'development' | 'production' {
+  return typeof __DEV__ !== 'undefined' && __DEV__ ? 'development' : 'production';
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/error.ts b/node_modules/@sentry/react-native/src/js/utils/error.ts
new file mode 100644
index 0000000..044e3a8
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/error.ts
@@ -0,0 +1,38 @@
+export interface ExtendedError extends Error {
+  framesToPop?: number | undefined;
+}
+
+// Sentry Stack Parser is skipping lines not frames
+// https://github.com/getsentry/sentry-javascript/blob/739d904342aaf9327312f409952f14ceff4ae1ab/packages/utils/src/stacktrace.ts#L23
+// 1 for first line with the Error message
+const SENTRY_STACK_PARSER_OFFSET = 1;
+const REMOVE_ERROR_CREATION_FRAMES = 2 + SENTRY_STACK_PARSER_OFFSET;
+
+/**
+ * Creates synthetic trace. By default pops 2 frames - `createSyntheticError` and the caller
+ */
+export function createSyntheticError(framesToPop: number = 0): ExtendedError {
+  const error: ExtendedError = new Error();
+  error.framesToPop = framesToPop + REMOVE_ERROR_CREATION_FRAMES; // Skip createSyntheticError's own stack frame.
+  return error;
+}
+
+/**
+ * Returns the number of frames to pop from the stack trace.
+ * @param error ExtendedError
+ */
+export function getFramesToPop(error: ExtendedError): number {
+  return error.framesToPop !== undefined ? error.framesToPop : 0;
+}
+
+/**
+ * Check if `potentialError` is an object with string stack property.
+ */
+export function isErrorLike(potentialError: unknown): potentialError is { stack: string } {
+  return (
+    potentialError !== null &&
+    typeof potentialError === 'object' &&
+    'stack' in potentialError &&
+    typeof potentialError.stack === 'string'
+  );
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/ignorerequirecyclelogs.ts b/node_modules/@sentry/react-native/src/js/utils/ignorerequirecyclelogs.ts
new file mode 100644
index 0000000..7df3a3f
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/ignorerequirecyclelogs.ts
@@ -0,0 +1,8 @@
+import { LogBox } from 'react-native';
+
+/**
+ * This is a workaround for using fetch on RN, this is a known issue in react-native and only generates a warning.
+ */
+export function ignoreRequireCycleLogs(): void {
+  LogBox.ignoreLogs(['Require cycle:']);
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/normalize.ts b/node_modules/@sentry/react-native/src/js/utils/normalize.ts
new file mode 100644
index 0000000..fb3245f
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/normalize.ts
@@ -0,0 +1,19 @@
+import { normalize } from '@sentry/utils';
+
+const KEY = 'value';
+
+/**
+ * Converts any input into a valid record with string keys.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+export function convertToNormalizedObject(data: unknown): Record<string, any> {
+  const normalized: unknown = normalize(data);
+  if (normalized === null || typeof normalized !== 'object') {
+    return {
+      [KEY]: normalized,
+    };
+  } else {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    return normalized as Record<string, any>;
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/outcome.ts b/node_modules/@sentry/react-native/src/js/utils/outcome.ts
new file mode 100644
index 0000000..cd4279d
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/outcome.ts
@@ -0,0 +1,22 @@
+import type { Outcome } from '@sentry/types';
+
+/**
+ * Merges buffer with new outcomes.
+ */
+export function mergeOutcomes(...merge: Outcome[][]): Outcome[] {
+  const map = new Map<string, Outcome>();
+
+  const process = (outcome: Outcome): void => {
+    const key = `${outcome.reason}:${outcome.category}`;
+    const existing = map.get(key);
+    if (existing) {
+      existing.quantity += outcome.quantity;
+    } else {
+      map.set(key, outcome);
+    }
+  };
+
+  merge.forEach(outcomes => outcomes.forEach(process));
+
+  return [...map.values()];
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/rnlibraries.ts b/node_modules/@sentry/react-native/src/js/utils/rnlibraries.ts
new file mode 100644
index 0000000..f00c8c5
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/rnlibraries.ts
@@ -0,0 +1,36 @@
+/* eslint-disable @typescript-eslint/no-var-requires */
+
+import { version as RNV } from 'react-native/Libraries/Core/ReactNativeVersion';
+
+import type * as ReactNative from '../vendor/react-native';
+import type { ReactNativeLibrariesInterface } from './rnlibrariesinterface';
+
+export const ReactNativeLibraries: Required<ReactNativeLibrariesInterface> = {
+  Devtools: {
+    parseErrorStack: (errorStack: string): Array<ReactNative.StackFrame> => {
+      const parseErrorStack = require('react-native/Libraries/Core/Devtools/parseErrorStack');
+      return parseErrorStack(errorStack);
+    },
+    symbolicateStackTrace: (
+      stack: Array<ReactNative.StackFrame>,
+      extraData?: Record<string, unknown>,
+    ): Promise<ReactNative.SymbolicatedStackTrace> => {
+      const symbolicateStackTrace = require('react-native/Libraries/Core/Devtools/symbolicateStackTrace');
+      return symbolicateStackTrace(stack, extraData);
+    },
+    getDevServer: (): ReactNative.DevServerInfo => {
+      const getDevServer = require('react-native/Libraries/Core/Devtools/getDevServer');
+      return getDevServer();
+    },
+  },
+  Promise: require('react-native/Libraries/Promise'),
+  Utilities: {
+    polyfillGlobal: <T>(name: string, getValue: () => T): void => {
+      const { polyfillGlobal } = require('react-native/Libraries/Utilities/PolyfillFunctions');
+      polyfillGlobal(name, getValue);
+    },
+  },
+  ReactNativeVersion: {
+    version: RNV,
+  },
+};
diff --git a/node_modules/@sentry/react-native/src/js/utils/rnlibraries.web.ts b/node_modules/@sentry/react-native/src/js/utils/rnlibraries.web.ts
new file mode 100644
index 0000000..c861a27
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/rnlibraries.web.ts
@@ -0,0 +1,3 @@
+import type { ReactNativeLibrariesInterface } from './rnlibrariesinterface';
+
+export const ReactNativeLibraries: ReactNativeLibrariesInterface = {};
diff --git a/node_modules/@sentry/react-native/src/js/utils/rnlibrariesinterface.ts b/node_modules/@sentry/react-native/src/js/utils/rnlibrariesinterface.ts
new file mode 100644
index 0000000..eff652a
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/rnlibrariesinterface.ts
@@ -0,0 +1,31 @@
+//
+// This interface contains all of react-native internals Libraries used in Sentry RN SDK.
+//
+// Containing the internals in one place enables us to handle platforms
+// that don't have all the internals available. For example react-native-web.
+//
+
+import type { version as RNV } from 'react-native/Libraries/Core/ReactNativeVersion';
+
+import type * as ReactNative from '../vendor/react-native';
+
+export type { UnsafeObject } from 'react-native/Libraries/Types/CodegenTypes';
+export type { EmitterSubscription } from 'react-native/Libraries/vendor/emitter/EventEmitter';
+
+export interface ReactNativeLibrariesInterface {
+  Devtools?: {
+    parseErrorStack: (errorStack: string) => Array<ReactNative.StackFrame>;
+    symbolicateStackTrace: (
+      stack: Array<ReactNative.StackFrame>,
+      extraData?: Record<string, unknown>,
+    ) => Promise<ReactNative.SymbolicatedStackTrace>;
+    getDevServer: () => ReactNative.DevServerInfo;
+  };
+  Utilities?: {
+    polyfillGlobal: <T>(name: string, getValue: () => T) => void;
+  };
+  Promise?: typeof Promise;
+  ReactNativeVersion?: {
+    version: typeof RNV;
+  };
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/safe.ts b/node_modules/@sentry/react-native/src/js/utils/safe.ts
new file mode 100644
index 0000000..03dcc33
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/safe.ts
@@ -0,0 +1,59 @@
+import { logger } from '@sentry/utils';
+
+import type { ReactNativeOptions } from '../options';
+
+type DangerTypesWithoutCallSignature =
+  // eslint-disable-next-line @typescript-eslint/ban-types
+  Object | null | undefined;
+
+/**
+ * Returns callback factory wrapped with try/catch
+ * or the original passed value is it's not a function.
+ *
+ * If the factory fails original data are returned as it.
+ * They might be partially modified by the failed function.
+ */
+export function safeFactory<A extends [R, ...unknown[]], R, T extends DangerTypesWithoutCallSignature>(
+  danger: ((...args: A) => R) | T,
+  options: {
+    loggerMessage?: string;
+  } = {},
+): ((...args: A) => R) | T {
+  if (typeof danger === 'function') {
+    return (...args) => {
+      try {
+        return danger(...args);
+      } catch (error) {
+        logger.error(
+          options.loggerMessage ? options.loggerMessage : `The ${danger.name} callback threw an error`,
+          error,
+        );
+        return args[0];
+      }
+    };
+  } else {
+    return danger;
+  }
+}
+
+type TracesSampler = Required<ReactNativeOptions>['tracesSampler'];
+
+/**
+ * Returns sage tracesSampler that returns 0 if the original failed.
+ */
+export function safeTracesSampler(
+  tracesSampler: ReactNativeOptions['tracesSampler'],
+): ReactNativeOptions['tracesSampler'] {
+  if (tracesSampler) {
+    return (...args: Parameters<TracesSampler>): ReturnType<TracesSampler> => {
+      try {
+        return tracesSampler(...args);
+      } catch (error) {
+        logger.error('The tracesSampler callback threw an error', error);
+        return 0;
+      }
+    };
+  } else {
+    return tracesSampler;
+  }
+}
diff --git a/node_modules/@sentry/react-native/src/js/utils/worldwide.ts b/node_modules/@sentry/react-native/src/js/utils/worldwide.ts
new file mode 100644
index 0000000..7054537
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/utils/worldwide.ts
@@ -0,0 +1,20 @@
+import type { InternalGlobal } from '@sentry/utils';
+import { GLOBAL_OBJ } from '@sentry/utils';
+import type { ErrorUtils } from 'react-native/types';
+
+/** Internal Global object interface with common and Sentry specific properties */
+export interface ReactNativeInternalGlobal extends InternalGlobal {
+  __sentry_rn_v4_registered?: boolean;
+  __sentry_rn_v5_registered?: boolean;
+  HermesInternal?: {
+    getRuntimeProperties?: () => Record<string, string | undefined>;
+  };
+  Promise: unknown;
+  __turboModuleProxy: unknown;
+  nativeFabricUIManager: unknown;
+  ErrorUtils?: ErrorUtils;
+  expo: unknown;
+}
+
+/** Get's the global object for the current JavaScript runtime */
+export const RN_GLOBAL_OBJ = GLOBAL_OBJ as ReactNativeInternalGlobal;
diff --git a/node_modules/@sentry/react-native/src/js/vendor/base64-js/fromByteArray.ts b/node_modules/@sentry/react-native/src/js/vendor/base64-js/fromByteArray.ts
new file mode 100644
index 0000000..51c046b
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/base64-js/fromByteArray.ts
@@ -0,0 +1,73 @@
+/* eslint-disable */
+
+// The MIT License (MIT)
+
+// Copyright (c) 2014 Jameson Little
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+// Adapted from https://github.dev/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js#L119
+
+const lookup: string[] = [];
+
+const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+for (let i = 0, len = code.length; i < len; ++i) {
+  lookup[i] = code[i];
+}
+
+function tripletToBase64(num: number): string {
+  return lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f];
+}
+
+function encodeChunk(uint8: Uint8Array | number[], start: number, end: number): string {
+  let tmp;
+  const output = [];
+  for (let i = start; i < end; i += 3) {
+    tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);
+    output.push(tripletToBase64(tmp));
+  }
+  return output.join('');
+}
+
+/**
+ * Converts a Uint8Array or Array of bytes into a string representation of base64.
+ */
+export function base64StringFromByteArray(uint8: Uint8Array | number[]): string {
+  let tmp;
+  const len = uint8.length;
+  const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
+  const parts = [];
+  const maxChunkLength = 16383; // must be multiple of 3
+
+  // go through the array every three bytes, we'll deal with trailing stuff later
+  for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
+    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
+  }
+
+  // pad the end with zeros, but make sure to not forget the extra bytes
+  if (extraBytes === 1) {
+    tmp = uint8[len - 1];
+    parts.push(`${lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f]}==`);
+  } else if (extraBytes === 2) {
+    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
+    parts.push(`${lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f]}=`);
+  }
+
+  return parts.join('');
+}
diff --git a/node_modules/@sentry/react-native/src/js/vendor/base64-js/index.ts b/node_modules/@sentry/react-native/src/js/vendor/base64-js/index.ts
new file mode 100644
index 0000000..1478872
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/base64-js/index.ts
@@ -0,0 +1 @@
+export { base64StringFromByteArray } from './fromByteArray';
diff --git a/node_modules/@sentry/react-native/src/js/vendor/buffer/index.ts b/node_modules/@sentry/react-native/src/js/vendor/buffer/index.ts
new file mode 100644
index 0000000..86753dd
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/buffer/index.ts
@@ -0,0 +1 @@
+export { utf8ToBytes } from './utf8ToBytes';
diff --git a/node_modules/@sentry/react-native/src/js/vendor/buffer/utf8ToBytes.ts b/node_modules/@sentry/react-native/src/js/vendor/buffer/utf8ToBytes.ts
new file mode 100644
index 0000000..a8a743f
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/buffer/utf8ToBytes.ts
@@ -0,0 +1,101 @@
+// Adapted from https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L1956
+
+// The MIT License (MIT)
+
+// Copyright (c) Feross Aboukhadijeh, and other contributors.
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+/* eslint-disable */
+
+/**
+ * Convert a string to a byte array
+ */
+export function utf8ToBytes(string: string, units?: number): number[] {
+  units = units || Infinity;
+  let codePoint;
+  const length = string.length;
+  let leadSurrogate = null;
+  const bytes: number[] = [];
+
+  for (let i = 0; i < length; ++i) {
+    codePoint = string.charCodeAt(i);
+
+    // is surrogate component
+    if (codePoint > 0xd7ff && codePoint < 0xe000) {
+      // last char was a lead
+      if (!leadSurrogate) {
+        // no lead yet
+        if (codePoint > 0xdbff) {
+          // unexpected trail
+          if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
+          continue;
+        } else if (i + 1 === length) {
+          // unpaired lead
+          if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
+          continue;
+        }
+
+        // valid lead
+        leadSurrogate = codePoint;
+
+        continue;
+      }
+
+      // 2 leads in a row
+      if (codePoint < 0xdc00) {
+        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
+        leadSurrogate = codePoint;
+        continue;
+      }
+
+      // valid surrogate pair
+      codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
+    } else if (leadSurrogate) {
+      // valid bmp char, but last char was a lead
+      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
+    }
+
+    leadSurrogate = null;
+
+    // encode utf8
+    if (codePoint < 0x80) {
+      if ((units -= 1) < 0) break;
+      bytes.push(codePoint);
+    } else if (codePoint < 0x800) {
+      if ((units -= 2) < 0) break;
+      bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
+    } else if (codePoint < 0x10000) {
+      if ((units -= 3) < 0) break;
+      bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
+    } else if (codePoint < 0x110000) {
+      if ((units -= 4) < 0) break;
+      bytes.push(
+        (codePoint >> 0x12) | 0xf0,
+        ((codePoint >> 0xc) & 0x3f) | 0x80,
+        ((codePoint >> 0x6) & 0x3f) | 0x80,
+        (codePoint & 0x3f) | 0x80,
+      );
+    } else {
+      throw new Error('Invalid code point');
+    }
+  }
+
+  return bytes;
+}
diff --git a/node_modules/@sentry/react-native/src/js/vendor/index.ts b/node_modules/@sentry/react-native/src/js/vendor/index.ts
new file mode 100644
index 0000000..457b843
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/index.ts
@@ -0,0 +1,3 @@
+export { utf8ToBytes } from './buffer';
+export * from './react-native';
+export { base64StringFromByteArray } from './base64-js';
diff --git a/node_modules/@sentry/react-native/src/js/vendor/react-native/index.ts b/node_modules/@sentry/react-native/src/js/vendor/react-native/index.ts
new file mode 100644
index 0000000..d3affa0
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/vendor/react-native/index.ts
@@ -0,0 +1,55 @@
+// MIT License
+
+// Copyright (c) Meta Platforms, Inc. and affiliates.
+
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+// Adapted from https://github.com/facebook/react-native/blob/d09c02f9e2d468e4d0bde51890e312ae7003a3e6/packages/react-native/Libraries/Core/NativeExceptionsManager.js#L17
+export type StackFrame = {
+  column?: number;
+  file?: string;
+  lineNumber?: number;
+  methodName: string;
+  collapse?: boolean;
+};
+
+// Adapted from https://github.com/facebook/react-native/blob/d09c02f9e2d468e4d0bde51890e312ae7003a3e6/packages/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js#L17
+export type CodeFrame = Readonly<{
+  content: string;
+  location?: {
+    [key: string]: unknown;
+    row: number;
+    column: number;
+  };
+  fileName: string;
+}>;
+
+// Adapted from https://github.com/facebook/react-native/blob/d09c02f9e2d468e4d0bde51890e312ae7003a3e6/packages/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js#L27
+export type SymbolicatedStackTrace = Readonly<{
+  stack: Array<StackFrame>;
+  codeFrame?: CodeFrame;
+}>;
+
+// Adapted from https://github.com/facebook/react-native/blob/d09c02f9e2d468e4d0bde51890e312ae7003a3e6/packages/react-native/Libraries/Core/Devtools/getDevServer.js#L17
+export type DevServerInfo = {
+  [key: string]: unknown;
+  url: string;
+  fullBundleUrl?: string;
+  bundleLoadedFromServer: boolean;
+};
diff --git a/node_modules/@sentry/react-native/src/js/version.ts b/node_modules/@sentry/react-native/src/js/version.ts
new file mode 100644
index 0000000..1b338ac
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/version.ts
@@ -0,0 +1,3 @@
+export const SDK_PACKAGE_NAME = 'npm:@sentry/react-native';
+export const SDK_NAME = 'sentry.javascript.react-native';
+export const SDK_VERSION = '5.16.0-alpha.2';
diff --git a/node_modules/@sentry/react-native/src/js/wrapper.ts b/node_modules/@sentry/react-native/src/js/wrapper.ts
new file mode 100644
index 0000000..b108a84
--- /dev/null
+++ b/node_modules/@sentry/react-native/src/js/wrapper.ts
@@ -0,0 +1,665 @@
+/* eslint-disable max-lines */
+import type {
+  BaseEnvelopeItemHeaders,
+  Breadcrumb,
+  Envelope,
+  EnvelopeItem,
+  Event,
+  Package,
+  SeverityLevel,
+  User,
+} from '@sentry/types';
+import { logger, normalize, SentryError } from '@sentry/utils';
+import { NativeModules, Platform, TurboModuleRegistry } from 'react-native';
+
+import { isHardCrash } from './misc';
+import type {
+  NativeAppStartResponse,
+  NativeDeviceContextsResponse,
+  NativeFramesResponse,
+  NativeReleaseResponse,
+  NativeScreenshot,
+  NativeStackFrames,
+  Spec,
+} from './NativeRNSentry';
+import type { ReactNativeClientOptions } from './options';
+import type * as Hermes from './profiling/hermes';
+import type { NativeProfileEvent } from './profiling/nativeTypes';
+import type { RequiredKeysUser } from './user';
+import { isTurboModuleEnabled } from './utils/environment';
+import { base64StringFromByteArray, utf8ToBytes } from './vendor';
+
+const RNSentry: Spec | undefined = isTurboModuleEnabled()
+  ? TurboModuleRegistry.get<Spec>('RNSentry')
+  : NativeModules.RNSentry;
+
+export interface Screenshot {
+  data: Uint8Array;
+  contentType: string;
+  filename: string;
+}
+
+interface SentryNativeWrapper {
+  enableNative: boolean;
+  nativeIsReady: boolean;
+  platform: typeof Platform.OS;
+
+  _NativeClientError: Error;
+  _DisabledNativeError: Error;
+
+  _processItem(envelopeItem: EnvelopeItem): EnvelopeItem;
+  _processLevels(event: Event): Event;
+  _processLevel(level: SeverityLevel): SeverityLevel;
+  _serializeObject(data: { [key: string]: unknown }): { [key: string]: string };
+  _isModuleLoaded(module: Spec | undefined): module is Spec;
+
+  isNativeAvailable(): boolean;
+
+  initNativeSdk(options: Partial<ReactNativeClientOptions>): PromiseLike<boolean>;
+  closeNativeSdk(): PromiseLike<void>;
+
+  sendEnvelope(envelope: Envelope): Promise<void>;
+  captureScreenshot(): Promise<Screenshot[] | null>;
+
+  fetchNativeRelease(): PromiseLike<NativeReleaseResponse>;
+  fetchNativeDeviceContexts(): PromiseLike<NativeDeviceContextsResponse | null>;
+  fetchNativeAppStart(): PromiseLike<NativeAppStartResponse | null>;
+  fetchNativeFrames(): PromiseLike<NativeFramesResponse | null>;
+  fetchNativeSdkInfo(): PromiseLike<Package | null>;
+
+  disableNativeFramesTracking(): void;
+  enableNativeFramesTracking(): void;
+
+  addBreadcrumb(breadcrumb: Breadcrumb): void;
+  setContext(key: string, context: { [key: string]: unknown } | null): void;
+  clearBreadcrumbs(): void;
+  setExtra(key: string, extra: unknown): void;
+  setUser(user: User | null): void;
+  setTag(key: string, value: string): void;
+
+  nativeCrash(): void;
+
+  fetchModules(): Promise<Record<string, string> | null>;
+  fetchViewHierarchy(): PromiseLike<Uint8Array | null>;
+
+  startProfiling(): boolean;
+  stopProfiling(): { hermesProfile: Hermes.Profile; nativeProfile?: NativeProfileEvent } | null;
+
+  fetchNativePackageName(): Promise<string | null>;
+
+  /**
+   * Fetches native stack frames and debug images for the instructions addresses.
+   */
+  fetchNativeStackFramesBy(instructionsAddr: number[]): Promise<NativeStackFrames | null>;
+}
+
+const EOL = utf8ToBytes('\n');
+
+/**
+ * Our internal interface for calling native functions
+ */
+export const NATIVE: SentryNativeWrapper = {
+  async fetchModules(): Promise<Record<string, string> | null> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const raw = await RNSentry.fetchModules();
+    if (raw) {
+      return JSON.parse(raw);
+    }
+    return null;
+  },
+  /**
+   * Sending the envelope over the bridge to native
+   * @param envelope Envelope
+   */
+  async sendEnvelope(envelope: Envelope): Promise<void> {
+    if (!this.enableNative) {
+      logger.warn('Event was skipped as native SDK is not enabled.');
+      return;
+    }
+
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const [envelopeHeader, envelopeItems] = envelope;
+
+    const headerString = JSON.stringify(envelopeHeader);
+    const headerBytes = utf8ToBytes(headerString);
+    let envelopeBytes: Uint8Array = new Uint8Array(headerBytes.length + EOL.length);
+    envelopeBytes.set(headerBytes);
+    envelopeBytes.set(EOL, headerBytes.length);
+
+    let hardCrashed: boolean = false;
+    for (const rawItem of envelopeItems) {
+      const [itemHeader, itemPayload] = this._processItem(rawItem);
+
+      let bytesContentType: string;
+      let bytesPayload: number[] | Uint8Array | undefined;
+      if (typeof itemPayload === 'string') {
+        bytesContentType = 'text/plain';
+        bytesPayload = utf8ToBytes(itemPayload);
+      } else if (itemPayload instanceof Uint8Array) {
+        bytesContentType =
+          typeof itemHeader.content_type === 'string' ? itemHeader.content_type : 'application/octet-stream';
+        bytesPayload = itemPayload;
+      } else {
+        bytesContentType = 'application/json';
+        bytesPayload = utf8ToBytes(JSON.stringify(itemPayload));
+        if (!hardCrashed) {
+          hardCrashed = isHardCrash(itemPayload);
+        }
+      }
+
+      // Content type is not inside BaseEnvelopeItemHeaders.
+      (itemHeader as BaseEnvelopeItemHeaders).content_type = bytesContentType;
+      (itemHeader as BaseEnvelopeItemHeaders).length = bytesPayload.length;
+      const serializedItemHeader = JSON.stringify(itemHeader);
+
+      const bytesItemHeader = utf8ToBytes(serializedItemHeader);
+      const newBytes = new Uint8Array(
+        envelopeBytes.length + bytesItemHeader.length + EOL.length + bytesPayload.length + EOL.length,
+      );
+      newBytes.set(envelopeBytes);
+      newBytes.set(bytesItemHeader, envelopeBytes.length);
+      newBytes.set(EOL, envelopeBytes.length + bytesItemHeader.length);
+      newBytes.set(bytesPayload, envelopeBytes.length + bytesItemHeader.length + EOL.length);
+      newBytes.set(EOL, envelopeBytes.length + bytesItemHeader.length + EOL.length + bytesPayload.length);
+      envelopeBytes = newBytes;
+    }
+
+    await RNSentry.captureEnvelope(base64StringFromByteArray(envelopeBytes), { store: hardCrashed });
+  },
+
+  /**
+   * Starts native with the provided options.
+   * @param options ReactNativeClientOptions
+   */
+  async initNativeSdk(originalOptions: Partial<ReactNativeClientOptions>): Promise<boolean> {
+    const options: Partial<ReactNativeClientOptions> = {
+      enableNative: true,
+      autoInitializeNativeSdk: true,
+      ...originalOptions,
+    };
+
+    if (!options.enableNative) {
+      if (options.enableNativeNagger) {
+        logger.warn('Note: Native Sentry SDK is disabled.');
+      }
+      this.enableNative = false;
+      return false;
+    }
+    if (!options.autoInitializeNativeSdk) {
+      if (options.enableNativeNagger) {
+        logger.warn(
+          'Note: Native Sentry SDK was not initialized automatically, you will need to initialize it manually. If you wish to disable the native SDK and get rid of this warning, pass enableNative: false',
+        );
+      }
+      this.enableNative = true;
+      return false;
+    }
+
+    if (!options.dsn) {
+      logger.warn(
+        'Warning: No DSN was provided. The Sentry SDK will be disabled. Native SDK will also not be initalized.',
+      );
+      this.enableNative = false;
+      return false;
+    }
+
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    // filter out all the options that would crash native.
+    /* eslint-disable @typescript-eslint/unbound-method,@typescript-eslint/no-unused-vars */
+    const { beforeSend, beforeBreadcrumb, beforeSendTransaction, integrations, ...filteredOptions } = options;
+    /* eslint-enable @typescript-eslint/unbound-method,@typescript-eslint/no-unused-vars */
+    const nativeIsReady = await RNSentry.initNativeSdk(filteredOptions);
+
+    this.nativeIsReady = nativeIsReady;
+    this.enableNative = true;
+
+    return nativeIsReady;
+  },
+
+  /**
+   * Fetches the release from native
+   */
+  async fetchNativeRelease(): Promise<NativeReleaseResponse> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    return RNSentry.fetchNativeRelease();
+  },
+
+  /**
+   * Fetches the Sdk info for the native sdk.
+   */
+  async fetchNativeSdkInfo(): Promise<Package | null> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    return RNSentry.fetchNativeSdkInfo();
+  },
+
+  /**
+   * Fetches the device contexts. Not used on Android.
+   */
+  async fetchNativeDeviceContexts(): Promise<NativeDeviceContextsResponse | null> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    return RNSentry.fetchNativeDeviceContexts();
+  },
+
+  async fetchNativeAppStart(): Promise<NativeAppStartResponse | null> {
+    if (!this.enableNative) {
+      logger.warn(this._DisabledNativeError);
+      return null;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      logger.error(this._NativeClientError);
+      return null;
+    }
+
+    return RNSentry.fetchNativeAppStart();
+  },
+
+  async fetchNativeFrames(): Promise<NativeFramesResponse | null> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    return RNSentry.fetchNativeFrames();
+  },
+
+  /**
+   * Triggers a native crash.
+   * Use this only for testing purposes.
+   */
+  nativeCrash(): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    RNSentry.crash();
+  },
+
+  /**
+   * Sets the user in the native scope.
+   * Passing null clears the user.
+   */
+  setUser(user: User | null): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    // separate and serialize all non-default user keys.
+    let userKeys = null;
+    let userDataKeys = null;
+    if (user) {
+      const { id, ip_address, email, username, segment, ...otherKeys } = user;
+      const requiredUser: RequiredKeysUser = {
+        id,
+        ip_address,
+        email,
+        username,
+        segment,
+      };
+      userKeys = this._serializeObject(requiredUser);
+      userDataKeys = this._serializeObject(otherKeys);
+    }
+
+    RNSentry.setUser(userKeys, userDataKeys);
+  },
+
+  /**
+   * Sets a tag in the native module.
+   * @param key string
+   * @param value string
+   */
+  setTag(key: string, value: string): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const stringifiedValue = typeof value === 'string' ? value : JSON.stringify(value);
+
+    RNSentry.setTag(key, stringifiedValue);
+  },
+
+  /**
+   * Sets an extra in the native scope, will stringify
+   * extra value if it isn't already a string.
+   * @param key string
+   * @param extra any
+   */
+  setExtra(key: string, extra: unknown): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    // we stringify the extra as native only takes in strings.
+    const stringifiedExtra = typeof extra === 'string' ? extra : JSON.stringify(extra);
+
+    RNSentry.setExtra(key, stringifiedExtra);
+  },
+
+  /**
+   * Adds breadcrumb to the native scope.
+   * @param breadcrumb Breadcrumb
+   */
+  addBreadcrumb(breadcrumb: Breadcrumb): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    RNSentry.addBreadcrumb({
+      ...breadcrumb,
+      // Process and convert deprecated levels
+      level: breadcrumb.level ? this._processLevel(breadcrumb.level) : undefined,
+    });
+  },
+
+  /**
+   * Clears breadcrumbs on the native scope.
+   */
+  clearBreadcrumbs(): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    RNSentry.clearBreadcrumbs();
+  },
+
+  /**
+   * Sets context on the native scope. Not implemented in Android yet.
+   * @param key string
+   * @param context key-value map
+   */
+  setContext(key: string, context: { [key: string]: unknown } | null): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    RNSentry.setContext(key, context !== null ? normalize(context) : null);
+  },
+
+  /**
+   * Closes the Native Layer SDK
+   */
+  async closeNativeSdk(): Promise<void> {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      return;
+    }
+
+    return RNSentry.closeNativeSdk().then(() => {
+      this.enableNative = false;
+    });
+  },
+
+  disableNativeFramesTracking(): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      return;
+    }
+
+    RNSentry.disableNativeFramesTracking();
+  },
+
+  enableNativeFramesTracking(): void {
+    if (!this.enableNative) {
+      return;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      return;
+    }
+
+    RNSentry.enableNativeFramesTracking();
+  },
+
+  isNativeAvailable(): boolean {
+    return this._isModuleLoaded(RNSentry);
+  },
+
+  async captureScreenshot(): Promise<Screenshot[] | null> {
+    if (!this.enableNative) {
+      logger.warn(this._DisabledNativeError);
+      return null;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      logger.error(this._NativeClientError);
+      return null;
+    }
+
+    let raw: NativeScreenshot[] | null | undefined;
+    try {
+      raw = await RNSentry.captureScreenshot();
+    } catch (e) {
+      logger.warn('Failed to capture screenshot', e);
+    }
+
+    if (raw) {
+      return raw.map((item: NativeScreenshot) => ({
+        ...item,
+        data: new Uint8Array(item.data),
+      }));
+    } else {
+      return null;
+    }
+  },
+
+  async fetchViewHierarchy(): Promise<Uint8Array | null> {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const raw = await RNSentry.fetchViewHierarchy();
+    return raw ? new Uint8Array(raw) : null;
+  },
+
+  startProfiling(): boolean {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const { started, error } = RNSentry.startProfiling();
+    if (started) {
+      logger.log('[NATIVE] Start Profiling');
+    } else {
+      logger.error('[NATIVE] Start Profiling Failed', error);
+    }
+
+    return !!started;
+  },
+
+  stopProfiling(): { hermesProfile: Hermes.Profile; nativeProfile?: NativeProfileEvent } | null {
+    if (!this.enableNative) {
+      throw this._DisabledNativeError;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      throw this._NativeClientError;
+    }
+
+    const { profile, nativeProfile, error } = RNSentry.stopProfiling();
+    if (!profile || error) {
+      logger.error('[NATIVE] Stop Profiling Failed', error);
+      return null;
+    }
+    if (Platform.OS === 'ios' && !nativeProfile) {
+      logger.warn('[NATIVE] Stop Profiling Failed: No Native Profile');
+    }
+
+    try {
+      return {
+        hermesProfile: JSON.parse(profile) as Hermes.Profile,
+        nativeProfile: nativeProfile as NativeProfileEvent | undefined,
+      };
+    } catch (e) {
+      logger.error('[NATIVE] Failed to parse Hermes Profile JSON', e);
+      return null;
+    }
+  },
+
+  async fetchNativePackageName(): Promise<string | null> {
+    if (!this.enableNative) {
+      return null;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      return null;
+    }
+
+    return (await RNSentry.fetchNativePackageName()) || null;
+  },
+
+  async fetchNativeStackFramesBy(instructionsAddr: number[]): Promise<NativeStackFrames | null> {
+    if (!this.enableNative) {
+      return null;
+    }
+    if (!this._isModuleLoaded(RNSentry)) {
+      return null;
+    }
+
+    return (await RNSentry.fetchNativeStackFramesBy(instructionsAddr)) || null;
+  },
+
+  /**
+   * Gets the event from envelopeItem and applies the level filter to the selected event.
+   * @param data An envelope item containing the event.
+   * @returns The event from envelopeItem or undefined.
+   */
+  _processItem(item: EnvelopeItem): EnvelopeItem {
+    const [itemHeader, itemPayload] = item;
+
+    if (itemHeader.type == 'event' || itemHeader.type == 'transaction') {
+      const event = this._processLevels(itemPayload as Event);
+
+      if (NATIVE.platform === 'android') {
+        if ('message' in event) {
+          // @ts-expect-error Android still uses the old message object, without this the serialization of events will break.
+          event.message = { message: event.message };
+        }
+      }
+
+      return [itemHeader, event];
+    }
+
+    return item;
+  },
+
+  /**
+   * Serializes all values of root-level keys into strings.
+   * @param data key-value map.
+   * @returns An object where all root-level values are strings.
+   */
+  _serializeObject(data: { [key: string]: unknown }): { [key: string]: string } {
+    const serialized: { [key: string]: string } = {};
+
+    Object.keys(data).forEach(dataKey => {
+      const value = data[dataKey];
+      serialized[dataKey] = typeof value === 'string' ? value : JSON.stringify(value);
+    });
+
+    return serialized;
+  },
+
+  /**
+   * Convert js severity level in event.level and event.breadcrumbs to more widely supported levels.
+   * @param event
+   * @returns Event with more widely supported Severity level strings
+   */
+
+  _processLevels(event: Event): Event {
+    const processed: Event = {
+      ...event,
+      level: event.level ? this._processLevel(event.level) : undefined,
+      breadcrumbs: event.breadcrumbs?.map(breadcrumb => ({
+        ...breadcrumb,
+        level: breadcrumb.level ? this._processLevel(breadcrumb.level) : undefined,
+      })),
+    };
+
+    return processed;
+  },
+
+  /**
+   * Convert js severity level which has critical and log to more widely supported levels.
+   * @param level
+   * @returns More widely supported Severity level strings
+   */
+
+  _processLevel(level: SeverityLevel): SeverityLevel {
+    if (level == ('log' as SeverityLevel)) {
+      return 'debug' as SeverityLevel;
+    }
+    return level;
+  },
+
+  /**
+   * Checks whether the RNSentry module is loaded.
+   */
+  _isModuleLoaded(module: Spec | undefined): module is Spec {
+    return !!module;
+  },
+
+  _DisabledNativeError: new SentryError('Native is disabled'),
+
+  _NativeClientError: new SentryError("Native Client is not available, can't start on native."),
+
+  enableNative: true,
+  nativeIsReady: false,
+  platform: Platform.OS,
+};
