diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/NotificationsPackage.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/NotificationsPackage.java
index 344d8c3..45c1742 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/NotificationsPackage.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/NotificationsPackage.java
@@ -3,24 +3,34 @@ package expo.modules.notifications;
 import android.content.Context;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import expo.modules.core.BasePackage;
 import expo.modules.core.ExportedModule;
 import expo.modules.core.interfaces.InternalModule;
+import expo.modules.core.interfaces.ReactActivityLifecycleListener;
 import expo.modules.core.interfaces.SingletonModule;
 import expo.modules.notifications.notifications.NotificationManager;
 import expo.modules.notifications.notifications.categories.ExpoNotificationCategoriesModule;
 import expo.modules.notifications.notifications.categories.serializers.ExpoNotificationsCategoriesSerializer;
 import expo.modules.notifications.notifications.channels.AndroidXNotificationsChannelsProvider;
+import expo.modules.notifications.service.delegates.ExpoNotificationLifecycleListener;
 import expo.modules.notifications.tokens.PushTokenManager;
 
 public class NotificationsPackage extends BasePackage {
+
+  private NotificationManager mNotificationManager;
+
+  public NotificationsPackage() {
+    mNotificationManager = new NotificationManager();
+  }
+
   @Override
   public List<SingletonModule> createSingletonModules(Context context) {
     return Arrays.asList(
       new PushTokenManager(),
-      new NotificationManager()
+      mNotificationManager
     );
   }
 
@@ -31,4 +41,10 @@ public class NotificationsPackage extends BasePackage {
       new ExpoNotificationsCategoriesSerializer()
     );
   }
+
+  @Override
+  public List<ReactActivityLifecycleListener> createReactActivityLifecycleListeners(Context activityContext) {
+    return Collections.singletonList(new ExpoNotificationLifecycleListener(activityContext, mNotificationManager));
+  }
 }
+
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/badge/BadgeHelper.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/badge/BadgeHelper.kt
index 63a46c5..22322f3 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/badge/BadgeHelper.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/badge/BadgeHelper.kt
@@ -12,7 +12,12 @@ object BadgeHelper {
 
   fun setBadgeCount(context: Context, badgeCount: Int): Boolean {
     return try {
-      ShortcutBadger.applyCountOrThrow(context.applicationContext, badgeCount)
+      if (badgeCount == 0) {
+        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
+        notificationManager.cancelAll()
+      } else {
+        ShortcutBadger.applyCountOrThrow(context.applicationContext, badgeCount)
+      }
       BadgeHelper.badgeCount = badgeCount
       true
     } catch (e: ShortcutBadgeException) {
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationManager.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationManager.java
index 88da825..867c70d 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationManager.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationManager.java
@@ -1,5 +1,8 @@
 package expo.modules.notifications.notifications;
 
+import android.os.Bundle;
+import android.util.Log;
+
 import expo.modules.core.interfaces.SingletonModule;
 
 import java.lang.ref.WeakReference;
@@ -22,6 +25,7 @@ public class NotificationManager implements SingletonModule, expo.modules.notifi
    */
   private WeakHashMap<NotificationListener, WeakReference<NotificationListener>> mListenerReferenceMap;
   private Collection<NotificationResponse> mPendingNotificationResponses = new ArrayList<>();
+  private Collection<Bundle> mPendingNotificationResponsesFromExtras = new ArrayList<>();
 
   public NotificationManager() {
     mListenerReferenceMap = new WeakHashMap<>();
@@ -53,6 +57,11 @@ public class NotificationManager implements SingletonModule, expo.modules.notifi
           listener.onNotificationResponseReceived(pendingResponse);
         }
       }
+      if (!mPendingNotificationResponsesFromExtras.isEmpty()) {
+        for (Bundle extras : mPendingNotificationResponsesFromExtras) {
+          listener.onNotificationResponseIntentReceived(extras);
+        }
+      }
     }
   }
 
@@ -116,4 +125,28 @@ public class NotificationManager implements SingletonModule, expo.modules.notifi
       }
     }
   }
+
+ public void onNotificationResponseFromExtras(Bundle extras) {
+    // We're going to be passed in extras from either
+    // a killed state (ExpoNotificationLifecycleListener::onCreate)
+    // OR a background state (ExpoNotificationLifecycleListener::onNewIntent)
+
+    // If we've just come from a background state, we'll have listeners set up
+    // pass on the notification to them
+    if (!mListenerReferenceMap.isEmpty()) {
+      for (WeakReference<NotificationListener> listenerReference : mListenerReferenceMap.values()) {
+        NotificationListener listener = listenerReference.get();
+        if (listener != null) {
+          listener.onNotificationResponseIntentReceived(extras);
+        }
+      }
+    } else {
+      // Otherwise, the app has been launched from a killed state, and our listeners
+      // haven't yet been setup. We'll add this to a list of pending notifications
+      // for them to process once they've been initialized.
+      if (mPendingNotificationResponsesFromExtras.isEmpty()) {
+        mPendingNotificationResponsesFromExtras.add(extras);
+      }
+    }
+  }
 }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
index fd04a2e..53316ca 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
@@ -3,9 +3,9 @@ package expo.modules.notifications.notifications;
 import android.os.Build;
 import android.os.Bundle;
 
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
+import org.jetbrains.annotations.NotNull;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import expo.modules.core.arguments.MapArguments;
@@ -19,16 +19,12 @@ import java.util.Set;
 
 import expo.modules.notifications.notifications.interfaces.NotificationTrigger;
 import expo.modules.notifications.notifications.model.Notification;
-import expo.modules.notifications.notifications.model.NotificationAction;
-import expo.modules.notifications.notifications.model.NotificationCategory;
 import expo.modules.notifications.notifications.model.NotificationContent;
 import expo.modules.notifications.notifications.model.NotificationRequest;
 import expo.modules.notifications.notifications.model.NotificationResponse;
-import expo.modules.notifications.notifications.model.TextInputNotificationAction;
 import expo.modules.notifications.notifications.model.TextInputNotificationResponse;
 import expo.modules.notifications.notifications.model.triggers.FirebaseNotificationTrigger;
 
-import expo.modules.notifications.notifications.triggers.ChannelAwareTrigger;
 import expo.modules.notifications.notifications.triggers.DailyTrigger;
 import expo.modules.notifications.notifications.triggers.DateTrigger;
 import expo.modules.notifications.notifications.triggers.TimeIntervalTrigger;
@@ -199,4 +195,31 @@ public class NotificationSerializer {
     }
     return null;
   }
+
+    @NotNull
+    public static Bundle toResponseBundleFromExtras(Bundle extras) {
+      Bundle serializedContent = new Bundle();
+      serializedContent.putString("title", extras.getString("title"));
+      serializedContent.putString("body", extras.getString("message"));
+      serializedContent.putString("dataString", extras.getString("body"));
+
+      Bundle serializedTrigger = new Bundle();
+      serializedTrigger.putString("type", "push");
+      serializedTrigger.putString("channelId", extras.getString("channelId"));
+
+      Bundle serializedRequest = new Bundle();
+      serializedRequest.putString("identifier", extras.getString("google.message_id"));
+      serializedRequest.putBundle("trigger", serializedTrigger);
+      serializedRequest.putBundle("content", serializedContent);
+
+      Bundle serializedNotification = new Bundle();
+      serializedNotification.putLong("date", extras.getLong("google.sent_time"));
+      serializedNotification.putBundle("request", serializedRequest);
+
+      Bundle serializedResponse = new Bundle();
+      serializedResponse.putString("actionIdentifier", "expo.modules.notifications.actions.DEFAULT");
+      serializedResponse.putBundle("notification", serializedNotification);
+
+      return serializedResponse;
+    }
 }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
index 377410b..ad486cc 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
@@ -1,10 +1,8 @@
 package expo.modules.notifications.notifications.emitting
 
 import android.os.Bundle
-import expo.modules.core.interfaces.services.EventEmitter
 import expo.modules.kotlin.modules.Module
 import expo.modules.kotlin.modules.ModuleDefinition
-import expo.modules.notifications.ModuleNotFoundException
 import expo.modules.notifications.notifications.NotificationSerializer
 import expo.modules.notifications.notifications.interfaces.NotificationListener
 import expo.modules.notifications.notifications.interfaces.NotificationManager
@@ -17,8 +15,7 @@ private const val MESSAGES_DELETED_EVENT_NAME = "onNotificationsDeleted"
 
 open class NotificationsEmitter : Module(), NotificationListener {
   private lateinit var notificationManager: NotificationManager
-  private var lastNotificationResponse: NotificationResponse? = null
-  private var eventEmitter: EventEmitter? = null
+  private var lastNotificationResponseBundle: Bundle? = null
 
   override fun definition() = ModuleDefinition {
     Name("ExpoNotificationsEmitter")
@@ -30,9 +27,6 @@ open class NotificationsEmitter : Module(), NotificationListener {
     )
 
     OnCreate {
-      eventEmitter = appContext.legacyModule<EventEmitter>()
-        ?: throw ModuleNotFoundException(EventEmitter::class)
-
       // Register the module as a listener in NotificationManager singleton module.
       // Deregistration happens in onDestroy callback.
       notificationManager = requireNotNull(appContext.legacyModuleRegistry.getSingletonModule("NotificationManager", NotificationManager::class.java))
@@ -44,7 +38,7 @@ open class NotificationsEmitter : Module(), NotificationListener {
     }
 
     AsyncFunction("getLastNotificationResponseAsync") {
-      lastNotificationResponse?.let(NotificationSerializer::toBundle)
+      lastNotificationResponseBundle
     }
   }
 
@@ -55,7 +49,7 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @param notification Notification received
    */
   override fun onNotificationReceived(notification: Notification) {
-    eventEmitter?.emit(NEW_MESSAGE_EVENT_NAME, NotificationSerializer.toBundle(notification))
+    sendEvent(NEW_MESSAGE_EVENT_NAME, NotificationSerializer.toBundle(notification))
   }
 
   /**
@@ -66,12 +60,14 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @return Whether notification has been handled
    */
   override fun onNotificationResponseReceived(response: NotificationResponse): Boolean {
-    lastNotificationResponse = response
-    eventEmitter?.let {
-      it.emit(NEW_RESPONSE_EVENT_NAME, NotificationSerializer.toBundle(response))
-      return true
-    }
-    return false
+    lastNotificationResponseBundle = NotificationSerializer.toBundle(response)
+    sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
+    return true
+  }
+
+  override fun onNotificationResponseIntentReceived(extras: Bundle?) {
+    lastNotificationResponseBundle = NotificationSerializer.toResponseBundleFromExtras(extras)
+    sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
   }
 
   /**
@@ -79,6 +75,6 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * Emits a [MESSAGES_DELETED_EVENT_NAME] event.
    */
   override fun onNotificationsDropped() {
-    eventEmitter?.emit(MESSAGES_DELETED_EVENT_NAME, Bundle.EMPTY)
+    sendEvent(MESSAGES_DELETED_EVENT_NAME, Bundle.EMPTY)
   }
 }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/NotificationsHandler.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/NotificationsHandler.kt
index d06a818..f76bbb2 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/NotificationsHandler.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/NotificationsHandler.kt
@@ -115,7 +115,13 @@ open class NotificationsHandler : Module(), NotificationListener {
    */
   override fun onNotificationReceived(notification: Notification) {
     val context = appContext.reactContext ?: return
-    val task = SingleNotificationHandlerTask(context, handler, moduleRegistry, notification, this)
+    val task = SingleNotificationHandlerTask(
+      context,
+      appContext.eventEmitter(this),
+      handler,
+      notification,
+      this
+    )
     tasksMap[task.identifier] = task
     task.start()
   }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/SingleNotificationHandlerTask.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/SingleNotificationHandlerTask.java
index 2b90e00..e7080d7 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/SingleNotificationHandlerTask.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/handling/SingleNotificationHandlerTask.java
@@ -5,10 +5,8 @@ import android.os.Bundle;
 import android.os.Handler;
 import android.os.ResultReceiver;
 
-import expo.modules.core.ModuleRegistry;
 import expo.modules.core.Promise;
 import expo.modules.core.interfaces.services.EventEmitter;
-
 import expo.modules.notifications.notifications.NotificationSerializer;
 import expo.modules.notifications.notifications.model.Notification;
 import expo.modules.notifications.notifications.model.NotificationBehavior;
@@ -42,10 +40,16 @@ public class SingleNotificationHandlerTask {
 
   private Runnable mTimeoutRunnable = SingleNotificationHandlerTask.this::handleTimeout;
 
-  /* package */ SingleNotificationHandlerTask(Context context, Handler handler, ModuleRegistry moduleRegistry, Notification notification, NotificationsHandler delegate) {
+  /* package */ SingleNotificationHandlerTask(
+    Context context,
+    EventEmitter eventEmitter,
+    Handler handler,
+    Notification notification,
+    NotificationsHandler delegate
+  ) {
     mContext = context;
     mHandler = handler;
-    mEventEmitter = moduleRegistry.getModule(EventEmitter.class);
+    mEventEmitter = eventEmitter;
     mNotification = notification;
     mDelegate = delegate;
   }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/interfaces/NotificationListener.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/interfaces/NotificationListener.java
index 7b1add7..e22ec26 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/interfaces/NotificationListener.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/interfaces/NotificationListener.java
@@ -1,5 +1,7 @@
 package expo.modules.notifications.notifications.interfaces;
 
+import android.os.Bundle;
+
 import com.google.firebase.messaging.FirebaseMessagingService;
 
 import expo.modules.notifications.notifications.model.Notification;
@@ -28,6 +30,14 @@ public interface NotificationListener {
     return false;
   }
 
+  /**
+   * Callback called when notification response is received through package lifecycle listeners
+   *
+   * @param extras Bundle of extras from the lifecycle method
+   */
+  default void onNotificationResponseIntentReceived(Bundle extras) {
+  }
+
   /**
    * Callback called when some notifications are dropped.
    * See {@link FirebaseMessagingService#onDeletedMessages()}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java
new file mode 100644
index 0000000..77591a5
--- /dev/null
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java
@@ -0,0 +1,75 @@
+package expo.modules.notifications.service.delegates;
+
+import android.app.Activity;
+import android.app.NotificationChannel;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.util.Log;
+
+import androidx.core.app.NotificationCompat;
+
+import java.util.Objects;
+
+import expo.modules.core.interfaces.ReactActivityLifecycleListener;
+import expo.modules.notifications.notifications.NotificationManager;
+import expo.modules.notifications.notifications.model.Notification;
+import expo.modules.notifications.notifications.model.NotificationResponse;
+
+public class ExpoNotificationLifecycleListener implements ReactActivityLifecycleListener {
+
+    private NotificationManager mNotificationManager;
+
+    public ExpoNotificationLifecycleListener(Context context, NotificationManager notificationManager) {
+      mNotificationManager = notificationManager;
+    }
+
+    /**
+     * This will be triggered if the app is not running,
+     * and is started from clicking on a notification.
+     * <p>
+     * Notification data will be in activity.intent.extras
+     *
+     * @param activity
+     * @param savedInstanceState
+     */
+    @Override
+    public void onCreate(Activity activity, Bundle savedInstanceState) {
+        Intent intent = activity.getIntent();
+        if (intent != null) {
+            Bundle extras = intent.getExtras();
+            if (extras != null) {
+                if (extras.containsKey("notificationResponse")) {
+                    Log.d("ReactNativeJS", "[native] ExpoNotificationLifecycleListener contains an unmarshaled notification response. Skipping.");
+                    return;
+                }
+                mNotificationManager.onNotificationResponseFromExtras(extras);
+            }
+        }
+    }
+
+    /**
+     * This will be triggered if the app is running and in the background,
+     * and the user clicks on a notification to open the app.
+     * <p>
+     * Notification data will be in intent.extras
+     *
+     * @param intent
+     * @return
+     */
+    @Override
+    public boolean onNewIntent(Intent intent) {
+        Bundle extras = intent.getExtras();
+        if (extras != null) {
+            if (extras.containsKey("notificationResponse")) {
+                Log.d("ReactNativeJS", "[native] ExpoNotificationLifecycleListener contains an unmarshaled notification response. Skipping.");
+                intent.removeExtra("notificationResponse");
+                return ReactActivityLifecycleListener.super.onNewIntent(intent);
+            }
+            mNotificationManager.onNotificationResponseFromExtras(extras);
+        }
+        return ReactActivityLifecycleListener.super.onNewIntent(intent);
+    }
+}
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map b/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
index b8f0dca..c736431 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationsEmitter.d.ts","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,YAAY,EAAuB,MAAM,mBAAmB,CAAC;AAEpF,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAW3E,eAAO,MAAM,yBAAyB,+CAA+C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,wBAAgB,+BAA+B,CAC7C,QAAQ,EAAE,CAAC,KAAK,EAAE,YAAY,KAAK,IAAI,GACtC,YAAY,CAEd;AAED;;;;;;;GAOG;AACH,wBAAgB,+BAA+B,CAAC,QAAQ,EAAE,MAAM,IAAI,GAAG,YAAY,CAElF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,wBAAgB,uCAAuC,CACrD,QAAQ,EAAE,CAAC,KAAK,EAAE,oBAAoB,KAAK,IAAI,GAC9C,YAAY,CAKd;AAED;;;;GAIG;AACH,wBAAgB,8BAA8B,CAAC,YAAY,EAAE,YAAY,QAExE;AAGD;;GAEG;AACH,wBAAsB,gCAAgC,IAAI,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC,CAK7F"}
\ No newline at end of file
+{"version":3,"file":"NotificationsEmitter.d.ts","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,YAAY,EAAuB,MAAM,mBAAmB,CAAC;AAEpF,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAY3E,eAAO,MAAM,yBAAyB,+CAA+C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,wBAAgB,+BAA+B,CAC7C,QAAQ,EAAE,CAAC,KAAK,EAAE,YAAY,KAAK,IAAI,GACtC,YAAY,CAEd;AAED;;;;;;;GAOG;AACH,wBAAgB,+BAA+B,CAAC,QAAQ,EAAE,MAAM,IAAI,GAAG,YAAY,CAElF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,wBAAgB,uCAAuC,CACrD,QAAQ,EAAE,CAAC,KAAK,EAAE,oBAAoB,KAAK,IAAI,GAC9C,YAAY,CAQd;AAED;;;;GAIG;AACH,wBAAgB,8BAA8B,CAAC,YAAY,EAAE,YAAY,QAExE;AAGD;;GAEG;AACH,wBAAsB,gCAAgC,IAAI,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC,CAK7F"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.js b/node_modules/expo-notifications/build/NotificationsEmitter.js
index 1c07cca..18cd3a4 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.js
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.js
@@ -1,5 +1,6 @@
 import { EventEmitter, UnavailabilityError } from 'expo-modules-core';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
+import { mapNotificationResponse } from './utils/mapNotificationResponse';
 // Web uses SyntheticEventEmitter
 const emitter = new EventEmitter(NotificationsEmitterModule);
 const didReceiveNotificationEventName = 'onDidReceiveNotification';
@@ -72,7 +73,10 @@ export function addNotificationsDroppedListener(listener) {
  * @header listen
  */
 export function addNotificationResponseReceivedListener(listener) {
-    return emitter.addListener(didReceiveNotificationResponseEventName, listener);
+    return emitter.addListener(didReceiveNotificationResponseEventName, (response) => {
+        const mappedResponse = mapNotificationResponse(response);
+        listener(mappedResponse);
+    });
 }
 /**
  * Removes a notification subscription returned by an `addNotificationListener` call.
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.js.map b/node_modules/expo-notifications/build/NotificationsEmitter.js.map
index 168c80b..2406f61 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.js.map
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.js.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationsEmitter.js","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAgB,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAGpF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AAEtE,iCAAiC;AACjC,MAAM,OAAO,GAAG,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAE7D,MAAM,+BAA+B,GAAG,0BAA0B,CAAC;AACnE,MAAM,6BAA6B,GAAG,wBAAwB,CAAC;AAC/D,MAAM,uCAAuC,GAAG,kCAAkC,CAAC;AAEnF,eAAe;AACf,MAAM,CAAC,MAAM,yBAAyB,GAAG,4CAA4C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,+BAA+B,CAC7C,QAAuC;IAEvC,OAAO,OAAO,CAAC,WAAW,CAAe,+BAA+B,EAAE,QAAQ,CAAC,CAAC;AACtF,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,+BAA+B,CAAC,QAAoB;IAClE,OAAO,OAAO,CAAC,WAAW,CAAO,6BAA6B,EAAE,QAAQ,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,UAAU,uCAAuC,CACrD,QAA+C;IAE/C,OAAO,OAAO,CAAC,WAAW,CACxB,uCAAuC,EACvC,QAAQ,CACT,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,8BAA8B,CAAC,YAA0B;IACvE,OAAO,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;AAC3C,CAAC;AAED,eAAe;AACf;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,gCAAgC;IACpD,IAAI,CAAC,0BAA0B,CAAC,gCAAgC,EAAE;QAChE,MAAM,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,kCAAkC,CAAC,CAAC;KACxF;IACD,OAAO,MAAM,0BAA0B,CAAC,gCAAgC,EAAE,CAAC;AAC7E,CAAC","sourcesContent":["import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationResponse } from './Notifications.types';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n// Web uses SyntheticEventEmitter\nconst emitter = new EventEmitter(NotificationsEmitterModule);\n\nconst didReceiveNotificationEventName = 'onDidReceiveNotification';\nconst didDropNotificationsEventName = 'onNotificationsDeleted';\nconst didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\n\n// @docsMissing\nexport const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\n\n/**\n * Listeners registered by this method will be called whenever a notification is received while the app is running.\n * @param listener A function accepting a notification ([`Notification`](#notification)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Registering a notification listener using a React hook:\n * ```jsx\n * import React from 'react';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function App() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationReceivedListener(notification => {\n *       console.log(notification);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationReceivedListener(\n  listener: (event: Notification) => void\n): Subscription {\n  return emitter.addListener<Notification>(didReceiveNotificationEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever some notifications have been dropped by the server.\n * Applicable only to Firebase Cloud Messaging which we use as a notifications service on Android. It corresponds to `onDeletedMessages()` callback.\n * More information can be found in [Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n * @param listener A callback function.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @header listen\n */\nexport function addNotificationsDroppedListener(listener: () => void): Subscription {\n  return emitter.addListener<void>(didDropNotificationsEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever a user interacts with a notification (for example, taps on it).\n * @param listener A function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Register a notification responder listener:\n * ```jsx\n * import React from 'react';\n * import { Linking } from 'react-native';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function Container() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n *       const url = response.notification.request.content.data.url;\n *       Linking.openURL(url);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationResponseReceivedListener(\n  listener: (event: NotificationResponse) => void\n): Subscription {\n  return emitter.addListener<NotificationResponse>(\n    didReceiveNotificationResponseEventName,\n    listener\n  );\n}\n\n/**\n * Removes a notification subscription returned by an `addNotificationListener` call.\n * @param subscription A subscription returned by `addNotificationListener` method.\n * @header listen\n */\nexport function removeNotificationSubscription(subscription: Subscription) {\n  emitter.removeSubscription(subscription);\n}\n\n// @docsMissing\n/**\n * @header listen\n */\nexport async function getLastNotificationResponseAsync(): Promise<NotificationResponse | null> {\n  if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');\n  }\n  return await NotificationsEmitterModule.getLastNotificationResponseAsync();\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NotificationsEmitter.js","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAgB,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAGpF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AACtE,OAAO,EAAE,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAE1E,iCAAiC;AACjC,MAAM,OAAO,GAAG,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAE7D,MAAM,+BAA+B,GAAG,0BAA0B,CAAC;AACnE,MAAM,6BAA6B,GAAG,wBAAwB,CAAC;AAC/D,MAAM,uCAAuC,GAAG,kCAAkC,CAAC;AAEnF,eAAe;AACf,MAAM,CAAC,MAAM,yBAAyB,GAAG,4CAA4C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,+BAA+B,CAC7C,QAAuC;IAEvC,OAAO,OAAO,CAAC,WAAW,CAAe,+BAA+B,EAAE,QAAQ,CAAC,CAAC;AACtF,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,+BAA+B,CAAC,QAAoB;IAClE,OAAO,OAAO,CAAC,WAAW,CAAO,6BAA6B,EAAE,QAAQ,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,UAAU,uCAAuC,CACrD,QAA+C;IAE/C,OAAO,OAAO,CAAC,WAAW,CACxB,uCAAuC,EACvC,CAAC,QAA8B,EAAE,EAAE;QACjC,MAAM,cAAc,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QACzD,QAAQ,CAAC,cAAc,CAAC,CAAC;IAC3B,CAAC,CACF,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,8BAA8B,CAAC,YAA0B;IACvE,OAAO,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;AAC3C,CAAC;AAED,eAAe;AACf;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,gCAAgC;IACpD,IAAI,CAAC,0BAA0B,CAAC,gCAAgC,EAAE;QAChE,MAAM,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,kCAAkC,CAAC,CAAC;KACxF;IACD,OAAO,MAAM,0BAA0B,CAAC,gCAAgC,EAAE,CAAC;AAC7E,CAAC","sourcesContent":["import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationResponse } from './Notifications.types';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotificationResponse } from './utils/mapNotificationResponse';\n\n// Web uses SyntheticEventEmitter\nconst emitter = new EventEmitter(NotificationsEmitterModule);\n\nconst didReceiveNotificationEventName = 'onDidReceiveNotification';\nconst didDropNotificationsEventName = 'onNotificationsDeleted';\nconst didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\n\n// @docsMissing\nexport const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\n\n/**\n * Listeners registered by this method will be called whenever a notification is received while the app is running.\n * @param listener A function accepting a notification ([`Notification`](#notification)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Registering a notification listener using a React hook:\n * ```jsx\n * import React from 'react';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function App() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationReceivedListener(notification => {\n *       console.log(notification);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationReceivedListener(\n  listener: (event: Notification) => void\n): Subscription {\n  return emitter.addListener<Notification>(didReceiveNotificationEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever some notifications have been dropped by the server.\n * Applicable only to Firebase Cloud Messaging which we use as a notifications service on Android. It corresponds to `onDeletedMessages()` callback.\n * More information can be found in [Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n * @param listener A callback function.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @header listen\n */\nexport function addNotificationsDroppedListener(listener: () => void): Subscription {\n  return emitter.addListener<void>(didDropNotificationsEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever a user interacts with a notification (for example, taps on it).\n * @param listener A function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Register a notification responder listener:\n * ```jsx\n * import React from 'react';\n * import { Linking } from 'react-native';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function Container() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n *       const url = response.notification.request.content.data.url;\n *       Linking.openURL(url);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationResponseReceivedListener(\n  listener: (event: NotificationResponse) => void\n): Subscription {\n  return emitter.addListener<NotificationResponse>(\n    didReceiveNotificationResponseEventName,\n    (response: NotificationResponse) => {\n      const mappedResponse = mapNotificationResponse(response);\n      listener(mappedResponse);\n    }\n  );\n}\n\n/**\n * Removes a notification subscription returned by an `addNotificationListener` call.\n * @param subscription A subscription returned by `addNotificationListener` method.\n * @header listen\n */\nexport function removeNotificationSubscription(subscription: Subscription) {\n  emitter.removeSubscription(subscription);\n}\n\n// @docsMissing\n/**\n * @header listen\n */\nexport async function getLastNotificationResponseAsync(): Promise<NotificationResponse | null> {\n  if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');\n  }\n  return await NotificationsEmitterModule.getLastNotificationResponseAsync();\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/useLastNotificationResponse.d.ts.map b/node_modules/expo-notifications/build/useLastNotificationResponse.d.ts.map
index fc750e6..3c17132 100644
--- a/node_modules/expo-notifications/build/useLastNotificationResponse.d.ts.map
+++ b/node_modules/expo-notifications/build/useLastNotificationResponse.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"useLastNotificationResponse.d.ts","sourceRoot":"","sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAI7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,CAAC,OAAO,UAAU,2BAA2B,4CA4BlD"}
\ No newline at end of file
+{"version":3,"file":"useLastNotificationResponse.d.ts","sourceRoot":"","sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAK7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,CAAC,OAAO,UAAU,2BAA2B,4CA8BlD"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/useLastNotificationResponse.js b/node_modules/expo-notifications/build/useLastNotificationResponse.js
index 577a613..f9ea795 100644
--- a/node_modules/expo-notifications/build/useLastNotificationResponse.js
+++ b/node_modules/expo-notifications/build/useLastNotificationResponse.js
@@ -1,6 +1,7 @@
 import { useEffect, useLayoutEffect, useState } from 'react';
 import { addNotificationResponseReceivedListener } from './NotificationsEmitter';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
+import { mapNotificationResponse } from './utils/mapNotificationResponse';
 /**
  * A React hook always returns the notification response that was received most recently
  * (a notification response designates an interaction with a notification, such as tapping on it).
@@ -41,7 +42,8 @@ export default function useLastNotificationResponse() {
     // useLayoutEffect ensures the listener is registered as soon as possible
     useLayoutEffect(() => {
         const subscription = addNotificationResponseReceivedListener((response) => {
-            setLastNotificationResponse(response);
+            const mappedResponse = mapNotificationResponse(response);
+            setLastNotificationResponse(mappedResponse);
         });
         return () => {
             subscription.remove();
@@ -55,7 +57,8 @@ export default function useLastNotificationResponse() {
             // We only update the state with the resolved value if it's empty,
             // because if it's not empty it must have been populated by the `useLayoutEffect`
             // listener which returns "live" values.
-            setLastNotificationResponse((currentResponse) => currentResponse ?? response);
+            const mappedResponse = response ? mapNotificationResponse(response) : response;
+            setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);
         });
     }, []);
     return lastNotificationResponse;
diff --git a/node_modules/expo-notifications/build/useLastNotificationResponse.js.map b/node_modules/expo-notifications/build/useLastNotificationResponse.js.map
index 255e53f..91a735a 100644
--- a/node_modules/expo-notifications/build/useLastNotificationResponse.js.map
+++ b/node_modules/expo-notifications/build/useLastNotificationResponse.js.map
@@ -1 +1 @@
-{"version":3,"file":"useLastNotificationResponse.js","sourceRoot":"","sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAG7D,OAAO,EAAE,uCAAuC,EAAE,MAAM,wBAAwB,CAAC;AACjF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,CAAC,OAAO,UAAU,2BAA2B;IACjD,MAAM,CAAC,wBAAwB,EAAE,2BAA2B,CAAC,GAAG,QAAQ,CAEtE,SAAS,CAAC,CAAC;IAEb,yEAAyE;IACzE,eAAe,CAAC,GAAG,EAAE;QACnB,MAAM,YAAY,GAAG,uCAAuC,CAAC,CAAC,QAAQ,EAAE,EAAE;YACxE,2BAA2B,CAAC,QAAQ,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,EAAE;YACV,YAAY,CAAC,MAAM,EAAE,CAAC;QACxB,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,iEAAiE;IACjE,8DAA8D;IAC9D,+CAA+C;IAC/C,SAAS,CAAC,GAAG,EAAE;QACb,0BAA0B,CAAC,gCAAgC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;YAChF,kEAAkE;YAClE,iFAAiF;YACjF,wCAAwC;YACxC,2BAA2B,CAAC,CAAC,eAAe,EAAE,EAAE,CAAC,eAAe,IAAI,QAAQ,CAAC,CAAC;QAChF,CAAC,CAAC,CAAC;IACL,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,wBAAwB,CAAC;AAClC,CAAC","sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n/**\n * A React hook always returns the notification response that was received most recently\n * (a notification response designates an interaction with a notification, such as tapping on it).\n *\n * > If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n *\n * @return The hook may return one of these three types/values:\n * - `undefined` - until we're sure of what to return,\n * - `null` - if no notification response has been received yet,\n * - a [`NotificationResponse`](#notificationresponse) object - if a notification response was received.\n *\n * @example Responding to a notification tap by opening a URL that could be put into the notification's `data`\n * (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n * ```jsx\n * import * as Notifications from 'expo-notifications';\n * import { Linking } from 'react-native';\n *\n * export default function App() {\n *   const lastNotificationResponse = Notifications.useLastNotificationResponse();\n *   React.useEffect(() => {\n *     if (\n *       lastNotificationResponse &&\n *       lastNotificationResponse.notification.request.content.data.url &&\n *       lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n *     ) {\n *       Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n *     }\n *   }, [lastNotificationResponse]);\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      setLastNotificationResponse(response);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      setLastNotificationResponse((currentResponse) => currentResponse ?? response);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"useLastNotificationResponse.js","sourceRoot":"","sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAG7D,OAAO,EAAE,uCAAuC,EAAE,MAAM,wBAAwB,CAAC;AACjF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AACtE,OAAO,EAAE,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAE1E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,CAAC,OAAO,UAAU,2BAA2B;IACjD,MAAM,CAAC,wBAAwB,EAAE,2BAA2B,CAAC,GAAG,QAAQ,CAEtE,SAAS,CAAC,CAAC;IAEb,yEAAyE;IACzE,eAAe,CAAC,GAAG,EAAE;QACnB,MAAM,YAAY,GAAG,uCAAuC,CAAC,CAAC,QAAQ,EAAE,EAAE;YACxE,MAAM,cAAc,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;YACzD,2BAA2B,CAAC,cAAc,CAAC,CAAC;QAC9C,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,EAAE;YACV,YAAY,CAAC,MAAM,EAAE,CAAC;QACxB,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,iEAAiE;IACjE,8DAA8D;IAC9D,+CAA+C;IAC/C,SAAS,CAAC,GAAG,EAAE;QACb,0BAA0B,CAAC,gCAAgC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;YAChF,kEAAkE;YAClE,iFAAiF;YACjF,wCAAwC;YACxC,MAAM,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;YAC/E,2BAA2B,CAAC,CAAC,eAAe,EAAE,EAAE,CAAC,eAAe,IAAI,cAAc,CAAC,CAAC;QACtF,CAAC,CAAC,CAAC;IACL,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,wBAAwB,CAAC;AAClC,CAAC","sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotificationResponse } from './utils/mapNotificationResponse';\n\n/**\n * A React hook always returns the notification response that was received most recently\n * (a notification response designates an interaction with a notification, such as tapping on it).\n *\n * > If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n *\n * @return The hook may return one of these three types/values:\n * - `undefined` - until we're sure of what to return,\n * - `null` - if no notification response has been received yet,\n * - a [`NotificationResponse`](#notificationresponse) object - if a notification response was received.\n *\n * @example Responding to a notification tap by opening a URL that could be put into the notification's `data`\n * (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n * ```jsx\n * import * as Notifications from 'expo-notifications';\n * import { Linking } from 'react-native';\n *\n * export default function App() {\n *   const lastNotificationResponse = Notifications.useLastNotificationResponse();\n *   React.useEffect(() => {\n *     if (\n *       lastNotificationResponse &&\n *       lastNotificationResponse.notification.request.content.data.url &&\n *       lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n *     ) {\n *       Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n *     }\n *   }, [lastNotificationResponse]);\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      const mappedResponse = mapNotificationResponse(response);\n      setLastNotificationResponse(mappedResponse);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      const mappedResponse = response ? mapNotificationResponse(response) : response;\n      setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts
new file mode 100644
index 0000000..3c8916e
--- /dev/null
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts
@@ -0,0 +1,21 @@
+import { NotificationResponse } from '../Notifications.types';
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification response from native code
+ * before it is passed to a notification response listener, or to the
+ * last notification response hook.
+ *
+ * @param response The raw response passed in from native code
+ * @returns the mapped response.
+ */
+export declare const mapNotificationResponse: (response: NotificationResponse) => NotificationResponse & {
+    notification: {
+        request: {
+            content: {
+                dataString?: string;
+            };
+        };
+    };
+};
+//# sourceMappingURL=mapNotificationResponse.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map
new file mode 100644
index 0000000..b873283
--- /dev/null
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"mapNotificationResponse.d.ts","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAE9D;;;;;;;;;GASG;AACH,eAAO,MAAM,uBAAuB,aAAc,oBAAoB;kBAEpD;QAAE,OAAO,EAAE;YAAE,OAAO,EAAE;gBAAE,UAAU,CAAC,EAAE,MAAM,CAAA;aAAE,CAAA;SAAE,CAAA;KAAE;CAYlE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js
new file mode 100644
index 0000000..4f421e3
--- /dev/null
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js
@@ -0,0 +1,25 @@
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification response from native code
+ * before it is passed to a notification response listener, or to the
+ * last notification response hook.
+ *
+ * @param response The raw response passed in from native code
+ * @returns the mapped response.
+ */
+export const mapNotificationResponse = (response) => {
+    const mappedResponse = { ...response };
+    try {
+        const dataString = mappedResponse?.notification?.request?.content['dataString'];
+        if (typeof dataString === 'string') {
+            mappedResponse.notification.request.content.data = JSON.parse(dataString);
+            delete mappedResponse.notification.request.content.dataString;
+        }
+    }
+    catch (e) {
+        console.log(`Error in response: ${e}`);
+    }
+    return mappedResponse;
+};
+//# sourceMappingURL=mapNotificationResponse.js.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map
new file mode 100644
index 0000000..4c49e80
--- /dev/null
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"mapNotificationResponse.js","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAEA;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,QAA8B,EAAE,EAAE;IACxE,MAAM,cAAc,GAEhB,EAAE,GAAG,QAAQ,EAAE,CAAC;IACpB,IAAI;QACF,MAAM,UAAU,GAAG,cAAc,EAAE,YAAY,EAAE,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;QAChF,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,cAAc,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YAC1E,OAAO,cAAc,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;SAC/D;KACF;IAAC,OAAO,CAAM,EAAE;QACf,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;KACxC;IACD,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC","sourcesContent":["import { NotificationResponse } from '../Notifications.types';\n\n/**\n * @hidden\n *\n * Does any required processing of a notification response from native code\n * before it is passed to a notification response listener, or to the\n * last notification response hook.\n *\n * @param response The raw response passed in from native code\n * @returns the mapped response.\n */\nexport const mapNotificationResponse = (response: NotificationResponse) => {\n  const mappedResponse: NotificationResponse & {\n    notification: { request: { content: { dataString?: string } } };\n  } = { ...response };\n  try {\n    const dataString = mappedResponse?.notification?.request?.content['dataString'];\n    if (typeof dataString === 'string') {\n      mappedResponse.notification.request.content.data = JSON.parse(dataString);\n      delete mappedResponse.notification.request.content.dataString;\n    }\n  } catch (e: any) {\n    console.log(`Error in response: ${e}`);\n  }\n  return mappedResponse;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/plugin/__mocks__/@expo/image-utils.ts b/node_modules/expo-notifications/plugin/__mocks__/@expo/image-utils.ts
new file mode 100644
index 0000000..8427446
--- /dev/null
+++ b/node_modules/expo-notifications/plugin/__mocks__/@expo/image-utils.ts
@@ -0,0 +1,8 @@
+export async function generateImageAsync(input: any, { src }) {
+  const fs = require('fs');
+  return { source: fs.readFileSync(src) };
+}
+
+export async function compositeImagesAsync({ foreground }) {
+  return foreground;
+}
diff --git a/node_modules/expo-notifications/plugin/__mocks__/fs.ts b/node_modules/expo-notifications/plugin/__mocks__/fs.ts
new file mode 100644
index 0000000..c81a2b9
--- /dev/null
+++ b/node_modules/expo-notifications/plugin/__mocks__/fs.ts
@@ -0,0 +1,2 @@
+import { fs } from 'memfs';
+module.exports = fs;
diff --git a/node_modules/expo-notifications/plugin/build/withNotifications.d.ts b/node_modules/expo-notifications/plugin/build/withNotifications.d.ts
index 8f87b69..f79b82f 100644
--- a/node_modules/expo-notifications/plugin/build/withNotifications.d.ts
+++ b/node_modules/expo-notifications/plugin/build/withNotifications.d.ts
@@ -13,6 +13,11 @@ export type NotificationsPluginProps = {
      * @platform android
      */
     color?: string;
+    /**
+     * Default channel for FCMv1 notifications.
+     * @platform android
+     */
+    defaultChannel?: string;
     /**
      * Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.
      */
diff --git a/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.d.ts b/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.d.ts
index 1f26faa..4d1aa54 100644
--- a/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.d.ts
+++ b/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.d.ts
@@ -8,8 +8,11 @@ type dpiMap = Record<DPIString, {
 }>;
 export declare const ANDROID_RES_PATH = "android/app/src/main/res/";
 export declare const dpiValues: dpiMap;
-export declare const META_DATA_NOTIFICATION_ICON = "expo.modules.notifications.default_notification_icon";
-export declare const META_DATA_NOTIFICATION_ICON_COLOR = "expo.modules.notifications.default_notification_color";
+export declare const META_DATA_NOTIFICATION_ICON = "com.google.firebase.messaging.default_notification_icon";
+export declare const META_DATA_NOTIFICATION_ICON_COLOR = "com.google.firebase.messaging.default_notification_color";
+export declare const META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID = "com.google.firebase.messaging.default_notification_channel_id";
+export declare const META_DATA_LEGACY_NOTIFICATION_ICON = "expo.modules.notifications.default_notification_icon";
+export declare const META_DATA_LEGACY_NOTIFICATION_ICON_COLOR = "expo.modules.notifications.default_notification_color";
 export declare const NOTIFICATION_ICON = "notification_icon";
 export declare const NOTIFICATION_ICON_RESOURCE: string;
 export declare const NOTIFICATION_ICON_COLOR = "notification_icon_color";
@@ -23,6 +26,7 @@ export declare const withNotificationIconColor: ConfigPlugin<{
 export declare const withNotificationManifest: ConfigPlugin<{
     icon: string | null;
     color: string | null;
+    defaultChannel: string | null;
 }>;
 export declare const withNotificationSounds: ConfigPlugin<{
     sounds: string[];
diff --git a/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.js b/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.js
index 9ca09dc..73a0334 100644
--- a/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.js
+++ b/node_modules/expo-notifications/plugin/build/withNotificationsAndroid.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.withNotificationsAndroid = exports.setNotificationSounds = exports.setNotificationIconAsync = exports.setNotificationIconColor = exports.getNotificationColor = exports.getNotificationIcon = exports.withNotificationSounds = exports.withNotificationManifest = exports.withNotificationIconColor = exports.withNotificationIcons = exports.NOTIFICATION_ICON_COLOR_RESOURCE = exports.NOTIFICATION_ICON_COLOR = exports.NOTIFICATION_ICON_RESOURCE = exports.NOTIFICATION_ICON = exports.META_DATA_NOTIFICATION_ICON_COLOR = exports.META_DATA_NOTIFICATION_ICON = exports.dpiValues = exports.ANDROID_RES_PATH = void 0;
+exports.withNotificationsAndroid = exports.setNotificationSounds = exports.setNotificationIconAsync = exports.setNotificationIconColor = exports.getNotificationColor = exports.getNotificationIcon = exports.withNotificationSounds = exports.withNotificationManifest = exports.withNotificationIconColor = exports.withNotificationIcons = exports.NOTIFICATION_ICON_COLOR_RESOURCE = exports.NOTIFICATION_ICON_COLOR = exports.NOTIFICATION_ICON_RESOURCE = exports.NOTIFICATION_ICON = exports.META_DATA_LEGACY_NOTIFICATION_ICON_COLOR = exports.META_DATA_LEGACY_NOTIFICATION_ICON = exports.META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID = exports.META_DATA_NOTIFICATION_ICON_COLOR = exports.META_DATA_NOTIFICATION_ICON = exports.dpiValues = exports.ANDROID_RES_PATH = void 0;
 const image_utils_1 = require("@expo/image-utils");
 const config_plugins_1 = require("expo/config-plugins");
 const fs_1 = require("fs");
@@ -17,8 +17,11 @@ exports.dpiValues = {
 const { addMetaDataItemToMainApplication, getMainApplicationOrThrow, removeMetaDataItemFromMainApplication, } = config_plugins_1.AndroidConfig.Manifest;
 const BASELINE_PIXEL_SIZE = 24;
 const ERROR_MSG_PREFIX = 'An error occurred while configuring Android notifications. ';
-exports.META_DATA_NOTIFICATION_ICON = 'expo.modules.notifications.default_notification_icon';
-exports.META_DATA_NOTIFICATION_ICON_COLOR = 'expo.modules.notifications.default_notification_color';
+exports.META_DATA_NOTIFICATION_ICON = 'com.google.firebase.messaging.default_notification_icon';
+exports.META_DATA_NOTIFICATION_ICON_COLOR = 'com.google.firebase.messaging.default_notification_color';
+exports.META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID = 'com.google.firebase.messaging.default_notification_channel_id';
+exports.META_DATA_LEGACY_NOTIFICATION_ICON = 'expo.modules.notifications.default_notification_icon';
+exports.META_DATA_LEGACY_NOTIFICATION_ICON_COLOR = 'expo.modules.notifications.default_notification_color';
 exports.NOTIFICATION_ICON = 'notification_icon';
 exports.NOTIFICATION_ICON_RESOURCE = `@drawable/${exports.NOTIFICATION_ICON}`;
 exports.NOTIFICATION_ICON_COLOR = 'notification_icon_color';
@@ -44,12 +47,13 @@ const withNotificationIconColor = (config, { color }) => {
     });
 };
 exports.withNotificationIconColor = withNotificationIconColor;
-const withNotificationManifest = (config, { icon, color }) => {
+const withNotificationManifest = (config, { icon, color, defaultChannel }) => {
     // If no icon or color provided in the config plugin props, fallback to value from app.json
     icon = icon || getNotificationIcon(config);
     color = color || getNotificationColor(config);
+    defaultChannel = defaultChannel || null;
     return (0, config_plugins_1.withAndroidManifest)(config, (config) => {
-        config.modResults = setNotificationConfig({ icon, color }, config.modResults);
+        config.modResults = setNotificationConfig({ icon, color, defaultChannel }, config.modResults);
         return config;
     });
 };
@@ -95,15 +99,25 @@ function setNotificationConfig(props, manifest) {
     const mainApplication = getMainApplicationOrThrow(manifest);
     if (props.icon) {
         addMetaDataItemToMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_ICON, exports.NOTIFICATION_ICON_RESOURCE, 'resource');
+        addMetaDataItemToMainApplication(mainApplication, exports.META_DATA_LEGACY_NOTIFICATION_ICON, exports.NOTIFICATION_ICON_RESOURCE, 'resource');
     }
     else {
         removeMetaDataItemFromMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_ICON);
+        removeMetaDataItemFromMainApplication(mainApplication, exports.META_DATA_LEGACY_NOTIFICATION_ICON);
     }
     if (props.color) {
         addMetaDataItemToMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_ICON_COLOR, exports.NOTIFICATION_ICON_COLOR_RESOURCE, 'resource');
+        addMetaDataItemToMainApplication(mainApplication, exports.META_DATA_LEGACY_NOTIFICATION_ICON_COLOR, exports.NOTIFICATION_ICON_COLOR_RESOURCE, 'resource');
     }
     else {
         removeMetaDataItemFromMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_ICON_COLOR);
+        removeMetaDataItemFromMainApplication(mainApplication, exports.META_DATA_LEGACY_NOTIFICATION_ICON_COLOR);
+    }
+    if (props.defaultChannel) {
+        addMetaDataItemToMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID, props.defaultChannel, 'value');
+    }
+    else {
+        removeMetaDataItemFromMainApplication(mainApplication, exports.META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID);
     }
     return manifest;
 }
@@ -174,10 +188,10 @@ function writeNotificationSoundFile(soundFileRelativePath, projectRoot) {
         }
     }
 }
-const withNotificationsAndroid = (config, { icon = null, color = null, sounds = [] }) => {
+const withNotificationsAndroid = (config, { icon = null, color = null, sounds = [], defaultChannel = null }) => {
     config = (0, exports.withNotificationIconColor)(config, { color });
     config = (0, exports.withNotificationIcons)(config, { icon });
-    config = (0, exports.withNotificationManifest)(config, { icon, color });
+    config = (0, exports.withNotificationManifest)(config, { icon, color, defaultChannel });
     config = (0, exports.withNotificationSounds)(config, { sounds });
     return config;
 };
diff --git a/node_modules/expo-notifications/plugin/src/__tests__/fixtures/cat.wav b/node_modules/expo-notifications/plugin/src/__tests__/fixtures/cat.wav
new file mode 100644
index 0000000..c25142c
Binary files /dev/null and b/node_modules/expo-notifications/plugin/src/__tests__/fixtures/cat.wav differ
diff --git a/node_modules/expo-notifications/plugin/src/__tests__/fixtures/icon.png b/node_modules/expo-notifications/plugin/src/__tests__/fixtures/icon.png
new file mode 100644
index 0000000..ff3dd16
Binary files /dev/null and b/node_modules/expo-notifications/plugin/src/__tests__/fixtures/icon.png differ
diff --git a/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsAndroid-test.ts b/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsAndroid-test.ts
new file mode 100644
index 0000000..743a002
--- /dev/null
+++ b/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsAndroid-test.ts
@@ -0,0 +1,124 @@
+import { ExpoConfig } from 'expo/config';
+import { fs, vol } from 'memfs';
+import * as path from 'path';
+
+import {
+  getNotificationColor,
+  getNotificationIcon,
+  setNotificationIconAsync,
+  setNotificationSounds,
+} from '../withNotificationsAndroid';
+
+export function getDirFromFS(fsJSON: Record<string, string | null>, rootDir: string) {
+  return Object.entries(fsJSON)
+    .filter(([path, value]) => value !== null && path.startsWith(rootDir))
+    .reduce<Record<string, string>>(
+      (acc, [path, fileContent]) => ({
+        ...acc,
+        [path.substring(rootDir.length).startsWith('/')
+          ? path.substring(rootDir.length + 1)
+          : path.substring(rootDir.length)]: fileContent,
+      }),
+      {}
+    );
+}
+
+const SAMPLE_COLORS_XML = `<?xml version="1.0" encoding="utf-8"?>
+    <resources>
+      <!-- Below line is handled by '@expo/configure-splash-screen' command and it's discouraged to modify it manually -->
+      <color name="splashscreen_background">#FFFFFF</color>
+    </resources>
+    `;
+
+jest.mock('fs');
+
+const fsReal = jest.requireActual('fs') as typeof fs;
+
+const LIST_OF_GENERATED_NOTIFICATION_FILES = [
+  'android/app/src/main/res/drawable-mdpi/notification_icon.png',
+  'android/app/src/main/res/drawable-hdpi/notification_icon.png',
+  'android/app/src/main/res/drawable-xhdpi/notification_icon.png',
+  'android/app/src/main/res/drawable-xxhdpi/notification_icon.png',
+  'android/app/src/main/res/drawable-xxxhdpi/notification_icon.png',
+  'android/app/src/main/res/values/colors.xml',
+  'assets/notificationIcon.png',
+  'assets/notificationSound.wav',
+  'android/app/src/main/res/raw/notificationSound.wav',
+];
+
+const iconPath = path.resolve(__dirname, './fixtures/icon.png');
+const soundPath = path.resolve(__dirname, './fixtures/cat.wav');
+
+const projectRoot = '/app';
+
+describe('Android notifications configuration', () => {
+  beforeEach(async () => {
+    const icon = fsReal.readFileSync(iconPath);
+    const sound = fsReal.readFileSync(soundPath);
+    vol.fromJSON(
+      { './android/app/src/main/res/values/colors.xml': SAMPLE_COLORS_XML },
+      projectRoot
+    );
+    setUpDrawableDirectories();
+    vol.mkdirpSync('/app/assets');
+    vol.writeFileSync('/app/assets/notificationIcon.png', icon);
+    vol.writeFileSync('/app/assets/notificationSound.wav', sound);
+  });
+
+  afterEach(() => {
+    vol.reset();
+  });
+
+  afterAll(() => {
+    jest.unmock('@expo/image-utils');
+    jest.unmock('fs');
+  });
+
+  it(`returns null if no config provided`, () => {
+    expect(getNotificationIcon({} as ExpoConfig)).toBeNull();
+    expect(getNotificationColor({} as ExpoConfig)).toBeNull();
+  });
+
+  it(`returns config if provided`, () => {
+    expect(getNotificationIcon({ notification: { icon: './myIcon.png' } } as ExpoConfig)).toMatch(
+      './myIcon.png'
+    );
+    expect(getNotificationColor({ notification: { color: '#123456' } } as ExpoConfig)).toMatch(
+      '#123456'
+    );
+  });
+
+  it('writes all the asset files (sounds and images) as expected', async () => {
+    await setNotificationIconAsync(projectRoot, '/app/assets/notificationIcon.png');
+    setNotificationSounds(projectRoot, ['/app/assets/notificationSound.wav']);
+
+    const after = getDirFromFS(vol.toJSON(), projectRoot);
+    expect(Object.keys(after).sort()).toEqual(LIST_OF_GENERATED_NOTIFICATION_FILES.sort());
+  });
+
+  it('Safely remove icon if it exists, and ignore if it doesnt', async () => {
+    const before = getDirFromFS(vol.toJSON(), projectRoot);
+    // first set the icon
+    await setNotificationIconAsync(projectRoot, '/app/assets/notificationIcon.png');
+
+    // now remove
+    await setNotificationIconAsync(projectRoot, null);
+
+    const after = getDirFromFS(vol.toJSON(), projectRoot);
+    expect(before).toMatchObject(after);
+
+    // now remove again to make sure we don't throw in that case
+    await setNotificationIconAsync(projectRoot, null);
+
+    const final = getDirFromFS(vol.toJSON(), projectRoot);
+    expect(before).toMatchObject(final);
+  });
+});
+
+function setUpDrawableDirectories() {
+  vol.mkdirpSync('/app/android/app/src/main/res/drawable-mdpi');
+  vol.mkdirpSync('/app/android/app/src/main/res/drawable-hdpi');
+  vol.mkdirpSync('/app/android/app/src/main/res/drawable-xhdpi');
+  vol.mkdirpSync('/app/android/app/src/main/res/drawable-xxhdpi');
+  vol.mkdirpSync('/app/android/app/src/main/res/drawable-xxxhdpi');
+}
diff --git a/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsiOS-test.ts b/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsiOS-test.ts
new file mode 100644
index 0000000..6579556
--- /dev/null
+++ b/node_modules/expo-notifications/plugin/src/__tests__/withNotificationsiOS-test.ts
@@ -0,0 +1,56 @@
+import { IOSConfig } from 'expo/config-plugins';
+import { fs, vol } from 'memfs';
+import * as path from 'path';
+
+import { getDirFromFS } from './withNotificationsAndroid-test';
+import { setNotificationSounds } from '../withNotificationsIOS';
+
+jest.mock('fs');
+
+const fsReal = jest.requireActual('fs') as typeof fs;
+
+const template = path.join(
+  __dirname,
+  '../../../../../templates/expo-template-bare-minimum/ios/HelloWorld.xcodeproj/project.pbxproj'
+);
+const pbxproj = fsReal.readFileSync(template, 'utf-8');
+const LIST_OF_GENERATED_FILES = [
+  'assets/notificationSound.wav',
+  'ios/testproject/notificationSound.wav',
+  'ios/testproject.xcodeproj/project.pbxproj',
+  'ios/testproject/AppDelegate.m',
+];
+
+const soundPath = path.resolve(__dirname, './fixtures/cat.wav');
+
+const projectRoot = '/app';
+
+describe('iOS notifications configuration', () => {
+  beforeAll(async () => {
+    jest.mock('fs');
+    const sound = fsReal.readFileSync(soundPath);
+    vol.fromJSON({ 'ios/testproject/AppDelegate.m': '' }, projectRoot);
+    vol.mkdirpSync('/app/assets');
+    vol.mkdirpSync('/app/ios/testproject.xcodeproj/');
+    vol.writeFileSync('/app/assets/notificationSound.wav', sound);
+    vol.writeFileSync('/app/ios/testproject.xcodeproj/project.pbxproj', pbxproj);
+  });
+
+  afterAll(() => {
+    jest.unmock('fs');
+    vol.reset();
+  });
+
+  it('writes all the asset files (sounds and images) as expected', async () => {
+    const project = IOSConfig.XcodeUtils.getPbxproj(projectRoot);
+    // TODO: test pbxproj result via snapshot
+    setNotificationSounds(projectRoot, {
+      sounds: ['/app/assets/notificationSound.wav'],
+      project,
+      projectName: 'testproject',
+    });
+
+    const after = getDirFromFS(vol.toJSON(), projectRoot);
+    expect(Object.keys(after).sort()).toEqual(LIST_OF_GENERATED_FILES.sort());
+  });
+});
diff --git a/node_modules/expo-notifications/plugin/src/withNotifications.ts b/node_modules/expo-notifications/plugin/src/withNotifications.ts
index 9540645..4453df3 100644
--- a/node_modules/expo-notifications/plugin/src/withNotifications.ts
+++ b/node_modules/expo-notifications/plugin/src/withNotifications.ts
@@ -19,6 +19,11 @@ export type NotificationsPluginProps = {
    * @platform android
    */
   color?: string;
+  /**
+   * Default channel for FCMv1 notifications.
+   * @platform android
+   */
+  defaultChannel?: string;
   /**
    * Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.
    */
diff --git a/node_modules/expo-notifications/plugin/src/withNotificationsAndroid.ts b/node_modules/expo-notifications/plugin/src/withNotificationsAndroid.ts
index 94d2bd0..b5ab4e4 100644
--- a/node_modules/expo-notifications/plugin/src/withNotificationsAndroid.ts
+++ b/node_modules/expo-notifications/plugin/src/withNotificationsAndroid.ts
@@ -32,9 +32,19 @@ const {
 } = AndroidConfig.Manifest;
 const BASELINE_PIXEL_SIZE = 24;
 const ERROR_MSG_PREFIX = 'An error occurred while configuring Android notifications. ';
-export const META_DATA_NOTIFICATION_ICON = 'expo.modules.notifications.default_notification_icon';
+
+export const META_DATA_NOTIFICATION_ICON =
+  'com.google.firebase.messaging.default_notification_icon';
 export const META_DATA_NOTIFICATION_ICON_COLOR =
+  'com.google.firebase.messaging.default_notification_color';
+export const META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID =
+  'com.google.firebase.messaging.default_notification_channel_id';
+
+export const META_DATA_LEGACY_NOTIFICATION_ICON =
+  'expo.modules.notifications.default_notification_icon';
+export const META_DATA_LEGACY_NOTIFICATION_ICON_COLOR =
   'expo.modules.notifications.default_notification_color';
+
 export const NOTIFICATION_ICON = 'notification_icon';
 export const NOTIFICATION_ICON_RESOURCE = `@drawable/${NOTIFICATION_ICON}`;
 export const NOTIFICATION_ICON_COLOR = 'notification_icon_color';
@@ -67,12 +77,14 @@ export const withNotificationIconColor: ConfigPlugin<{ color: string | null }> =
 export const withNotificationManifest: ConfigPlugin<{
   icon: string | null;
   color: string | null;
-}> = (config, { icon, color }) => {
+  defaultChannel: string | null;
+}> = (config, { icon, color, defaultChannel }) => {
   // If no icon or color provided in the config plugin props, fallback to value from app.json
   icon = icon || getNotificationIcon(config);
   color = color || getNotificationColor(config);
+  defaultChannel = defaultChannel || null;
   return withAndroidManifest(config, (config) => {
-    config.modResults = setNotificationConfig({ icon, color }, config.modResults);
+    config.modResults = setNotificationConfig({ icon, color, defaultChannel }, config.modResults);
     return config;
   });
 };
@@ -117,7 +129,7 @@ export async function setNotificationIconAsync(projectRoot: string, icon: string
 }
 
 function setNotificationConfig(
-  props: { icon: string | null; color: string | null },
+  props: { icon: string | null; color: string | null; defaultChannel?: string | null },
   manifest: AndroidConfig.Manifest.AndroidManifest
 ) {
   const mainApplication = getMainApplicationOrThrow(manifest);
@@ -128,8 +140,15 @@ function setNotificationConfig(
       NOTIFICATION_ICON_RESOURCE,
       'resource'
     );
+    addMetaDataItemToMainApplication(
+      mainApplication,
+      META_DATA_LEGACY_NOTIFICATION_ICON,
+      NOTIFICATION_ICON_RESOURCE,
+      'resource'
+    );
   } else {
     removeMetaDataItemFromMainApplication(mainApplication, META_DATA_NOTIFICATION_ICON);
+    removeMetaDataItemFromMainApplication(mainApplication, META_DATA_LEGACY_NOTIFICATION_ICON);
   }
   if (props.color) {
     addMetaDataItemToMainApplication(
@@ -138,8 +157,32 @@ function setNotificationConfig(
       NOTIFICATION_ICON_COLOR_RESOURCE,
       'resource'
     );
+    addMetaDataItemToMainApplication(
+      mainApplication,
+      META_DATA_LEGACY_NOTIFICATION_ICON_COLOR,
+      NOTIFICATION_ICON_COLOR_RESOURCE,
+      'resource'
+    );
   } else {
     removeMetaDataItemFromMainApplication(mainApplication, META_DATA_NOTIFICATION_ICON_COLOR);
+    removeMetaDataItemFromMainApplication(
+      mainApplication,
+      META_DATA_LEGACY_NOTIFICATION_ICON_COLOR
+    );
+  }
+
+  if (props.defaultChannel) {
+    addMetaDataItemToMainApplication(
+      mainApplication,
+      META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID,
+      props.defaultChannel,
+      'value'
+    );
+  } else {
+    removeMetaDataItemFromMainApplication(
+      mainApplication,
+      META_DATA_NOTIFICATION_DEFAULT_CHANNEL_ID
+    );
   }
   return manifest;
 }
@@ -229,11 +272,11 @@ function writeNotificationSoundFile(soundFileRelativePath: string, projectRoot:
 
 export const withNotificationsAndroid: ConfigPlugin<NotificationsPluginProps> = (
   config,
-  { icon = null, color = null, sounds = [] }
+  { icon = null, color = null, sounds = [], defaultChannel = null }
 ) => {
   config = withNotificationIconColor(config, { color });
   config = withNotificationIcons(config, { icon });
-  config = withNotificationManifest(config, { icon, color });
+  config = withNotificationManifest(config, { icon, color, defaultChannel });
   config = withNotificationSounds(config, { sounds });
   return config;
 };
diff --git a/node_modules/expo-notifications/src/NotificationsEmitter.ts b/node_modules/expo-notifications/src/NotificationsEmitter.ts
index 6942363..50f9678 100644
--- a/node_modules/expo-notifications/src/NotificationsEmitter.ts
+++ b/node_modules/expo-notifications/src/NotificationsEmitter.ts
@@ -2,6 +2,7 @@ import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-co
 
 import { Notification, NotificationResponse } from './Notifications.types';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
+import { mapNotificationResponse } from './utils/mapNotificationResponse';
 
 // Web uses SyntheticEventEmitter
 const emitter = new EventEmitter(NotificationsEmitterModule);
@@ -86,7 +87,10 @@ export function addNotificationResponseReceivedListener(
 ): Subscription {
   return emitter.addListener<NotificationResponse>(
     didReceiveNotificationResponseEventName,
-    listener
+    (response: NotificationResponse) => {
+      const mappedResponse = mapNotificationResponse(response);
+      listener(mappedResponse);
+    }
   );
 }
 
diff --git a/node_modules/expo-notifications/src/__tests__/DevicePushTokenAutoRegistration-test.ts b/node_modules/expo-notifications/src/__tests__/DevicePushTokenAutoRegistration-test.ts
new file mode 100644
index 0000000..2caf407
--- /dev/null
+++ b/node_modules/expo-notifications/src/__tests__/DevicePushTokenAutoRegistration-test.ts
@@ -0,0 +1,56 @@
+import * as DevicePushTokenAutoRegistration from '../DevicePushTokenAutoRegistration.fx';
+import { DevicePushToken } from '../Tokens.types';
+import getDevicePushTokenAsync from '../getDevicePushTokenAsync';
+import { updateDevicePushTokenAsync } from '../utils/updateDevicePushTokenAsync';
+
+const ENABLED_REGISTRATION_FIXTURE: DevicePushTokenAutoRegistration.DevicePushTokenRegistration = {
+  isEnabled: true,
+};
+const DISABLED_REGISTRATION_FIXTURE: DevicePushTokenAutoRegistration.DevicePushTokenRegistration = {
+  isEnabled: false,
+};
+
+jest.mock('../utils/updateDevicePushTokenAsync');
+jest.mock('../ServerRegistrationModule');
+jest.mock('../getDevicePushTokenAsync');
+
+describe('__handlePersistedRegistrationInfoAsync', () => {
+  it(`doesn't fail if persisted value is empty`, async () => {
+    const spy = jest.spyOn(console, 'warn').mockImplementation();
+    await expect(
+      DevicePushTokenAutoRegistration.__handlePersistedRegistrationInfoAsync(null)
+    ).resolves.toBeUndefined();
+    await expect(
+      DevicePushTokenAutoRegistration.__handlePersistedRegistrationInfoAsync(undefined)
+    ).resolves.toBeUndefined();
+    await expect(
+      DevicePushTokenAutoRegistration.__handlePersistedRegistrationInfoAsync('{i-am-invalid-json')
+    ).resolves.toBeUndefined();
+    spy.mockRestore();
+  });
+
+  it(`doesn't try to update registration if it's not enabled`, async () => {
+    await DevicePushTokenAutoRegistration.__handlePersistedRegistrationInfoAsync(
+      JSON.stringify(DISABLED_REGISTRATION_FIXTURE)
+    );
+    expect(getDevicePushTokenAsync).not.toBeCalled();
+    expect(updateDevicePushTokenAsync).not.toBeCalled();
+  });
+
+  it(`does try to update registration if it's enabled`, async () => {
+    const mockPendingDevicePushToken: DevicePushToken = {
+      data: 'i-want-to-be-sent-to-server',
+      type: 'ios',
+    };
+    (
+      getDevicePushTokenAsync as jest.MockedFunction<typeof getDevicePushTokenAsync>
+    ).mockResolvedValue(mockPendingDevicePushToken);
+    await DevicePushTokenAutoRegistration.__handlePersistedRegistrationInfoAsync(
+      JSON.stringify(ENABLED_REGISTRATION_FIXTURE)
+    );
+    expect(updateDevicePushTokenAsync).toBeCalledWith(
+      expect.anything(),
+      mockPendingDevicePushToken
+    );
+  });
+});
diff --git a/node_modules/expo-notifications/src/__tests__/NotificationCategories-test.ts b/node_modules/expo-notifications/src/__tests__/NotificationCategories-test.ts
new file mode 100644
index 0000000..0616b03
--- /dev/null
+++ b/node_modules/expo-notifications/src/__tests__/NotificationCategories-test.ts
@@ -0,0 +1,69 @@
+import NotificationCategoriesModule from '../NotificationCategoriesModule.native';
+import deleteNotificationCategoryAsync from '../deleteNotificationCategoryAsync';
+import getNotificationCategoriesAsync from '../getNotificationCategoriesAsync';
+import setNotificationCategoryAsync from '../setNotificationCategoryAsync';
+
+it(`setNotificationCategoryAsync accepts the expected arguments`, async () => {
+  await setNotificationCategoryAsync(
+    'my-category-id',
+    [
+      {
+        identifier: 'actionId',
+        buttonTitle: 'click me',
+        textInput: { submitButtonTitle: 'submit', placeholder: 'tests are good' },
+        options: {
+          opensAppToForeground: false,
+          isAuthenticationRequired: true,
+          isDestructive: true,
+        },
+      },
+    ],
+    {
+      previewPlaceholder: 'this is just a placeholder',
+      intentIdentifiers: ['myIntentIdentifier'],
+      categorySummaryFormat: 'formatString',
+      customDismissAction: true,
+      allowInCarPlay: true,
+      showTitle: true,
+      showSubtitle: true,
+      allowAnnouncement: true,
+    }
+  );
+  expect(NotificationCategoriesModule.setNotificationCategoryAsync).toHaveBeenLastCalledWith(
+    'my-category-id',
+    [
+      {
+        identifier: 'actionId',
+        buttonTitle: 'click me',
+        textInput: { submitButtonTitle: 'submit', placeholder: 'tests are good' },
+        options: {
+          opensAppToForeground: false,
+          isAuthenticationRequired: true,
+          isDestructive: true,
+        },
+      },
+    ],
+    {
+      previewPlaceholder: 'this is just a placeholder',
+      intentIdentifiers: ['myIntentIdentifier'],
+      categorySummaryFormat: 'formatString',
+      customDismissAction: true,
+      allowInCarPlay: true,
+      showTitle: true,
+      showSubtitle: true,
+      allowAnnouncement: true,
+    }
+  );
+});
+
+it('deleteNotificationCategoryAsync accepts the expected argument', async () => {
+  await deleteNotificationCategoryAsync('my-category-id');
+  expect(NotificationCategoriesModule.deleteNotificationCategoryAsync).toHaveBeenLastCalledWith(
+    'my-category-id'
+  );
+});
+
+it('getNotificationCategoriesAsync accepts the expected argument', async () => {
+  await getNotificationCategoriesAsync();
+  expect(NotificationCategoriesModule.getNotificationCategoriesAsync).toHaveBeenLastCalledWith();
+});
diff --git a/node_modules/expo-notifications/src/__tests__/Notifications-test.ts b/node_modules/expo-notifications/src/__tests__/Notifications-test.ts
new file mode 100644
index 0000000..5576b46
--- /dev/null
+++ b/node_modules/expo-notifications/src/__tests__/Notifications-test.ts
@@ -0,0 +1,311 @@
+import NotificationScheduler from '../NotificationScheduler';
+import scheduleNotificationAsync from '../scheduleNotificationAsync';
+
+const notificationTriggerInputTest = {
+  identifier: 'test_id',
+  content: {
+    title: 'test',
+  },
+};
+
+it(`verifies date (as Date) trigger handling`, async () => {
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger: new Date(),
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'date',
+      timestamp: input.trigger.getTime(),
+    }
+  );
+});
+
+it(`verifies date (as time) trigger handling`, async () => {
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger: new Date().getTime(),
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'date',
+      timestamp: input.trigger,
+    }
+  );
+});
+
+it(`verifies daily trigger handling`, async () => {
+  const trigger = {
+    hour: 12,
+    minute: 30,
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'daily',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies weekly trigger handling`, async () => {
+  const trigger = {
+    weekday: 1,
+    hour: 12,
+    minute: 30,
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'weekly',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies yearly trigger handling`, async () => {
+  const trigger = {
+    day: 1,
+    month: 6,
+    hour: 12,
+    minute: 30,
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'yearly',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies daily trigger handling with channelId`, async () => {
+  const trigger = {
+    hour: 12,
+    minute: 30,
+    channelId: 'test-channel-id',
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'daily',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies weekly trigger handling with channelId`, async () => {
+  const trigger = {
+    weekday: 1,
+    hour: 12,
+    minute: 30,
+    channelId: 'test-channel-id',
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'weekly',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies yearly trigger handling with channelId`, async () => {
+  const trigger = {
+    day: 1,
+    month: 6,
+    hour: 12,
+    minute: 30,
+    channelId: 'test-channel-id',
+    repeats: true as boolean | undefined,
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  delete trigger.repeats;
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'yearly',
+      ...input.trigger,
+    }
+  );
+});
+
+it(`verifies immediate trigger handling`, async () => {
+  const trigger = null;
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    null
+  );
+});
+
+it(`verifies immediate trigger handling with channelId`, async () => {
+  const trigger = {
+    channelId: 'test-channel-id',
+  };
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger,
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    null
+  );
+});
+
+it(`verifies time interval trigger handling`, async () => {
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger: {
+      seconds: 3600,
+    },
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'timeInterval',
+      repeats: false,
+      seconds: input.trigger.seconds,
+    }
+  );
+
+  await scheduleNotificationAsync({
+    ...input,
+    trigger: {
+      ...input.trigger,
+      repeats: true,
+    },
+  });
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'timeInterval',
+      repeats: true,
+      seconds: input.trigger.seconds,
+    }
+  );
+});
+
+it(`verifies calendar trigger handling`, async () => {
+  const input = {
+    ...notificationTriggerInputTest,
+    trigger: {
+      hour: 12,
+      minute: 30,
+    },
+  };
+  await scheduleNotificationAsync(input);
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'calendar',
+      repeats: undefined,
+      value: {
+        ...input.trigger,
+      },
+    }
+  );
+
+  await scheduleNotificationAsync({
+    ...input,
+    trigger: {
+      ...input.trigger,
+      second: 10,
+    },
+  });
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'calendar',
+      repeats: undefined,
+      value: {
+        ...input.trigger,
+        second: 10,
+      },
+    }
+  );
+
+  await scheduleNotificationAsync({
+    ...input,
+    trigger: {
+      ...input.trigger,
+      repeats: true,
+      second: 10,
+    },
+  });
+  expect(NotificationScheduler.scheduleNotificationAsync).toHaveBeenLastCalledWith(
+    input.identifier,
+    input.content,
+    {
+      type: 'calendar',
+      repeats: true,
+      value: {
+        ...input.trigger,
+        second: 10,
+      },
+    }
+  );
+});
diff --git a/node_modules/expo-notifications/src/__tests__/index-test.ts b/node_modules/expo-notifications/src/__tests__/index-test.ts
new file mode 100644
index 0000000..17958da
--- /dev/null
+++ b/node_modules/expo-notifications/src/__tests__/index-test.ts
@@ -0,0 +1,5 @@
+import * as Notifications from '..';
+
+it(`includes IosAuthorizationStatus export`, () => {
+  expect(Notifications.IosAuthorizationStatus).toBeDefined();
+});
diff --git a/node_modules/expo-notifications/src/useLastNotificationResponse.ts b/node_modules/expo-notifications/src/useLastNotificationResponse.ts
index 89c1c0b..6163695 100644
--- a/node_modules/expo-notifications/src/useLastNotificationResponse.ts
+++ b/node_modules/expo-notifications/src/useLastNotificationResponse.ts
@@ -3,6 +3,7 @@ import { useEffect, useLayoutEffect, useState } from 'react';
 import { NotificationResponse } from './Notifications.types';
 import { addNotificationResponseReceivedListener } from './NotificationsEmitter';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
+import { mapNotificationResponse } from './utils/mapNotificationResponse';
 
 /**
  * A React hook always returns the notification response that was received most recently
@@ -47,7 +48,8 @@ export default function useLastNotificationResponse() {
   // useLayoutEffect ensures the listener is registered as soon as possible
   useLayoutEffect(() => {
     const subscription = addNotificationResponseReceivedListener((response) => {
-      setLastNotificationResponse(response);
+      const mappedResponse = mapNotificationResponse(response);
+      setLastNotificationResponse(mappedResponse);
     });
     return () => {
       subscription.remove();
@@ -62,7 +64,8 @@ export default function useLastNotificationResponse() {
       // We only update the state with the resolved value if it's empty,
       // because if it's not empty it must have been populated by the `useLayoutEffect`
       // listener which returns "live" values.
-      setLastNotificationResponse((currentResponse) => currentResponse ?? response);
+      const mappedResponse = response ? mapNotificationResponse(response) : response;
+      setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);
     });
   }, []);
 
diff --git a/node_modules/expo-notifications/src/utils/__tests__/updateDevicePushTokenAsync-test.ts b/node_modules/expo-notifications/src/utils/__tests__/updateDevicePushTokenAsync-test.ts
new file mode 100644
index 0000000..74c1a32
--- /dev/null
+++ b/node_modules/expo-notifications/src/utils/__tests__/updateDevicePushTokenAsync-test.ts
@@ -0,0 +1,94 @@
+import 'abort-controller/polyfill';
+
+import { DevicePushToken } from '../../Tokens.types';
+import { updateDevicePushTokenAsync } from '../updateDevicePushTokenAsync';
+
+const TOKEN: DevicePushToken = { type: 'ios', data: 'i-am-token' };
+
+jest.mock('../../ServerRegistrationModule', () => ({
+  getInstallationIdAsync: () => 'abcdefg',
+}));
+
+declare const global: any;
+
+const expoEndpointUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';
+
+describe('given valid registration info', () => {
+  const successResponse = {
+    status: 200,
+    ok: true,
+  } as Response;
+
+  const failureResponse = {
+    status: 500,
+    ok: false,
+    text: async () => 'Server error',
+  } as Response;
+
+  let originalFetch: typeof fetch | undefined;
+
+  beforeAll(() => {
+    originalFetch = global.fetch;
+    global.fetch = jest.fn();
+  });
+
+  afterAll(() => {
+    global.fetch = originalFetch;
+  });
+
+  it('submits the request to proper URL', async () => {
+    global.fetch.mockResolvedValue(successResponse);
+    const warnSpy = jest.spyOn(console, 'warn').mockImplementation();
+    const abortController = new AbortController();
+    await updateDevicePushTokenAsync(abortController.signal, TOKEN);
+    warnSpy.mockRestore();
+    expect(global.fetch).toHaveBeenCalledWith(expoEndpointUrl, expect.anything());
+  });
+
+  describe('when server responds with an ok status', () => {
+    beforeAll(() => {
+      global.fetch.mockResolvedValue(successResponse);
+    });
+
+    it('submits the request only once', async () => {
+      const abortController = new AbortController();
+      await updateDevicePushTokenAsync(abortController.signal, TOKEN);
+      expect(global.fetch).toHaveBeenCalledTimes(1);
+    });
+  });
+
+  it('retries until it succeeds whilst server responds with an error status', async () => {
+    const spy = jest.spyOn(console, 'debug').mockImplementation();
+    global.fetch
+      .mockResolvedValueOnce(failureResponse)
+      .mockResolvedValueOnce(failureResponse)
+      .mockResolvedValueOnce(successResponse);
+    const abortController = new AbortController();
+    await updateDevicePushTokenAsync(abortController.signal, TOKEN);
+    expect(global.fetch).toHaveBeenCalledTimes(3);
+    spy.mockRestore();
+  });
+
+  it('retries until it succeeds if fetch throws', async () => {
+    const debugSpy = jest.spyOn(console, 'debug').mockImplementation();
+    const warnSpy = jest.spyOn(console, 'warn').mockImplementation();
+    global.fetch.mockRejectedValueOnce(new TypeError()).mockResolvedValueOnce(successResponse);
+    const abortController = new AbortController();
+    await updateDevicePushTokenAsync(abortController.signal, TOKEN);
+    expect(global.fetch).toHaveBeenCalledTimes(2);
+    warnSpy.mockRestore();
+    debugSpy.mockRestore();
+  });
+
+  it('does not retry if signal has been aborted', async () => {
+    const debugSpy = jest.spyOn(console, 'debug').mockImplementation();
+    const warnSpy = jest.spyOn(console, 'warn').mockImplementation();
+    global.fetch.mockRejectedValue(new TypeError());
+    const abortController = new AbortController();
+    setTimeout(() => abortController.abort(), 1000);
+    await updateDevicePushTokenAsync(abortController.signal, TOKEN);
+    expect(global.fetch).toHaveBeenCalledTimes(2);
+    warnSpy.mockRestore();
+    debugSpy.mockRestore();
+  });
+});
diff --git a/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts b/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts
new file mode 100644
index 0000000..424d0f2
--- /dev/null
+++ b/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts
@@ -0,0 +1,27 @@
+import { NotificationResponse } from '../Notifications.types';
+
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification response from native code
+ * before it is passed to a notification response listener, or to the
+ * last notification response hook.
+ *
+ * @param response The raw response passed in from native code
+ * @returns the mapped response.
+ */
+export const mapNotificationResponse = (response: NotificationResponse) => {
+  const mappedResponse: NotificationResponse & {
+    notification: { request: { content: { dataString?: string } } };
+  } = { ...response };
+  try {
+    const dataString = mappedResponse?.notification?.request?.content['dataString'];
+    if (typeof dataString === 'string') {
+      mappedResponse.notification.request.content.data = JSON.parse(dataString);
+      delete mappedResponse.notification.request.content.dataString;
+    }
+  } catch (e: any) {
+    console.log(`Error in response: ${e}`);
+  }
+  return mappedResponse;
+};
