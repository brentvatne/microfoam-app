diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
index 30a67ab..e0065ac 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
@@ -32,6 +32,7 @@ import expo.modules.notifications.notifications.model.triggers.FirebaseNotificat
 
 import expo.modules.notifications.notifications.triggers.DailyTrigger;
 import expo.modules.notifications.notifications.triggers.DateTrigger;
+import expo.modules.notifications.notifications.triggers.MonthlyTrigger;
 import expo.modules.notifications.notifications.triggers.TimeIntervalTrigger;
 import expo.modules.notifications.notifications.triggers.WeeklyTrigger;
 import expo.modules.notifications.notifications.triggers.YearlyTrigger;
@@ -211,6 +212,11 @@ public class NotificationSerializer {
       bundle.putInt("weekday", ((WeeklyTrigger) trigger).getWeekday());
       bundle.putInt("hour", ((WeeklyTrigger) trigger).getHour());
       bundle.putInt("minute", ((WeeklyTrigger) trigger).getMinute());
+    } else if (trigger instanceof MonthlyTrigger) {
+      bundle.putString("type", "monthly");
+      bundle.putInt("day", ((MonthlyTrigger) trigger).getDay());
+      bundle.putInt("hour", ((MonthlyTrigger) trigger).getHour());
+      bundle.putInt("minute", ((MonthlyTrigger) trigger).getMinute());
     } else if (trigger instanceof YearlyTrigger) {
       bundle.putString("type", "yearly");
       bundle.putInt("day", ((YearlyTrigger) trigger).getDay());
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/scheduling/NotificationScheduler.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/scheduling/NotificationScheduler.kt
index 4604ddf..753865d 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/scheduling/NotificationScheduler.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/scheduling/NotificationScheduler.kt
@@ -21,6 +21,7 @@ import expo.modules.notifications.notifications.model.NotificationRequest
 import expo.modules.notifications.notifications.triggers.ChannelAwareTrigger
 import expo.modules.notifications.notifications.triggers.DailyTrigger
 import expo.modules.notifications.notifications.triggers.DateTrigger
+import expo.modules.notifications.notifications.triggers.MonthlyTrigger
 import expo.modules.notifications.notifications.triggers.TimeIntervalTrigger
 import expo.modules.notifications.notifications.triggers.WeeklyTrigger
 import expo.modules.notifications.notifications.triggers.YearlyTrigger
@@ -197,6 +198,23 @@ open class NotificationScheduler : Module() {
         )
       }
 
+      "monthly" -> {
+        val day = params["day"] as? Number
+        val hour = params["hour"] as? Number
+        val minute = params["minute"] as? Number
+
+        if (day == null || hour == null || minute == null) {
+          throw InvalidArgumentException("Invalid value(s) provided for yearly trigger.")
+        }
+
+        MonthlyTrigger(
+          day.toInt(),
+          hour.toInt(),
+          minute.toInt(),
+          channelId
+        )
+      }
+
       "yearly" -> {
         val day = params["day"] as? Number
         val month = params["month"] as? Number
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/ChannelAwareTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/ChannelAwareTrigger.java
deleted file mode 100644
index 5c9bd43..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/ChannelAwareTrigger.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.io.Serializable;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.NotificationTrigger;
-
-public class ChannelAwareTrigger implements NotificationTrigger, Serializable {
-  @Nullable
-  private String mChannelId;
-
-  public ChannelAwareTrigger(@Nullable String channelId) {
-    mChannelId = channelId;
-  }
-
-  public ChannelAwareTrigger(Parcel in) {
-    mChannelId = in.readString();
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel parcel, int i) {
-    parcel.writeString(mChannelId);
-  }
-
-  @Nullable
-  @Override
-  public String getNotificationChannel() {
-    return mChannelId;
-  }
-
-  public static final Creator<ChannelAwareTrigger> CREATOR = new Creator<ChannelAwareTrigger>() {
-    @Override
-    public ChannelAwareTrigger createFromParcel(Parcel in) {
-      return new ChannelAwareTrigger(in);
-    }
-
-    @Override
-    public ChannelAwareTrigger[] newArray(int size) {
-      return new ChannelAwareTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DailyTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DailyTrigger.java
deleted file mode 100644
index 9d0e2c3..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DailyTrigger.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.util.Calendar;
-import java.util.Date;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger;
-
-/**
- * A schedulable trigger representing a notification to be scheduled once per day.
- */
-public class DailyTrigger extends ChannelAwareTrigger implements SchedulableNotificationTrigger {
-  private int mHour;
-  private int mMinute;
-
-  public DailyTrigger(int hour, int minute, @Nullable String channelId) {
-    super(channelId);
-    mHour = hour;
-    mMinute = minute;
-  }
-
-  private DailyTrigger(Parcel in) {
-    super(in);
-    mHour = in.readInt();
-    mMinute = in.readInt();
-  }
-
-  public int getHour() {
-    return mHour;
-  }
-
-  public int getMinute() {
-    return mMinute;
-  }
-
-  @Nullable
-  @Override
-  public Date nextTriggerDate() {
-    Calendar nextTriggerDate = Calendar.getInstance();
-    nextTriggerDate.set(Calendar.HOUR_OF_DAY, mHour);
-    nextTriggerDate.set(Calendar.MINUTE, mMinute);
-    nextTriggerDate.set(Calendar.SECOND, 0);
-    nextTriggerDate.set(Calendar.MILLISECOND, 0);
-    Calendar rightNow = Calendar.getInstance();
-    if (nextTriggerDate.before(rightNow)) {
-      nextTriggerDate.add(Calendar.DATE, 1);
-    }
-    return nextTriggerDate.getTime();
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    super.writeToParcel(dest, flags);
-    dest.writeInt(mHour);
-    dest.writeInt(mMinute);
-  }
-
-  public static final Creator<DailyTrigger> CREATOR = new Creator<DailyTrigger>() {
-    @Override
-    public DailyTrigger createFromParcel(Parcel in) {
-      return new DailyTrigger(in);
-    }
-
-    @Override
-    public DailyTrigger[] newArray(int size) {
-      return new DailyTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DateTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DateTrigger.java
deleted file mode 100644
index ab28d01..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/DateTrigger.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.util.Date;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger;
-
-/**
- * A schedulable trigger representing notification to be scheduled only once at a given moment of time.
- */
-public class DateTrigger extends ChannelAwareTrigger implements SchedulableNotificationTrigger {
-  private Date mTriggerDate;
-
-  public DateTrigger(long timestamp, @Nullable String channelId) {
-    super(channelId);
-    mTriggerDate = new Date(timestamp);
-  }
-
-  private DateTrigger(Parcel in) {
-    super(in);
-    mTriggerDate = new Date(in.readLong());
-  }
-
-  public Date getTriggerDate() {
-    return mTriggerDate;
-  }
-
-  @Nullable
-  @Override
-  public Date nextTriggerDate() {
-    Date now = new Date();
-
-    if (mTriggerDate.before(now)) {
-      return null;
-    }
-
-    return mTriggerDate;
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    super.writeToParcel(dest, flags);
-    dest.writeLong(mTriggerDate.getTime());
-  }
-
-  public static final Creator<DateTrigger> CREATOR = new Creator<DateTrigger>() {
-    @Override
-    public DateTrigger createFromParcel(Parcel in) {
-      return new DateTrigger(in);
-    }
-
-    @Override
-    public DateTrigger[] newArray(int size) {
-      return new DateTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/NotificationTriggers.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/NotificationTriggers.kt
new file mode 100644
index 0000000..03d7054
--- /dev/null
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/NotificationTriggers.kt
@@ -0,0 +1,413 @@
+package expo.modules.notifications.notifications.triggers
+
+import android.os.Parcel
+import android.os.Parcelable
+import expo.modules.notifications.notifications.interfaces.NotificationTrigger
+import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger
+import java.io.Serializable
+import java.util.Calendar
+import java.util.Date
+
+open class ChannelAwareTrigger : NotificationTrigger, Serializable {
+  private var mChannelId: String?
+
+  constructor(channelId: String?) {
+    mChannelId = channelId
+  }
+
+  constructor(`in`: Parcel) {
+    mChannelId = `in`.readString()
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    dest.writeString(mChannelId)
+  }
+
+  override fun getNotificationChannel(): String? {
+    return mChannelId
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<ChannelAwareTrigger?> =
+      object : Parcelable.Creator<ChannelAwareTrigger?> {
+        override fun createFromParcel(`in`: Parcel): ChannelAwareTrigger {
+          return ChannelAwareTrigger(`in`)
+        }
+
+        override fun newArray(size: Int): Array<ChannelAwareTrigger?> {
+          return arrayOfNulls(size)
+        }
+      }
+  }
+}
+
+/**
+ * A schedulable trigger representing a notification to be scheduled once per day.
+ */
+class DailyTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  var hour: Int
+    private set
+  var minute: Int
+    private set
+
+  constructor(hour: Int, minute: Int, channelId: String?) : super(channelId) {
+    this.hour = hour
+    this.minute = minute
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    hour = `in`.readInt()
+    minute = `in`.readInt()
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val nextTriggerDate = Calendar.getInstance()
+    nextTriggerDate[Calendar.HOUR_OF_DAY] = hour
+    nextTriggerDate[Calendar.MINUTE] = minute
+    nextTriggerDate[Calendar.SECOND] = 0
+    nextTriggerDate[Calendar.MILLISECOND] = 0
+    val rightNow = Calendar.getInstance()
+    if (nextTriggerDate.before(rightNow)) {
+      nextTriggerDate.add(Calendar.DATE, 1)
+    }
+    return nextTriggerDate.time
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeInt(hour)
+    dest.writeInt(minute)
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<DailyTrigger?> = object : Parcelable.Creator<DailyTrigger?> {
+      override fun createFromParcel(`in`: Parcel): DailyTrigger {
+        return DailyTrigger(`in`)
+      }
+
+      override fun newArray(size: Int): Array<DailyTrigger?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
+
+/**
+ * A schedulable trigger representing notification to be scheduled only once at a given moment of time.
+ */
+class DateTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  var triggerDate: Date
+    private set
+
+  constructor(timestamp: Long, channelId: String?) : super(channelId) {
+    triggerDate = Date(timestamp)
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    triggerDate = Date(`in`.readLong())
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val now = Date()
+
+    if (triggerDate.before(now)) {
+      return null
+    }
+
+    return triggerDate
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeLong(triggerDate.time)
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<DateTrigger?> = object : Parcelable.Creator<DateTrigger?> {
+      override fun createFromParcel(`in`: Parcel): DateTrigger {
+        return DateTrigger(`in`)
+      }
+
+      override fun newArray(size: Int): Array<DateTrigger?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
+
+/**
+ * A schedulable trigger representing a notification to be scheduled once per month.
+ */
+class MonthlyTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  var day: Int
+    private set
+  var hour: Int
+    private set
+  var minute: Int
+    private set
+
+  constructor(day: Int, hour: Int, minute: Int, channelId: String?) : super(channelId) {
+    this.day = day
+    this.hour = hour
+    this.minute = minute
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    day = `in`.readInt()
+    hour = `in`.readInt()
+    minute = `in`.readInt()
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val nextTriggerDate = Calendar.getInstance()
+    nextTriggerDate[Calendar.DATE] = day
+    nextTriggerDate[Calendar.HOUR_OF_DAY] = hour
+    nextTriggerDate[Calendar.MINUTE] = minute
+    nextTriggerDate[Calendar.SECOND] = 0
+    nextTriggerDate[Calendar.MILLISECOND] = 0
+    val rightNow = Calendar.getInstance()
+    if (nextTriggerDate.before(rightNow)) {
+      nextTriggerDate.add(Calendar.MONTH, 1)
+    }
+    return nextTriggerDate.time
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeInt(day)
+    dest.writeInt(hour)
+    dest.writeInt(minute)
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<MonthlyTrigger?> = object : Parcelable.Creator<MonthlyTrigger?> {
+      override fun createFromParcel(`in`: Parcel): MonthlyTrigger {
+        return MonthlyTrigger(`in`)
+      }
+
+      override fun newArray(size: Int): Array<MonthlyTrigger?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
+
+/**
+ * A schedulable trigger representing notification to be scheduled after X milliseconds,
+ * optionally repeating.
+ *
+ *
+ * *Note: The implementation ensures that the trigger times do not drift away too much from the
+ * * initial time, so eg. a trigger started at 11111000 time repeated every 1000 ms should always
+ * * trigger around …000 timestamp.*
+ */
+class TimeIntervalTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  private var mTriggerDate: Date
+  var timeInterval: Long
+    private set
+  var isRepeating: Boolean
+    private set
+
+  constructor(timeInterval: Long, repeats: Boolean, channelId: String?) : super(channelId) {
+    this.timeInterval = timeInterval
+    mTriggerDate = Date(Date().time + this.timeInterval * 1000)
+    isRepeating = repeats
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    mTriggerDate = Date(`in`.readLong())
+    timeInterval = `in`.readLong()
+    isRepeating = `in`.readByte().toInt() == 1
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val now = Date()
+
+    if (isRepeating) {
+      while (mTriggerDate.before(now)) {
+        mTriggerDate.time += timeInterval * 1000
+      }
+    }
+
+    if (mTriggerDate.before(now)) {
+      return null
+    }
+
+    return mTriggerDate
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeLong(mTriggerDate.time)
+    dest.writeLong(timeInterval)
+    dest.writeByte((if (isRepeating) 1 else 0).toByte())
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<TimeIntervalTrigger?> =
+      object : Parcelable.Creator<TimeIntervalTrigger?> {
+        override fun createFromParcel(`in`: Parcel): TimeIntervalTrigger {
+          return TimeIntervalTrigger(`in`)
+        }
+
+        override fun newArray(size: Int): Array<TimeIntervalTrigger?> {
+          return arrayOfNulls(size)
+        }
+      }
+  }
+}
+
+/**
+ * A schedulable trigger representing a notification to be scheduled once per week.
+ */
+class WeeklyTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  var weekday: Int
+    private set
+  var hour: Int
+    private set
+  var minute: Int
+    private set
+
+  constructor(weekday: Int, hour: Int, minute: Int, channelId: String?) : super(channelId) {
+    this.weekday = weekday
+    this.hour = hour
+    this.minute = minute
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    weekday = `in`.readInt()
+    hour = `in`.readInt()
+    minute = `in`.readInt()
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val nextTriggerDate = Calendar.getInstance()
+    nextTriggerDate[Calendar.DAY_OF_WEEK] = weekday
+    nextTriggerDate[Calendar.HOUR_OF_DAY] = hour
+    nextTriggerDate[Calendar.MINUTE] = minute
+    nextTriggerDate[Calendar.SECOND] = 0
+    nextTriggerDate[Calendar.MILLISECOND] = 0
+    val rightNow = Calendar.getInstance()
+    if (nextTriggerDate.before(rightNow)) {
+      nextTriggerDate.add(Calendar.DAY_OF_WEEK_IN_MONTH, 1)
+    }
+    return nextTriggerDate.time
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeInt(weekday)
+    dest.writeInt(hour)
+    dest.writeInt(minute)
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<WeeklyTrigger?> = object : Parcelable.Creator<WeeklyTrigger?> {
+      override fun createFromParcel(`in`: Parcel): WeeklyTrigger {
+        return WeeklyTrigger(`in`)
+      }
+
+      override fun newArray(size: Int): Array<WeeklyTrigger?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
+
+/**
+ * A schedulable trigger representing a notification to be scheduled once per year.
+ */
+class YearlyTrigger : ChannelAwareTrigger, SchedulableNotificationTrigger {
+  var day: Int
+    private set
+  var month: Int
+    private set
+  var hour: Int
+    private set
+  var minute: Int
+    private set
+
+  constructor(day: Int, month: Int, hour: Int, minute: Int, channelId: String?) : super(channelId) {
+    this.day = day
+    this.month = month
+    this.hour = hour
+    this.minute = minute
+  }
+
+  private constructor(`in`: Parcel) : super(`in`) {
+    day = `in`.readInt()
+    month = `in`.readInt()
+    hour = `in`.readInt()
+    minute = `in`.readInt()
+  }
+
+  override fun nextTriggerDate(): Date? {
+    val nextTriggerDate = Calendar.getInstance()
+    nextTriggerDate[Calendar.DATE] = day
+    nextTriggerDate[Calendar.MONTH] = month
+    nextTriggerDate[Calendar.HOUR_OF_DAY] = hour
+    nextTriggerDate[Calendar.MINUTE] = minute
+    nextTriggerDate[Calendar.SECOND] = 0
+    nextTriggerDate[Calendar.MILLISECOND] = 0
+    val rightNow = Calendar.getInstance()
+    if (nextTriggerDate.before(rightNow)) {
+      nextTriggerDate.add(Calendar.YEAR, 1)
+    }
+    return nextTriggerDate.time
+  }
+
+  override fun describeContents(): Int {
+    return 0
+  }
+
+  override fun writeToParcel(dest: Parcel, flags: Int) {
+    super.writeToParcel(dest, flags)
+    dest.writeInt(day)
+    dest.writeInt(month)
+    dest.writeInt(hour)
+    dest.writeInt(minute)
+  }
+
+  companion object {
+    @JvmField
+    val CREATOR: Parcelable.Creator<YearlyTrigger?> = object : Parcelable.Creator<YearlyTrigger?> {
+      override fun createFromParcel(`in`: Parcel): YearlyTrigger {
+        return YearlyTrigger(`in`)
+      }
+
+      override fun newArray(size: Int): Array<YearlyTrigger?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/TimeIntervalTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/TimeIntervalTrigger.java
deleted file mode 100644
index f3d0702..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/TimeIntervalTrigger.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.util.Date;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger;
-
-/**
- * A schedulable trigger representing notification to be scheduled after X milliseconds,
- * optionally repeating.
- * <p>
- * <i>Note: The implementation ensures that the trigger times do not drift away too much from the
- * * initial time, so eg. a trigger started at 11111000 time repeated every 1000 ms should always
- * * trigger around …000 timestamp.</i>
- */
-public class TimeIntervalTrigger extends ChannelAwareTrigger implements SchedulableNotificationTrigger {
-  private Date mTriggerDate;
-  private long mTimeInterval;
-  private boolean mRepeats;
-
-  public TimeIntervalTrigger(long timeInterval, boolean repeats, @Nullable String channelId) {
-    super(channelId);
-    mTimeInterval = timeInterval;
-    mTriggerDate = new Date(new Date().getTime() + mTimeInterval * 1000);
-    mRepeats = repeats;
-  }
-
-  private TimeIntervalTrigger(Parcel in) {
-    super(in);
-    mTriggerDate = new Date(in.readLong());
-    mTimeInterval = in.readLong();
-    mRepeats = in.readByte() == 1;
-  }
-
-  public boolean isRepeating() {
-    return mRepeats;
-  }
-
-  public long getTimeInterval() {
-    return mTimeInterval;
-  }
-
-  @Nullable
-  @Override
-  public Date nextTriggerDate() {
-    Date now = new Date();
-
-    if (mRepeats) {
-      while (mTriggerDate.before(now)) {
-        mTriggerDate.setTime(mTriggerDate.getTime() + mTimeInterval * 1000);
-      }
-    }
-
-    if (mTriggerDate.before(now)) {
-      return null;
-    }
-
-    return mTriggerDate;
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    super.writeToParcel(dest, flags);
-    dest.writeLong(mTriggerDate.getTime());
-    dest.writeLong(mTimeInterval);
-    dest.writeByte((byte) (mRepeats ? 1 : 0));
-  }
-
-  public static final Creator<TimeIntervalTrigger> CREATOR = new Creator<TimeIntervalTrigger>() {
-    @Override
-    public TimeIntervalTrigger createFromParcel(Parcel in) {
-      return new TimeIntervalTrigger(in);
-    }
-
-    @Override
-    public TimeIntervalTrigger[] newArray(int size) {
-      return new TimeIntervalTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/WeeklyTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/WeeklyTrigger.java
deleted file mode 100644
index f5d47ea..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/WeeklyTrigger.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.util.Calendar;
-import java.util.Date;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger;
-
-/**
- * A schedulable trigger representing a notification to be scheduled once per week.
- */
-public class WeeklyTrigger extends ChannelAwareTrigger implements SchedulableNotificationTrigger {
-  private int mWeekday;
-  private int mHour;
-  private int mMinute;
-
-  public WeeklyTrigger(int weekday, int hour, int minute, @Nullable String channelId) {
-    super(channelId);
-    mWeekday = weekday;
-    mHour = hour;
-    mMinute = minute;
-  }
-
-  private WeeklyTrigger(Parcel in) {
-    super(in);
-    mWeekday = in.readInt();
-    mHour = in.readInt();
-    mMinute = in.readInt();
-  }
-
-  public int getWeekday() {
-    return mWeekday;
-  }
-
-  public int getHour() {
-    return mHour;
-  }
-
-  public int getMinute() {
-    return mMinute;
-  }
-
-  @Nullable
-  @Override
-  public Date nextTriggerDate() {
-    Calendar nextTriggerDate = Calendar.getInstance();
-    nextTriggerDate.set(Calendar.DAY_OF_WEEK, mWeekday);
-    nextTriggerDate.set(Calendar.HOUR_OF_DAY, mHour);
-    nextTriggerDate.set(Calendar.MINUTE, mMinute);
-    nextTriggerDate.set(Calendar.SECOND, 0);
-    nextTriggerDate.set(Calendar.MILLISECOND, 0);
-    Calendar rightNow = Calendar.getInstance();
-    if (nextTriggerDate.before(rightNow)) {
-      nextTriggerDate.add(Calendar.DAY_OF_WEEK_IN_MONTH, 1);
-    }
-    return nextTriggerDate.getTime();
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    super.writeToParcel(dest, flags);
-    dest.writeInt(mWeekday);
-    dest.writeInt(mHour);
-    dest.writeInt(mMinute);
-  }
-
-  public static final Creator<WeeklyTrigger> CREATOR = new Creator<WeeklyTrigger>() {
-    @Override
-    public WeeklyTrigger createFromParcel(Parcel in) {
-      return new WeeklyTrigger(in);
-    }
-
-    @Override
-    public WeeklyTrigger[] newArray(int size) {
-      return new WeeklyTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/YearlyTrigger.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/YearlyTrigger.java
deleted file mode 100644
index 896206a..0000000
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/triggers/YearlyTrigger.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package expo.modules.notifications.notifications.triggers;
-
-import android.os.Parcel;
-
-import java.util.Calendar;
-import java.util.Date;
-
-import androidx.annotation.Nullable;
-import expo.modules.notifications.notifications.interfaces.SchedulableNotificationTrigger;
-
-/**
- * A schedulable trigger representing a notification to be scheduled once per year.
- */
-public class YearlyTrigger extends ChannelAwareTrigger implements SchedulableNotificationTrigger {
-  private int mDay;
-  private int mMonth;
-  private int mHour;
-  private int mMinute;
-
-  public YearlyTrigger(int day, int month, int hour, int minute, @Nullable String channelId) {
-    super(channelId);
-    mDay = day;
-    mMonth = month;
-    mHour = hour;
-    mMinute = minute;
-  }
-
-  private YearlyTrigger(Parcel in) {
-    super(in);
-    mDay = in.readInt();
-    mMonth = in.readInt();
-    mHour = in.readInt();
-    mMinute = in.readInt();
-  }
-
-  public int getDay() {
-    return mDay;
-  }
-
-  public int getMonth() {
-    return mMonth;
-  }
-
-  public int getHour() {
-    return mHour;
-  }
-
-  public int getMinute() {
-    return mMinute;
-  }
-
-  @Nullable
-  @Override
-  public Date nextTriggerDate() {
-    Calendar nextTriggerDate = Calendar.getInstance();
-    nextTriggerDate.set(Calendar.DATE, mDay);
-    nextTriggerDate.set(Calendar.MONTH, mMonth);
-    nextTriggerDate.set(Calendar.HOUR_OF_DAY, mHour);
-    nextTriggerDate.set(Calendar.MINUTE, mMinute);
-    nextTriggerDate.set(Calendar.SECOND, 0);
-    nextTriggerDate.set(Calendar.MILLISECOND, 0);
-    Calendar rightNow = Calendar.getInstance();
-    if (nextTriggerDate.before(rightNow)) {
-      nextTriggerDate.add(Calendar.YEAR, 1);
-    }
-    return nextTriggerDate.getTime();
-  }
-
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    super.writeToParcel(dest, flags);
-    dest.writeInt(mDay);
-    dest.writeInt(mMonth);
-    dest.writeInt(mHour);
-    dest.writeInt(mMinute);
-  }
-
-  public static final Creator<YearlyTrigger> CREATOR = new Creator<YearlyTrigger>() {
-    @Override
-    public YearlyTrigger createFromParcel(Parcel in) {
-      return new YearlyTrigger(in);
-    }
-
-    @Override
-    public YearlyTrigger[] newArray(int size) {
-      return new YearlyTrigger[size];
-    }
-  };
-}
diff --git a/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts b/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts
index b01ef92..be6a417 100644
--- a/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts
+++ b/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts
@@ -1,42 +1,55 @@
 import { ProxyNativeModule } from 'expo-modules-core';
-import { NotificationRequest, NotificationContentInput, CalendarTriggerInputValue } from './Notifications.types';
+import { NotificationRequest, NotificationContentInput } from './Notifications.types';
+type CalendarTriggerInputValue = {
+    timezone?: string;
+    year?: number;
+    month?: number;
+    weekday?: number;
+    weekOfMonth?: number;
+    weekOfYear?: number;
+    weekdayOrdinal?: number;
+    day?: number;
+    hour?: number;
+    minute?: number;
+    second?: number;
+};
 export interface NotificationSchedulerModule extends ProxyNativeModule {
     getAllScheduledNotificationsAsync?: () => Promise<NotificationRequest[]>;
-    scheduleNotificationAsync?: (identifier: string, notificationContent: NotificationContentInput, trigger: NotificationTriggerInput) => Promise<string>;
+    scheduleNotificationAsync?: (identifier: string, notificationContent: NotificationContentInput, trigger: NativeNotificationTriggerInput) => Promise<string>;
     cancelScheduledNotificationAsync?: (identifier: string) => Promise<void>;
     cancelAllScheduledNotificationsAsync?: () => Promise<void>;
-    getNextTriggerDateAsync?: (trigger: NotificationTriggerInput) => Promise<number>;
+    getNextTriggerDateAsync?: (trigger: NativeNotificationTriggerInput) => Promise<number>;
 }
-export interface ChannelAwareTriggerInput {
+export interface NativeChannelAwareTriggerInput {
     type: 'channel';
     channelId?: string;
 }
-export interface CalendarTriggerInput {
+export interface NativeCalendarTriggerInput {
     type: 'calendar';
     channelId?: string;
     repeats?: boolean;
     value: CalendarTriggerInputValue;
 }
-export interface TimeIntervalTriggerInput {
+export interface NativeTimeIntervalTriggerInput {
     type: 'timeInterval';
     channelId?: string;
     repeats: boolean;
     seconds: number;
 }
-export interface DailyTriggerInput {
+export interface NativeDailyTriggerInput {
     type: 'daily';
     channelId?: string;
     hour: number;
     minute: number;
 }
-export interface WeeklyTriggerInput {
+export interface NativeWeeklyTriggerInput {
     type: 'weekly';
     channelId?: string;
     weekday: number;
     hour: number;
     minute: number;
 }
-export interface YearlyTriggerInput {
+export interface NativeYearlyTriggerInput {
     type: 'yearly';
     channelId?: string;
     day: number;
@@ -44,10 +57,18 @@ export interface YearlyTriggerInput {
     hour: number;
     minute: number;
 }
-export interface DateTriggerInput {
+export interface NativeMonthlyTriggerInput {
+    type: 'monthly';
+    channelId?: string;
+    day: number;
+    hour: number;
+    minute: number;
+}
+export interface NativeDateTriggerInput {
     type: 'date';
     channelId?: string;
     timestamp: number;
 }
-export type NotificationTriggerInput = null | ChannelAwareTriggerInput | DateTriggerInput | CalendarTriggerInput | TimeIntervalTriggerInput | DailyTriggerInput | WeeklyTriggerInput | YearlyTriggerInput;
+export type NativeNotificationTriggerInput = null | NativeChannelAwareTriggerInput | NativeDateTriggerInput | NativeCalendarTriggerInput | NativeTimeIntervalTriggerInput | NativeDailyTriggerInput | NativeWeeklyTriggerInput | NativeMonthlyTriggerInput | NativeYearlyTriggerInput;
+export {};
 //# sourceMappingURL=NotificationScheduler.types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts.map b/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts.map
index c267036..bf41727 100644
--- a/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts.map
+++ b/node_modules/expo-notifications/build/NotificationScheduler.types.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationScheduler.types.d.ts","sourceRoot":"","sources":["../src/NotificationScheduler.types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,mBAAmB,CAAC;AAEtD,OAAO,EACL,mBAAmB,EACnB,wBAAwB,EACxB,yBAAyB,EAC1B,MAAM,uBAAuB,CAAC;AAE/B,MAAM,WAAW,2BAA4B,SAAQ,iBAAiB;IACpE,iCAAiC,CAAC,EAAE,MAAM,OAAO,CAAC,mBAAmB,EAAE,CAAC,CAAC;IACzE,yBAAyB,CAAC,EAAE,CAC1B,UAAU,EAAE,MAAM,EAClB,mBAAmB,EAAE,wBAAwB,EAC7C,OAAO,EAAE,wBAAwB,KAC9B,OAAO,CAAC,MAAM,CAAC,CAAC;IACrB,gCAAgC,CAAC,EAAE,CAAC,UAAU,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;IACzE,oCAAoC,CAAC,EAAE,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;IAC3D,uBAAuB,CAAC,EAAE,CAAC,OAAO,EAAE,wBAAwB,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC;CAClF;AAED,MAAM,WAAW,wBAAwB;IACvC,IAAI,EAAE,SAAS,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAGD,MAAM,WAAW,oBAAoB;IACnC,IAAI,EAAE,UAAU,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,KAAK,EAAE,yBAAyB,CAAC;CAClC;AAED,MAAM,WAAW,wBAAwB;IACvC,IAAI,EAAE,cAAc,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,OAAO,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;CACjB;AAED,MAAM,WAAW,iBAAiB;IAChC,IAAI,EAAE,OAAO,CAAC;IACd,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,MAAM,WAAW,kBAAkB;IACjC,IAAI,EAAE,QAAQ,CAAC;IACf,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,MAAM,WAAW,kBAAkB;IACjC,IAAI,EAAE,QAAQ,CAAC;IACf,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,GAAG,EAAE,MAAM,CAAC;IACZ,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,MAAM,WAAW,gBAAgB;IAC/B,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,MAAM,wBAAwB,GAChC,IAAI,GACJ,wBAAwB,GACxB,gBAAgB,GAChB,oBAAoB,GACpB,wBAAwB,GACxB,iBAAiB,GACjB,kBAAkB,GAClB,kBAAkB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"NotificationScheduler.types.d.ts","sourceRoot":"","sources":["../src/NotificationScheduler.types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/NotificationScheduler.types.js.map b/node_modules/expo-notifications/build/NotificationScheduler.types.js.map
index 50bf9bd..d099417 100644
--- a/node_modules/expo-notifications/build/NotificationScheduler.types.js.map
+++ b/node_modules/expo-notifications/build/NotificationScheduler.types.js.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationScheduler.types.js","sourceRoot":"","sources":["../src/NotificationScheduler.types.ts"],"names":[],"mappings":"","sourcesContent":["import { ProxyNativeModule } from 'expo-modules-core';\n\nimport {\n  NotificationRequest,\n  NotificationContentInput,\n  CalendarTriggerInputValue,\n} from './Notifications.types';\n\nexport interface NotificationSchedulerModule extends ProxyNativeModule {\n  getAllScheduledNotificationsAsync?: () => Promise<NotificationRequest[]>;\n  scheduleNotificationAsync?: (\n    identifier: string,\n    notificationContent: NotificationContentInput,\n    trigger: NotificationTriggerInput\n  ) => Promise<string>;\n  cancelScheduledNotificationAsync?: (identifier: string) => Promise<void>;\n  cancelAllScheduledNotificationsAsync?: () => Promise<void>;\n  getNextTriggerDateAsync?: (trigger: NotificationTriggerInput) => Promise<number>;\n}\n\nexport interface ChannelAwareTriggerInput {\n  type: 'channel';\n  channelId?: string;\n}\n\n// ISO8601 calendar pattern-matching\nexport interface CalendarTriggerInput {\n  type: 'calendar';\n  channelId?: string;\n  repeats?: boolean;\n  value: CalendarTriggerInputValue;\n}\n\nexport interface TimeIntervalTriggerInput {\n  type: 'timeInterval';\n  channelId?: string;\n  repeats: boolean;\n  seconds: number;\n}\n\nexport interface DailyTriggerInput {\n  type: 'daily';\n  channelId?: string;\n  hour: number;\n  minute: number;\n}\n\nexport interface WeeklyTriggerInput {\n  type: 'weekly';\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n\nexport interface YearlyTriggerInput {\n  type: 'yearly';\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n\nexport interface DateTriggerInput {\n  type: 'date';\n  channelId?: string;\n  timestamp: number; // seconds since 1970\n}\n\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | DateTriggerInput\n  | CalendarTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput;\n"]}
\ No newline at end of file
+{"version":3,"file":"NotificationScheduler.types.js","sourceRoot":"","sources":["../src/NotificationScheduler.types.ts"],"names":[],"mappings":"","sourcesContent":["import { ProxyNativeModule } from 'expo-modules-core';\n\nimport { NotificationRequest, NotificationContentInput } from './Notifications.types';\n\ntype CalendarTriggerInputValue = {\n  timezone?: string;\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n  hour?: number;\n  minute?: number;\n  second?: number;\n};\n\nexport interface NotificationSchedulerModule extends ProxyNativeModule {\n  getAllScheduledNotificationsAsync?: () => Promise<NotificationRequest[]>;\n  scheduleNotificationAsync?: (\n    identifier: string,\n    notificationContent: NotificationContentInput,\n    trigger: NativeNotificationTriggerInput\n  ) => Promise<string>;\n  cancelScheduledNotificationAsync?: (identifier: string) => Promise<void>;\n  cancelAllScheduledNotificationsAsync?: () => Promise<void>;\n  getNextTriggerDateAsync?: (trigger: NativeNotificationTriggerInput) => Promise<number>;\n}\n\nexport interface NativeChannelAwareTriggerInput {\n  type: 'channel';\n  channelId?: string;\n}\n\n// ISO8601 calendar pattern-matching\nexport interface NativeCalendarTriggerInput {\n  type: 'calendar';\n  channelId?: string;\n  repeats?: boolean;\n  value: CalendarTriggerInputValue;\n}\n\nexport interface NativeTimeIntervalTriggerInput {\n  type: 'timeInterval';\n  channelId?: string;\n  repeats: boolean;\n  seconds: number;\n}\n\nexport interface NativeDailyTriggerInput {\n  type: 'daily';\n  channelId?: string;\n  hour: number;\n  minute: number;\n}\n\nexport interface NativeWeeklyTriggerInput {\n  type: 'weekly';\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n\nexport interface NativeYearlyTriggerInput {\n  type: 'yearly';\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n\nexport interface NativeMonthlyTriggerInput {\n  type: 'monthly';\n  channelId?: string;\n  day: number;\n  hour: number;\n  minute: number;\n}\n\nexport interface NativeDateTriggerInput {\n  type: 'date';\n  channelId?: string;\n  timestamp: number; // seconds since 1970\n}\n\nexport type NativeNotificationTriggerInput =\n  | null\n  | NativeChannelAwareTriggerInput\n  | NativeDateTriggerInput\n  | NativeCalendarTriggerInput\n  | NativeTimeIntervalTriggerInput\n  | NativeDailyTriggerInput\n  | NativeWeeklyTriggerInput\n  | NativeMonthlyTriggerInput\n  | NativeYearlyTriggerInput;\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/Notifications.types.d.ts b/node_modules/expo-notifications/build/Notifications.types.d.ts
index 0256439..b68c671 100644
--- a/node_modules/expo-notifications/build/Notifications.types.d.ts
+++ b/node_modules/expo-notifications/build/Notifications.types.d.ts
@@ -150,6 +150,17 @@ export interface WeeklyNotificationTrigger {
     hour: number;
     minute: number;
 }
+/**
+ * A trigger related to a monthly notification.
+ * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.
+ * @platform android
+ */
+export interface MonthlyNotificationTrigger {
+    type: 'monthly';
+    day: number;
+    hour: number;
+    minute: number;
+}
 /**
  * A trigger related to a yearly notification.
  * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.
@@ -215,14 +226,39 @@ export interface UnknownNotificationTrigger {
 /**
  * A union type containing different triggers which may cause the notification to be delivered to the application.
  */
-export type NotificationTrigger = PushNotificationTrigger | CalendarNotificationTrigger | LocationNotificationTrigger | TimeIntervalNotificationTrigger | DailyNotificationTrigger | WeeklyNotificationTrigger | YearlyNotificationTrigger | UnknownNotificationTrigger;
+export type NotificationTrigger = PushNotificationTrigger | CalendarNotificationTrigger | LocationNotificationTrigger | TimeIntervalNotificationTrigger | DailyNotificationTrigger | WeeklyNotificationTrigger | MonthlyNotificationTrigger | YearlyNotificationTrigger | UnknownNotificationTrigger;
 /**
  * A trigger that will cause the notification to be delivered immediately.
  */
 export type ChannelAwareTriggerInput = {
     channelId: string;
 };
-export type CalendarTriggerInputValue = {
+/**
+ * Schedulable trigger inputs (that are not a plain date value or time value)
+ * must have the "type" property set to one of these values.
+ */
+export declare enum SchedulableTriggerInputTypes {
+    CALENDAR = "calendar",
+    DAILY = "daily",
+    WEEKLY = "weekly",
+    MONTHLY = "monthly",
+    YEARLY = "yearly",
+    DATE = "date",
+    TIME_INTERVAL = "timeInterval"
+}
+/**
+ * This trigger input will cause the notification to be delivered once or many times
+ * (controlled by the value of `repeats`)
+ * when the date components match the specified values.
+ * Corresponds to native
+ * [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).
+ * @platform ios
+ */
+export type CalendarTriggerInput = {
+    type: SchedulableTriggerInputTypes.CALENDAR;
+    channelId?: string;
+    repeats?: boolean;
+    seconds?: number;
     timezone?: string;
     year?: number;
     month?: number;
@@ -236,68 +272,87 @@ export type CalendarTriggerInputValue = {
     second?: number;
 };
 /**
- * A trigger that will cause the notification to be delivered once or many times when the date components match the specified values.
- * Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).
- * @platform ios
+ * This trigger input will cause the notification to be delivered once per day
+ * when the `hour` and `minute` date components match the specified values.
  */
-export type CalendarTriggerInput = CalendarTriggerInputValue & {
+export type DailyTriggerInput = {
+    type: SchedulableTriggerInputTypes.DAILY;
     channelId?: string;
-    repeats?: boolean;
+    hour: number;
+    minute: number;
 };
 /**
- * A trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.
- * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater. Otherwise, the notification won't be triggered.
- */
-export interface TimeIntervalTriggerInput {
-    channelId?: string;
-    repeats?: boolean;
-    seconds: number;
-}
-/**
- * A trigger that will cause the notification to be delivered once per day.
+ * This trigger input will cause the notification to be delivered once every week
+ * when the `weekday`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.
  */
-export interface DailyTriggerInput {
+export type WeeklyTriggerInput = {
+    type: SchedulableTriggerInputTypes.WEEKLY;
     channelId?: string;
+    weekday: number;
     hour: number;
     minute: number;
-    repeats: true;
-}
+};
 /**
- * A trigger that will cause the notification to be delivered once every week.
- * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.
+ * This trigger input will cause the notification to be delivered once per month
+ * when the `day`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** All properties are specified in JavaScript `Date` object's ranges.
  */
-export interface WeeklyTriggerInput {
+export type MonthlyTriggerInput = {
+    type: SchedulableTriggerInputTypes.MONTHLY;
     channelId?: string;
-    weekday: number;
+    day: number;
     hour: number;
     minute: number;
-    repeats: true;
-}
+};
 /**
- * A trigger that will cause the notification to be delivered once every year.
- * > **Note:** all properties are specified in JavaScript Date's ranges.
+ * This trigger input will cause the notification to be delivered once every year
+ * when the `day`, `month`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** All properties are specified in JavaScript `Date` object's ranges.
  */
-export interface YearlyTriggerInput {
+export type YearlyTriggerInput = {
+    type: SchedulableTriggerInputTypes.YEARLY;
     channelId?: string;
     day: number;
     month: number;
     hour: number;
     minute: number;
-    repeats: true;
-}
+};
 /**
- * A trigger that will cause the notification to be delivered once at the specified `Date`.
- * If you pass in a `number` it will be interpreted as a Unix timestamp.
+ * This trigger input will cause the notification to be delivered once
+ * on the specified value of the `date` property. The value of `repeats` will be ignored
+ * for this trigger type.
  */
 export type DateTriggerInput = Date | number | {
+    type: SchedulableTriggerInputTypes.DATE;
     channelId?: string;
     date: Date | number;
 };
 /**
- * A type represents time-based, schedulable triggers. For these triggers you can check the next trigger date
- * with [`getNextTriggerDateAsync`](#notificationsgetnexttriggerdateasynctrigger).
+ * This trigger input will cause the notification to be delivered once or many times
+ * (depends on the `repeats` field) after `seconds` time elapse.
+ * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater.
+ * Otherwise, the notification won't be triggered.
  */
-export type SchedulableNotificationTriggerInput = DateTriggerInput | TimeIntervalTriggerInput | DailyTriggerInput | WeeklyTriggerInput | YearlyTriggerInput | CalendarTriggerInput;
+export type TimeIntervalTriggerInput = {
+    type: SchedulableTriggerInputTypes.TIME_INTERVAL;
+    channelId?: string;
+    repeats?: boolean;
+    seconds: number;
+};
+/**
+ * Input for time-based, schedulable triggers.
+ * For these triggers you can check the next trigger date
+ * with [`getNextTriggerDateAsync`](#notificationsgetnexttriggerdateasynctrigger).
+ * If you pass in a `number` (Unix timestamp) or `Date`, it will be processed as a
+ * trigger input of type [`CalendarTriggerTypes.DATE`](#date). Otherwise, the input must be
+ * an object, with a `type` value set to one of the allowed values in
+ * [`CalendarTriggerTypes`](#calendartriggertypes).
+ * If the input is an object, date components passed in will be validated, and
+ * an error is thrown if they are outside their allowed range (for example, the `minute` and
+ * `second` components must be between 0 and 59 inclusive).
+ */
+export type SchedulableNotificationTriggerInput = CalendarTriggerInput | TimeIntervalTriggerInput | DailyTriggerInput | WeeklyTriggerInput | MonthlyTriggerInput | YearlyTriggerInput | DateTriggerInput;
 /**
  * A type represents possible triggers with which you can schedule notifications.
  * A `null` trigger means that the notification should be scheduled for delivery immediately.
diff --git a/node_modules/expo-notifications/build/Notifications.types.d.ts.map b/node_modules/expo-notifications/build/Notifications.types.d.ts.map
index de39cdd..a3e4a97 100644
--- a/node_modules/expo-notifications/build/Notifications.types.d.ts.map
+++ b/node_modules/expo-notifications/build/Notifications.types.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Notifications.types.d.ts","sourceRoot":"","sources":["../src/Notifications.types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Notifications.types.d.ts","sourceRoot":"","sources":["../src/Notifications.types.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,oBAAoB,EACpB,kBAAkB,EAClB,gBAAgB,EAChB,YAAY,EACb,MAAM,mBAAmB,CAAC;AAE3B;;;;;;GAMG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClC;;OAEG;IACH,aAAa,CAAC,EAAE,qBAAqB,CAAC;CACvC,CAAC;AAEF;;;GAGG;AACH,MAAM,WAAW,2BAA2B;IAC1C,IAAI,EAAE,UAAU,CAAC;IACjB,OAAO,EAAE,OAAO,CAAC;IACjB,cAAc,EAAE;QACd,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,cAAc,CAAC,EAAE,MAAM,CAAC;QACxB,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,iBAAiB,CAAC,EAAE,MAAM,CAAC;QAC3B,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,WAAW,EAAE,OAAO,CAAC;QACrB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;KACnB,CAAC;CACH;AAED;;;GAGG;AACH,MAAM,WAAW,MAAM;IACrB,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,UAAU,EAAE,MAAM,CAAC;IACnB;;OAEG;IACH,aAAa,EAAE,OAAO,CAAC;IACvB;;OAEG;IACH,YAAY,EAAE,OAAO,CAAC;CACvB;AAED;;;GAGG;AACH,MAAM,WAAW,cAAe,SAAQ,MAAM;IAC5C,IAAI,EAAE,UAAU,CAAC;IACjB;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IACf;;OAEG;IACH,MAAM,EAAE;QACN,QAAQ,EAAE,MAAM,CAAC;QACjB,SAAS,EAAE,MAAM,CAAC;KACnB,CAAC;CACH;AAED;;;GAGG;AACH,MAAM,WAAW,YAAa,SAAQ,MAAM;IAC1C,IAAI,EAAE,QAAQ,CAAC;IACf;;OAEG;IACH,yBAAyB,EAAE,OAAO,CAAC;IACnC;;OAEG;IACH,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB;;OAEG;IACH,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IACd;;OAEG;IACH,wBAAwB,CAAC,EAAE;QACzB,IAAI,EAAE,MAAM,CAAC;QACb,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;QACrB,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;KACtB,CAAC;CACH;AAED;;;GAGG;AACH,MAAM,WAAW,2BAA2B;IAC1C,IAAI,EAAE,UAAU,CAAC;IACjB,OAAO,EAAE,OAAO,CAAC;IACjB,MAAM,EAAE,cAAc,GAAG,YAAY,CAAC;CACvC;AAED;;GAEG;AACH,MAAM,WAAW,+BAA+B;IAC9C,IAAI,EAAE,cAAc,CAAC;IACrB,OAAO,EAAE,OAAO,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;GAIG;AACH,MAAM,WAAW,wBAAwB;IACvC,IAAI,EAAE,OAAO,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED;;;;GAIG;AACH,MAAM,WAAW,yBAAyB;IACxC,IAAI,EAAE,QAAQ,CAAC;IACf,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED;;;;GAIG;AACH,MAAM,WAAW,0BAA0B;IACzC,IAAI,EAAE,SAAS,CAAC;IAChB,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAED;;;;GAIG;AACH,MAAM,WAAW,yBAAyB;IACxC,IAAI,EAAE,QAAQ,CAAC;IACf,GAAG,EAAE,MAAM,CAAC;IACZ,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB;AAGD;;GAEG;AACH,MAAM,WAAW,qBAAqB;IACpC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC7B,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,gBAAgB,EAAE,MAAM,CAAC;IACzB,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,EAAE,MAAM,CAAC;IACjB,EAAE,EAAE,MAAM,GAAG,IAAI,CAAC;IAClB,GAAG,EAAE,MAAM,CAAC;IACZ,YAAY,EAAE,IAAI,GAAG,iCAAiC,CAAC;CACxD;AAGD,MAAM,WAAW,iCAAiC;IAChD,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,oBAAoB,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IACtC,mBAAmB,EAAE,MAAM,GAAG,IAAI,CAAC;IACnC,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB,wBAAwB,EAAE,OAAO,CAAC;IAClC,gBAAgB,EAAE,OAAO,CAAC;IAC1B,0BAA0B,EAAE,OAAO,CAAC;IACpC,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB,aAAa,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IAC/B,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,SAAS,EAAE,OAAO,CAAC;IACnB,iBAAiB,EAAE,MAAM,GAAG,IAAI,CAAC;IACjC,oBAAoB,EAAE,MAAM,GAAG,IAAI,CAAC;IACpC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB,MAAM,EAAE,OAAO,CAAC;IAChB,GAAG,EAAE,MAAM,GAAG,IAAI,CAAC;IACnB,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;IACtB,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB,qBAAqB,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IACvC,oBAAoB,EAAE,MAAM,GAAG,IAAI,CAAC;IACpC,cAAc,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IAChC,UAAU,EAAE,MAAM,GAAG,IAAI,CAAC;CAC3B;AAED;;GAEG;AACH,MAAM,WAAW,0BAA0B;IACzC,IAAI,EAAE,SAAS,CAAC;CACjB;AAED;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAC3B,uBAAuB,GACvB,2BAA2B,GAC3B,2BAA2B,GAC3B,+BAA+B,GAC/B,wBAAwB,GACxB,yBAAyB,GACzB,0BAA0B,GAC1B,yBAAyB,GACzB,0BAA0B,CAAC;AAE/B;;GAEG;AACH,MAAM,MAAM,wBAAwB,GAAG;IACrC,SAAS,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF;;;GAGG;AACH,oBAAY,4BAA4B;IACtC,QAAQ,aAAa;IACrB,KAAK,UAAU;IACf,MAAM,WAAW;IACjB,OAAO,YAAY;IACnB,MAAM,WAAW;IACjB,IAAI,SAAS;IACb,aAAa,iBAAiB;CAC/B;AAED;;;;;;;GAOG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,4BAA4B,CAAC,QAAQ,CAAC;IAC5C,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,4BAA4B,CAAC,KAAK,CAAC;IACzC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,kBAAkB,GAAG;IAC/B,IAAI,EAAE,4BAA4B,CAAC,MAAM,CAAC;IAC1C,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC,IAAI,EAAE,4BAA4B,CAAC,OAAO,CAAC;IAC3C,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,kBAAkB,GAAG;IAC/B,IAAI,EAAE,4BAA4B,CAAC,MAAM,CAAC;IAC1C,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,GAAG,EAAE,MAAM,CAAC;IACZ,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,gBAAgB,GACxB,IAAI,GACJ,MAAM,GACN;IAAE,IAAI,EAAE,4BAA4B,CAAC,IAAI,CAAC;IAAC,SAAS,CAAC,EAAE,MAAM,CAAC;IAAC,IAAI,EAAE,IAAI,GAAG,MAAM,CAAA;CAAE,CAAC;AAEzF;;;;;GAKG;AACH,MAAM,MAAM,wBAAwB,GAAG;IACrC,IAAI,EAAE,4BAA4B,CAAC,aAAa,CAAC;IACjD,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,mCAAmC,GAC3C,oBAAoB,GACpB,wBAAwB,GACxB,iBAAiB,GACjB,kBAAkB,GAClB,mBAAmB,GACnB,kBAAkB,GAClB,gBAAgB,CAAC;AAErB;;;GAGG;AACH,MAAM,MAAM,wBAAwB,GAChC,IAAI,GACJ,wBAAwB,GACxB,mCAAmC,CAAC;AAExC;;GAEG;AACH,oBAAY,2BAA2B;IACrC,GAAG,QAAQ;IACX,GAAG,QAAQ;IACX,OAAO,YAAY;IACnB,IAAI,SAAS;IACb,GAAG,QAAQ;CACZ;AAED;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC;;OAEG;IACH,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB;;;;OAIG;IACH,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB;;OAEG;IACH,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAE1B,KAAK,EAAE,SAAS,GAAG,iBAAiB,GAAG,QAAQ,GAAG,IAAI,CAAC;CACxD,GAAG,CAAC,sBAAsB,GAAG,0BAA0B,CAAC,CAAC;AAE1D;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC;;OAEG;IACH,eAAe,EAAE,MAAM,GAAG,IAAI,CAAC;IAC/B;;OAEG;IACH,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB;;OAEG;IACH,WAAW,EAAE,gCAAgC,EAAE,CAAC;IAChD;;OAEG;IACH,eAAe,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAChC;;OAEG;IACH,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B;;OAEG;IACH,kBAAkB,EAAE,MAAM,GAAG,IAAI,CAAC;IAClC;;OAEG;IACH,gBAAgB,EAAE,MAAM,GAAG,IAAI,CAAC;IAChC;;OAEG;IACH,uBAAuB,CAAC,EAAE,MAAM,CAAC;IAUjC,iBAAiB,CAAC,EAAE,SAAS,GAAG,QAAQ,GAAG,eAAe,GAAG,UAAU,CAAC;CACzE,CAAC;AAGF;;GAEG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,UAAU,EAAE,MAAM,GAAG,IAAI,CAAC;IAC1B,GAAG,EAAE,MAAM,GAAG,IAAI,CAAC;IACnB,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,aAAa,CAAC,EAAE,OAAO,CAAC;IACxB,iBAAiB,CAAC,EAAE;QAAE,CAAC,EAAE,MAAM,CAAC;QAAC,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,EAAE,MAAM,CAAC;QAAC,MAAM,EAAE,MAAM,CAAA;KAAE,CAAC;IAC5E,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,0BAA0B,GAAG;IACvC;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IACf;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IACf;;;;OAIG;IACH,QAAQ,CAAC,EAAE,2BAA2B,CAAC;IACvC;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,EAAE,CAAC;CAC7B,CAAC;AAEF;;;GAGG;AACH,MAAM,WAAW,mBAAmB;IAClC,UAAU,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,mBAAmB,CAAC;IAC7B,OAAO,EAAE,mBAAmB,CAAC;CAC9B;AAGD;;GAEG;AACH,MAAM,MAAM,wBAAwB,GAAG;IACrC;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACtB;;;;OAIG;IACH,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC3B;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,OAAO,GAAG,MAAM,CAAC;IACzB;;OAEG;IACH,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB;;;OAGG;IACH,OAAO,CAAC,EAAE,MAAM,EAAE,CAAC;IACnB;;;;;OAKG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB;;;OAGG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IACf;;;;;;;;OAQG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IACtB;;;OAGG;IACH,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B;;;;;;;;;OASG;IACH,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB;;;OAGG;IACH,WAAW,CAAC,EAAE,gCAAgC,EAAE,CAAC;IAUjD,iBAAiB,CAAC,EAAE,SAAS,GAAG,QAAQ,GAAG,eAAe,GAAG,UAAU,CAAC;CACzE,CAAC;AAEF;;GAEG;AACH,MAAM,WAAW,wBAAwB;IACvC,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,OAAO,EAAE,wBAAwB,CAAC;IAClC,OAAO,EAAE,wBAAwB,CAAC;CACnC;AAED;;GAEG;AACH,MAAM,WAAW,YAAY;IAC3B,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,mBAAmB,CAAC;CAC9B;AAED;;;GAGG;AACH,MAAM,WAAW,oBAAoB;IACnC,YAAY,EAAE,YAAY,CAAC;IAC3B,gBAAgB,EAAE,MAAM,CAAC;IACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB;AAED;;;;GAIG;AACH,MAAM,WAAW,oBAAoB;IACnC,eAAe,EAAE,OAAO,CAAC;IACzB,eAAe,EAAE,OAAO,CAAC;IACzB,cAAc,EAAE,OAAO,CAAC;IACxB,QAAQ,CAAC,EAAE,2BAA2B,CAAC;CACxC;AAED,MAAM,WAAW,kBAAkB;IACjC;;;OAGG;IACH,UAAU,EAAE,MAAM,CAAC;IACnB;;OAEG;IACH,WAAW,EAAE,MAAM,CAAC;IACpB;;OAEG;IACH,SAAS,CAAC,EAAE;QACV;;;WAGG;QACH,iBAAiB,EAAE,MAAM,CAAC;QAC1B;;WAEG;QACH,WAAW,EAAE,MAAM,CAAC;KACrB,CAAC;IACF;;OAEG;IACH,OAAO,CAAC,EAAE;QACR;;;;WAIG;QACH,aAAa,CAAC,EAAE,OAAO,CAAC;QACxB;;;WAGG;QACH,wBAAwB,CAAC,EAAE,OAAO,CAAC;QACnC;;;;;WAKG;QACH,oBAAoB,CAAC,EAAE,OAAO,CAAC;KAChC,CAAC;CACH;AAGD,MAAM,WAAW,oBAAoB;IACnC,UAAU,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,kBAAkB,EAAE,CAAC;IAC9B,OAAO,CAAC,EAAE,2BAA2B,CAAC;CACvC;AAED;;GAEG;AACH,MAAM,MAAM,2BAA2B,GAAG;IACxC;;;OAGG;IACH,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B;;;;OAIG;IACH,iBAAiB,CAAC,EAAE,MAAM,EAAE,CAAC;IAC7B;;OAEG;IACH,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAC/B;;;;OAIG;IACH,mBAAmB,CAAC,EAAE,OAAO,CAAC;IAC9B;;;OAGG;IACH,cAAc,CAAC,EAAE,OAAO,CAAC;IACzB;;;OAGG;IACH,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB;;;OAGG;IACH,YAAY,CAAC,EAAE,OAAO,CAAC;IACvB;;;OAGG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B,CAAC;AAEF,YAAY,EAAE,YAAY,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,oBAAoB,EAAE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/Notifications.types.js b/node_modules/expo-notifications/build/Notifications.types.js
index 1d3dea5..52df264 100644
--- a/node_modules/expo-notifications/build/Notifications.types.js
+++ b/node_modules/expo-notifications/build/Notifications.types.js
@@ -1,3 +1,17 @@
+/**
+ * Schedulable trigger inputs (that are not a plain date value or time value)
+ * must have the "type" property set to one of these values.
+ */
+export var SchedulableTriggerInputTypes;
+(function (SchedulableTriggerInputTypes) {
+    SchedulableTriggerInputTypes["CALENDAR"] = "calendar";
+    SchedulableTriggerInputTypes["DAILY"] = "daily";
+    SchedulableTriggerInputTypes["WEEKLY"] = "weekly";
+    SchedulableTriggerInputTypes["MONTHLY"] = "monthly";
+    SchedulableTriggerInputTypes["YEARLY"] = "yearly";
+    SchedulableTriggerInputTypes["DATE"] = "date";
+    SchedulableTriggerInputTypes["TIME_INTERVAL"] = "timeInterval";
+})(SchedulableTriggerInputTypes || (SchedulableTriggerInputTypes = {}));
 /**
  * An enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.
  */
diff --git a/node_modules/expo-notifications/build/Notifications.types.js.map b/node_modules/expo-notifications/build/Notifications.types.js.map
index 0ce7f00..2d880cc 100644
--- a/node_modules/expo-notifications/build/Notifications.types.js.map
+++ b/node_modules/expo-notifications/build/Notifications.types.js.map
@@ -1 +1 @@
-{"version":3,"file":"Notifications.types.js","sourceRoot":"","sources":["../src/Notifications.types.ts"],"names":[],"mappings":"AAgWA;;GAEG;AACH,MAAM,CAAN,IAAY,2BAMX;AAND,WAAY,2BAA2B;IACrC,0CAAW,CAAA;IACX,0CAAW,CAAA;IACX,kDAAmB,CAAA;IACnB,4CAAa,CAAA;IACb,0CAAW,CAAA;AACb,CAAC,EANW,2BAA2B,KAA3B,2BAA2B,QAMtC","sourcesContent":["import type {\n  PermissionExpiration,\n  PermissionResponse,\n  PermissionStatus,\n  Subscription,\n} from 'expo-modules-core';\n\n/**\n * An object represents a notification delivered by a push notification system.\n *\n * On Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n * On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), for example [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n * On web there is no extra data.\n */\nexport type PushNotificationTrigger = {\n  type: 'push';\n  /**\n   * @platform ios\n   */\n  payload?: Record<string, unknown>;\n  /**\n   * @platform android\n   */\n  remoteMessage?: FirebaseRemoteMessage;\n};\n\n/**\n * A trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n * @platform ios\n */\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n\n/**\n * The region used to determine when the system sends the notification.\n * @platform ios\n */\nexport interface Region {\n  type: string;\n  /**\n   * The identifier for the region object.\n   */\n  identifier: string;\n  /**\n   * A Boolean indicating that notifications are generated upon entry into the region.\n   */\n  notifyOnEntry: boolean;\n  /**\n   * A Boolean indicating that notifications are generated upon exit from the region.\n   */\n  notifyOnExit: boolean;\n}\n\n/**\n * A circular geographic region, specified as a center point and radius. Based on Core Location [`CLCircularRegion`](https://developer.apple.com/documentation/corelocation/clcircularregion) class.\n * @platform ios\n */\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  /**\n   * The radius (measured in meters) that defines the geographic area’s outer boundary.\n   */\n  radius: number;\n  /**\n   * The center point of the geographic area.\n   */\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\n/**\n * A region used to detect the presence of iBeacon devices. Based on Core Location [`CLBeaconRegion`](https://developer.apple.com/documentation/corelocation/clbeaconregion) class.\n * @platform ios\n */\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  /**\n   * A Boolean value that indicates whether Core Location sends beacon notifications when the device’s display is on.\n   */\n  notifyEntryStateOnDisplay: boolean;\n  /**\n   * The major value from the beacon identity constraint that defines the beacon region.\n   */\n  major: number | null;\n  /**\n   * The minor value from the beacon identity constraint that defines the beacon region.\n   */\n  minor: number | null;\n  /**\n   * The UUID value from the beacon identity constraint that defines the beacon region.\n   */\n  uuid?: string;\n  /**\n   * The beacon identity constraint that defines the beacon region.\n   */\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n\n/**\n * A trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc).\n * @platform ios\n */\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\n/**\n * A trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n */\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n\n/**\n * A trigger related to a daily notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n\n/**\n * A trigger related to a weekly notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n\n/**\n * A trigger related to a yearly notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n\n// @docsMissing\n/**\n * A Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n */\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: Record<string, string>;\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | FirebaseRemoteMessageNotification;\n}\n\n// @docsMissing\nexport interface FirebaseRemoteMessageNotification {\n  body: string | null;\n  bodyLocalizationArgs: string[] | null;\n  bodyLocalizationKey: string | null;\n  channelId: string | null;\n  clickAction: string | null;\n  color: string | null;\n  usesDefaultLightSettings: boolean;\n  usesDefaultSound: boolean;\n  usesDefaultVibrateSettings: boolean;\n  eventTime: number | null;\n  icon: string | null;\n  imageUrl: string | null;\n  lightSettings: number[] | null;\n  link: string | null;\n  localOnly: boolean;\n  notificationCount: number | null;\n  notificationPriority: number | null;\n  sound: string | null;\n  sticky: boolean;\n  tag: string | null;\n  ticker: string | null;\n  title: string | null;\n  titleLocalizationArgs: string[] | null;\n  titleLocalizationKey: string | null;\n  vibrateTimings: number[] | null;\n  visibility: number | null;\n}\n\n/**\n * Represents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n */\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n\n/**\n * A union type containing different triggers which may cause the notification to be delivered to the application.\n */\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n\n/**\n * A trigger that will cause the notification to be delivered immediately.\n */\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n\n// @docsMissing\nexport type CalendarTriggerInputValue = {\n  timezone?: string;\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n  hour?: number;\n  minute?: number;\n  second?: number;\n};\n\n/**\n * A trigger that will cause the notification to be delivered once or many times when the date components match the specified values.\n * Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n * @platform ios\n */\nexport type CalendarTriggerInput = CalendarTriggerInputValue & {\n  channelId?: string;\n  repeats?: boolean;\n};\n\n/**\n * A trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater. Otherwise, the notification won't be triggered.\n */\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n\n/**\n * A trigger that will cause the notification to be delivered once per day.\n */\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n\n/**\n * A trigger that will cause the notification to be delivered once every week.\n * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.\n */\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n\n/**\n * A trigger that will cause the notification to be delivered once every year.\n * > **Note:** all properties are specified in JavaScript Date's ranges.\n */\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n\n/**\n * A trigger that will cause the notification to be delivered once at the specified `Date`.\n * If you pass in a `number` it will be interpreted as a Unix timestamp.\n */\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n\n/**\n * A type represents time-based, schedulable triggers. For these triggers you can check the next trigger date\n * with [`getNextTriggerDateAsync`](#notificationsgetnexttriggerdateasynctrigger).\n */\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n\n/**\n * A type represents possible triggers with which you can schedule notifications.\n * A `null` trigger means that the notification should be scheduled for delivery immediately.\n */\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n\n/**\n * An enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n */\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n\n/**\n * An object represents notification's content.\n */\nexport type NotificationContent = {\n  /**\n   * Notification title - the bold text displayed above the rest of the content.\n   */\n  title: string | null;\n  /**\n   * On Android: `subText` - the display depends on the device.\n   *\n   * On iOS: `subtitle` - the bold text displayed between title and the rest of the content.\n   */\n  subtitle: string | null;\n  /**\n   * Notification body - the main content of the notification.\n   */\n  body: string | null;\n  /**\n   * Data associated with the notification, not displayed\n   */\n  data: Record<string, any>;\n  // @docsMissing\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (NotificationContentIos | NotificationContentAndroid);\n\n/**\n * See [Apple documentation](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) for more information on specific fields.\n */\nexport type NotificationContentIos = {\n  /**\n   * The name of the image or storyboard to use when your app launches because of the notification.\n   */\n  launchImageName: string | null;\n  /**\n   * The number that your app’s icon displays.\n   */\n  badge: number | null;\n  /**\n   * The visual and audio attachments to display alongside the notification’s main content.\n   */\n  attachments: NotificationContentAttachmentIos[];\n  /**\n   * The text the system adds to the notification summary to provide additional context.\n   */\n  summaryArgument?: string | null;\n  /**\n   * The number the system adds to the notification summary when the notification represents multiple items.\n   */\n  summaryArgumentCount?: number;\n  /**\n   * The identifier of the notification’s category.\n   */\n  categoryIdentifier: string | null;\n  /**\n   * The identifier that groups related notifications.\n   */\n  threadIdentifier: string | null;\n  /**\n   * The value your app uses to determine which scene to display to handle the notification.\n   */\n  targetContentIdentifier?: string;\n  /*\n   * The notification’s importance and required delivery timing.\n   * Posible values:\n   * - 'passive' - the system adds the notification to the notification list without lighting up the screen or playing a sound\n   * - 'active' - the system presents the notification immediately, lights up the screen, and can play a sound\n   * - 'timeSensitive' - The system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls\n   * - 'critical - the system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound\n   * @platform ios 15+\n   */\n  interruptionLevel?: 'passive' | 'active' | 'timeSensitive' | 'critical';\n};\n\n// @docsMissing\n/**\n * @platform ios\n */\nexport type NotificationContentAttachmentIos = {\n  identifier: string | null;\n  url: string | null;\n  type: string | null;\n  typeHint?: string;\n  hideThumbnail?: boolean;\n  thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n  thumbnailTime?: number;\n};\n\n/**\n * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification#fields) for more information on specific fields.\n */\nexport type NotificationContentAndroid = {\n  /**\n   * Application badge number associated with the notification.\n   */\n  badge?: number;\n  /**\n   * Accent color (in `#AARRGGBB` or `#RRGGBB` format) to be applied by the standard Style templates when presenting this notification.\n   */\n  color?: string;\n  /**\n   * Relative priority for this notification. Priority is an indication of how much of the user's valuable attention should be consumed by this notification.\n   * Low-priority notifications may be hidden from the user in certain situations, while the user might be interrupted for a higher-priority notification.\n   * The system will make a determination about how to interpret this priority when presenting the notification.\n   */\n  priority?: AndroidNotificationPriority;\n  /**\n   * The pattern with which to vibrate.\n   */\n  vibrationPattern?: number[];\n};\n\n/**\n * An object represents a request to present a notification. It has content — how it's being represented, and a trigger — what triggers the notification.\n * Many notifications ([`Notification`](#notification)) may be triggered with the same request (for example, a repeating notification).\n */\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n\n// TODO(simek): asses if we can base this type on `NotificationContent`, since most of the fields looks like repetition\n/**\n * An object represents notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n */\nexport type NotificationContentInput = {\n  /**\n   * Notification title - the bold text displayed above the rest of the content.\n   */\n  title?: string | null;\n  /**\n   * On Android: `subText` - the display depends on the device.\n   *\n   * On iOS: `subtitle` - the bold text displayed between title and the rest of the content.\n   */\n  subtitle?: string | null;\n  /**\n   * The main content of the notification.\n   */\n  body?: string | null;\n  /**\n   * Data associated with the notification, not displayed.\n   */\n  data?: Record<string, any>;\n  /**\n   * Application badge number associated with the notification.\n   */\n  badge?: number;\n  sound?: boolean | string;\n  /**\n   * The name of the image or storyboard to use when your app launches because of the notification.\n   */\n  launchImageName?: string;\n  /**\n   * The pattern with which to vibrate.\n   * @platform android\n   */\n  vibrate?: number[];\n  /**\n   * Relative priority for this notification. Priority is an indication of how much of the user's valuable attention should be consumed by this notification.\n   * Low-priority notifications may be hidden from the user in certain situations, while the user might be interrupted for a higher-priority notification.\n   * The system will make a determination about how to interpret this priority when presenting the notification.\n   * @platform android\n   */\n  priority?: string;\n  /**\n   * Accent color (in `#AARRGGBB` or `#RRGGBB` format) to be applied by the standard Style templates when presenting this notification.\n   * @platform android\n   */\n  color?: string;\n  /**\n   * If set to `false`, the notification will not be automatically dismissed when clicked.\n   * The setting will be used when the value is not provided or is invalid is set to `true`, and the notification\n   * will be dismissed automatically anyway. Corresponds directly to Android's `setAutoCancel` behavior.\n   *\n   * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean))\n   * for more details.\n   * @platform android\n   */\n  autoDismiss?: boolean;\n  /**\n   * The identifier of the notification’s category.\n   * @platform ios\n   */\n  categoryIdentifier?: string;\n  /**\n   * If set to `true`, the notification cannot be dismissed by swipe. This setting defaults\n   * to `false` if not provided or is invalid. Corresponds directly do Android's `isOngoing` behavior.\n   * In Firebase terms this property of a notification is called `sticky`.\n   *\n   * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification.Builder#setOngoing(boolean))\n   * and [Firebase documentation](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky)\n   * for more details.\n   * @platform android\n   */\n  sticky?: boolean;\n  /**\n   * The visual and audio attachments to display alongside the notification’s main content.\n   * @platform ios\n   */\n  attachments?: NotificationContentAttachmentIos[];\n  /*\n   * The notification’s importance and required delivery timing.\n   * Posible values:\n   * - 'passive' - the system adds the notification to the notification list without lighting up the screen or playing a sound\n   * - 'active' - the system presents the notification immediately, lights up the screen, and can play a sound\n   * - 'timeSensitive' - The system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls\n   * - 'critical - the system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound\n   * @platform ios 15+\n   */\n  interruptionLevel?: 'passive' | 'active' | 'timeSensitive' | 'critical';\n};\n\n/**\n * An object represents a notification request you can pass into `scheduleNotificationAsync`.\n */\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n\n/**\n * An object represents a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n */\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n\n/**\n * An object represents user's interaction with the notification.\n * > **Note:** If the user taps on a notification `actionIdentifier` will be equal to [`Notifications.DEFAULT_ACTION_IDENTIFIER`](#notificationsdefault_action_identifier).\n */\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n\n/**\n * An object represents behavior that should be applied to the incoming notification.\n * > On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is.\n * > This setting will also override any channel-specific sounds you may have configured.\n */\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n\nexport interface NotificationAction {\n  /**\n   * A unique string that identifies this action. If a user takes this action (for example, selects this button in the system's Notification UI),\n   * your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener).\n   */\n  identifier: string;\n  /**\n   * The title of the button triggering this action.\n   */\n  buttonTitle: string;\n  /**\n   * Object which, if provided, will result in a button that prompts the user for a text response.\n   */\n  textInput?: {\n    /**\n     * A string which will be used as the title for the button used for submitting the text response.\n     * @platform ios\n     */\n    submitButtonTitle: string;\n    /**\n     * A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n     */\n    placeholder: string;\n  };\n  /**\n   * Object representing the additional configuration options.\n   */\n  options?: {\n    /**\n     * Boolean indicating whether the button title will be highlighted a different color (usually red).\n     * This usually signifies a destructive action such as deleting data.\n     * @platform ios\n     */\n    isDestructive?: boolean;\n    /**\n     * Boolean indicating whether triggering the action will require authentication from the user.\n     * @platform ios\n     */\n    isAuthenticationRequired?: boolean;\n    /**\n     * Boolean indicating whether triggering this action foregrounds the app.\n     * If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener)\n     * will not be triggered when a user selects this action.\n     * @default true\n     */\n    opensAppToForeground?: boolean;\n  };\n}\n\n// @docsMissing\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options?: NotificationCategoryOptions;\n}\n\n/**\n * @platform ios\n */\nexport type NotificationCategoryOptions = {\n  /**\n   * Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app.\n   * Defaults to the localized iOS system default placeholder (`Notification`).\n   */\n  previewPlaceholder?: string;\n  /**\n   * Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered,\n   * the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri.\n   * @default []\n   */\n  intentIdentifiers?: string[];\n  /**\n   * A format string for the summary description used when the system groups the category’s notifications.\n   */\n  categorySummaryFormat?: string;\n  /**\n   * A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss\n   * the notification interface - ignoring a notification or flicking away a notification banner does not trigger this action).\n   * @default false\n   */\n  customDismissAction?: boolean;\n  /**\n   * A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.**\n   * @default false\n   */\n  allowInCarPlay?: boolean;\n  /**\n   * A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app.\n   * @default false\n   */\n  showTitle?: boolean;\n  /**\n   * A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app.\n   * @default false\n   */\n  showSubtitle?: boolean;\n  /**\n   * A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods.\n   * @default false\n   */\n  allowAnnouncement?: boolean;\n};\n\nexport type { Subscription, PermissionResponse, PermissionStatus, PermissionExpiration };\n"]}
\ No newline at end of file
+{"version":3,"file":"Notifications.types.js","sourceRoot":"","sources":["../src/Notifications.types.ts"],"names":[],"mappings":"AA4QA;;;GAGG;AACH,MAAM,CAAN,IAAY,4BAQX;AARD,WAAY,4BAA4B;IACtC,qDAAqB,CAAA;IACrB,+CAAe,CAAA;IACf,iDAAiB,CAAA;IACjB,mDAAmB,CAAA;IACnB,iDAAiB,CAAA;IACjB,6CAAa,CAAA;IACb,8DAA8B,CAAA;AAChC,CAAC,EARW,4BAA4B,KAA5B,4BAA4B,QAQvC;AAoID;;GAEG;AACH,MAAM,CAAN,IAAY,2BAMX;AAND,WAAY,2BAA2B;IACrC,0CAAW,CAAA;IACX,0CAAW,CAAA;IACX,kDAAmB,CAAA;IACnB,4CAAa,CAAA;IACb,0CAAW,CAAA;AACb,CAAC,EANW,2BAA2B,KAA3B,2BAA2B,QAMtC","sourcesContent":["import type {\n  PermissionExpiration,\n  PermissionResponse,\n  PermissionStatus,\n  Subscription,\n} from 'expo-modules-core';\n\n/**\n * An object represents a notification delivered by a push notification system.\n *\n * On Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n * On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), for example [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n * On web there is no extra data.\n */\nexport type PushNotificationTrigger = {\n  type: 'push';\n  /**\n   * @platform ios\n   */\n  payload?: Record<string, unknown>;\n  /**\n   * @platform android\n   */\n  remoteMessage?: FirebaseRemoteMessage;\n};\n\n/**\n * A trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n * @platform ios\n */\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n\n/**\n * The region used to determine when the system sends the notification.\n * @platform ios\n */\nexport interface Region {\n  type: string;\n  /**\n   * The identifier for the region object.\n   */\n  identifier: string;\n  /**\n   * A Boolean indicating that notifications are generated upon entry into the region.\n   */\n  notifyOnEntry: boolean;\n  /**\n   * A Boolean indicating that notifications are generated upon exit from the region.\n   */\n  notifyOnExit: boolean;\n}\n\n/**\n * A circular geographic region, specified as a center point and radius. Based on Core Location [`CLCircularRegion`](https://developer.apple.com/documentation/corelocation/clcircularregion) class.\n * @platform ios\n */\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  /**\n   * The radius (measured in meters) that defines the geographic area’s outer boundary.\n   */\n  radius: number;\n  /**\n   * The center point of the geographic area.\n   */\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\n/**\n * A region used to detect the presence of iBeacon devices. Based on Core Location [`CLBeaconRegion`](https://developer.apple.com/documentation/corelocation/clbeaconregion) class.\n * @platform ios\n */\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  /**\n   * A Boolean value that indicates whether Core Location sends beacon notifications when the device’s display is on.\n   */\n  notifyEntryStateOnDisplay: boolean;\n  /**\n   * The major value from the beacon identity constraint that defines the beacon region.\n   */\n  major: number | null;\n  /**\n   * The minor value from the beacon identity constraint that defines the beacon region.\n   */\n  minor: number | null;\n  /**\n   * The UUID value from the beacon identity constraint that defines the beacon region.\n   */\n  uuid?: string;\n  /**\n   * The beacon identity constraint that defines the beacon region.\n   */\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n\n/**\n * A trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc).\n * @platform ios\n */\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\n/**\n * A trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n */\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n\n/**\n * A trigger related to a daily notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n\n/**\n * A trigger related to a weekly notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n\n/**\n * A trigger related to a monthly notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface MonthlyNotificationTrigger {\n  type: 'monthly';\n  day: number;\n  hour: number;\n  minute: number;\n}\n\n/**\n * A trigger related to a yearly notification.\n * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n * @platform android\n */\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n\n// @docsMissing\n/**\n * A Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n */\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: Record<string, string>;\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | FirebaseRemoteMessageNotification;\n}\n\n// @docsMissing\nexport interface FirebaseRemoteMessageNotification {\n  body: string | null;\n  bodyLocalizationArgs: string[] | null;\n  bodyLocalizationKey: string | null;\n  channelId: string | null;\n  clickAction: string | null;\n  color: string | null;\n  usesDefaultLightSettings: boolean;\n  usesDefaultSound: boolean;\n  usesDefaultVibrateSettings: boolean;\n  eventTime: number | null;\n  icon: string | null;\n  imageUrl: string | null;\n  lightSettings: number[] | null;\n  link: string | null;\n  localOnly: boolean;\n  notificationCount: number | null;\n  notificationPriority: number | null;\n  sound: string | null;\n  sticky: boolean;\n  tag: string | null;\n  ticker: string | null;\n  title: string | null;\n  titleLocalizationArgs: string[] | null;\n  titleLocalizationKey: string | null;\n  vibrateTimings: number[] | null;\n  visibility: number | null;\n}\n\n/**\n * Represents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n */\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n\n/**\n * A union type containing different triggers which may cause the notification to be delivered to the application.\n */\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | MonthlyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n\n/**\n * A trigger that will cause the notification to be delivered immediately.\n */\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n\n/**\n * Schedulable trigger inputs (that are not a plain date value or time value)\n * must have the \"type\" property set to one of these values.\n */\nexport enum SchedulableTriggerInputTypes {\n  CALENDAR = 'calendar',\n  DAILY = 'daily',\n  WEEKLY = 'weekly',\n  MONTHLY = 'monthly',\n  YEARLY = 'yearly',\n  DATE = 'date',\n  TIME_INTERVAL = 'timeInterval',\n}\n\n/**\n * This trigger input will cause the notification to be delivered once or many times\n * (controlled by the value of `repeats`)\n * when the date components match the specified values.\n * Corresponds to native\n * [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n * @platform ios\n */\nexport type CalendarTriggerInput = {\n  type: SchedulableTriggerInputTypes.CALENDAR;\n  channelId?: string;\n  repeats?: boolean;\n  seconds?: number;\n  timezone?: string;\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n  hour?: number;\n  minute?: number;\n  second?: number;\n};\n\n/**\n * This trigger input will cause the notification to be delivered once per day\n * when the `hour` and `minute` date components match the specified values.\n */\nexport type DailyTriggerInput = {\n  type: SchedulableTriggerInputTypes.DAILY;\n  channelId?: string;\n  hour: number;\n  minute: number;\n};\n\n/**\n * This trigger input will cause the notification to be delivered once every week\n * when the `weekday`, `hour`, and `minute` date components match the specified values.\n * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.\n */\nexport type WeeklyTriggerInput = {\n  type: SchedulableTriggerInputTypes.WEEKLY;\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n};\n\n/**\n * This trigger input will cause the notification to be delivered once per month\n * when the `day`, `hour`, and `minute` date components match the specified values.\n * > **Note:** All properties are specified in JavaScript `Date` object's ranges.\n */\nexport type MonthlyTriggerInput = {\n  type: SchedulableTriggerInputTypes.MONTHLY;\n  channelId?: string;\n  day: number;\n  hour: number;\n  minute: number;\n};\n\n/**\n * This trigger input will cause the notification to be delivered once every year\n * when the `day`, `month`, `hour`, and `minute` date components match the specified values.\n * > **Note:** All properties are specified in JavaScript `Date` object's ranges.\n */\nexport type YearlyTriggerInput = {\n  type: SchedulableTriggerInputTypes.YEARLY;\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n};\n\n/**\n * This trigger input will cause the notification to be delivered once\n * on the specified value of the `date` property. The value of `repeats` will be ignored\n * for this trigger type.\n */\nexport type DateTriggerInput =\n  | Date\n  | number\n  | { type: SchedulableTriggerInputTypes.DATE; channelId?: string; date: Date | number };\n\n/**\n * This trigger input will cause the notification to be delivered once or many times\n * (depends on the `repeats` field) after `seconds` time elapse.\n * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater.\n * Otherwise, the notification won't be triggered.\n */\nexport type TimeIntervalTriggerInput = {\n  type: SchedulableTriggerInputTypes.TIME_INTERVAL;\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n};\n\n/**\n * Input for time-based, schedulable triggers.\n * For these triggers you can check the next trigger date\n * with [`getNextTriggerDateAsync`](#notificationsgetnexttriggerdateasynctrigger).\n * If you pass in a `number` (Unix timestamp) or `Date`, it will be processed as a\n * trigger input of type [`CalendarTriggerTypes.DATE`](#date). Otherwise, the input must be\n * an object, with a `type` value set to one of the allowed values in\n * [`CalendarTriggerTypes`](#calendartriggertypes).\n * If the input is an object, date components passed in will be validated, and\n * an error is thrown if they are outside their allowed range (for example, the `minute` and\n * `second` components must be between 0 and 59 inclusive).\n */\nexport type SchedulableNotificationTriggerInput =\n  | CalendarTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | MonthlyTriggerInput\n  | YearlyTriggerInput\n  | DateTriggerInput;\n\n/**\n * A type represents possible triggers with which you can schedule notifications.\n * A `null` trigger means that the notification should be scheduled for delivery immediately.\n */\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n\n/**\n * An enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n */\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n\n/**\n * An object represents notification's content.\n */\nexport type NotificationContent = {\n  /**\n   * Notification title - the bold text displayed above the rest of the content.\n   */\n  title: string | null;\n  /**\n   * On Android: `subText` - the display depends on the device.\n   *\n   * On iOS: `subtitle` - the bold text displayed between title and the rest of the content.\n   */\n  subtitle: string | null;\n  /**\n   * Notification body - the main content of the notification.\n   */\n  body: string | null;\n  /**\n   * Data associated with the notification, not displayed\n   */\n  data: Record<string, any>;\n  // @docsMissing\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (NotificationContentIos | NotificationContentAndroid);\n\n/**\n * See [Apple documentation](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) for more information on specific fields.\n */\nexport type NotificationContentIos = {\n  /**\n   * The name of the image or storyboard to use when your app launches because of the notification.\n   */\n  launchImageName: string | null;\n  /**\n   * The number that your app’s icon displays.\n   */\n  badge: number | null;\n  /**\n   * The visual and audio attachments to display alongside the notification’s main content.\n   */\n  attachments: NotificationContentAttachmentIos[];\n  /**\n   * The text the system adds to the notification summary to provide additional context.\n   */\n  summaryArgument?: string | null;\n  /**\n   * The number the system adds to the notification summary when the notification represents multiple items.\n   */\n  summaryArgumentCount?: number;\n  /**\n   * The identifier of the notification’s category.\n   */\n  categoryIdentifier: string | null;\n  /**\n   * The identifier that groups related notifications.\n   */\n  threadIdentifier: string | null;\n  /**\n   * The value your app uses to determine which scene to display to handle the notification.\n   */\n  targetContentIdentifier?: string;\n  /*\n   * The notification’s importance and required delivery timing.\n   * Posible values:\n   * - 'passive' - the system adds the notification to the notification list without lighting up the screen or playing a sound\n   * - 'active' - the system presents the notification immediately, lights up the screen, and can play a sound\n   * - 'timeSensitive' - The system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls\n   * - 'critical - the system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound\n   * @platform ios 15+\n   */\n  interruptionLevel?: 'passive' | 'active' | 'timeSensitive' | 'critical';\n};\n\n// @docsMissing\n/**\n * @platform ios\n */\nexport type NotificationContentAttachmentIos = {\n  identifier: string | null;\n  url: string | null;\n  type: string | null;\n  typeHint?: string;\n  hideThumbnail?: boolean;\n  thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n  thumbnailTime?: number;\n};\n\n/**\n * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification#fields) for more information on specific fields.\n */\nexport type NotificationContentAndroid = {\n  /**\n   * Application badge number associated with the notification.\n   */\n  badge?: number;\n  /**\n   * Accent color (in `#AARRGGBB` or `#RRGGBB` format) to be applied by the standard Style templates when presenting this notification.\n   */\n  color?: string;\n  /**\n   * Relative priority for this notification. Priority is an indication of how much of the user's valuable attention should be consumed by this notification.\n   * Low-priority notifications may be hidden from the user in certain situations, while the user might be interrupted for a higher-priority notification.\n   * The system will make a determination about how to interpret this priority when presenting the notification.\n   */\n  priority?: AndroidNotificationPriority;\n  /**\n   * The pattern with which to vibrate.\n   */\n  vibrationPattern?: number[];\n};\n\n/**\n * An object represents a request to present a notification. It has content — how it's being represented, and a trigger — what triggers the notification.\n * Many notifications ([`Notification`](#notification)) may be triggered with the same request (for example, a repeating notification).\n */\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n\n// TODO(simek): asses if we can base this type on `NotificationContent`, since most of the fields looks like repetition\n/**\n * An object represents notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n */\nexport type NotificationContentInput = {\n  /**\n   * Notification title - the bold text displayed above the rest of the content.\n   */\n  title?: string | null;\n  /**\n   * On Android: `subText` - the display depends on the device.\n   *\n   * On iOS: `subtitle` - the bold text displayed between title and the rest of the content.\n   */\n  subtitle?: string | null;\n  /**\n   * The main content of the notification.\n   */\n  body?: string | null;\n  /**\n   * Data associated with the notification, not displayed.\n   */\n  data?: Record<string, any>;\n  /**\n   * Application badge number associated with the notification.\n   */\n  badge?: number;\n  sound?: boolean | string;\n  /**\n   * The name of the image or storyboard to use when your app launches because of the notification.\n   */\n  launchImageName?: string;\n  /**\n   * The pattern with which to vibrate.\n   * @platform android\n   */\n  vibrate?: number[];\n  /**\n   * Relative priority for this notification. Priority is an indication of how much of the user's valuable attention should be consumed by this notification.\n   * Low-priority notifications may be hidden from the user in certain situations, while the user might be interrupted for a higher-priority notification.\n   * The system will make a determination about how to interpret this priority when presenting the notification.\n   * @platform android\n   */\n  priority?: string;\n  /**\n   * Accent color (in `#AARRGGBB` or `#RRGGBB` format) to be applied by the standard Style templates when presenting this notification.\n   * @platform android\n   */\n  color?: string;\n  /**\n   * If set to `false`, the notification will not be automatically dismissed when clicked.\n   * The setting will be used when the value is not provided or is invalid is set to `true`, and the notification\n   * will be dismissed automatically anyway. Corresponds directly to Android's `setAutoCancel` behavior.\n   *\n   * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean))\n   * for more details.\n   * @platform android\n   */\n  autoDismiss?: boolean;\n  /**\n   * The identifier of the notification’s category.\n   * @platform ios\n   */\n  categoryIdentifier?: string;\n  /**\n   * If set to `true`, the notification cannot be dismissed by swipe. This setting defaults\n   * to `false` if not provided or is invalid. Corresponds directly do Android's `isOngoing` behavior.\n   * In Firebase terms this property of a notification is called `sticky`.\n   *\n   * See [Android developer documentation](https://developer.android.com/reference/android/app/Notification.Builder#setOngoing(boolean))\n   * and [Firebase documentation](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky)\n   * for more details.\n   * @platform android\n   */\n  sticky?: boolean;\n  /**\n   * The visual and audio attachments to display alongside the notification’s main content.\n   * @platform ios\n   */\n  attachments?: NotificationContentAttachmentIos[];\n  /*\n   * The notification’s importance and required delivery timing.\n   * Posible values:\n   * - 'passive' - the system adds the notification to the notification list without lighting up the screen or playing a sound\n   * - 'active' - the system presents the notification immediately, lights up the screen, and can play a sound\n   * - 'timeSensitive' - The system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls\n   * - 'critical - the system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound\n   * @platform ios 15+\n   */\n  interruptionLevel?: 'passive' | 'active' | 'timeSensitive' | 'critical';\n};\n\n/**\n * An object represents a notification request you can pass into `scheduleNotificationAsync`.\n */\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n\n/**\n * An object represents a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n */\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n\n/**\n * An object represents user's interaction with the notification.\n * > **Note:** If the user taps on a notification `actionIdentifier` will be equal to [`Notifications.DEFAULT_ACTION_IDENTIFIER`](#notificationsdefault_action_identifier).\n */\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n\n/**\n * An object represents behavior that should be applied to the incoming notification.\n * > On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is.\n * > This setting will also override any channel-specific sounds you may have configured.\n */\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n\nexport interface NotificationAction {\n  /**\n   * A unique string that identifies this action. If a user takes this action (for example, selects this button in the system's Notification UI),\n   * your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener).\n   */\n  identifier: string;\n  /**\n   * The title of the button triggering this action.\n   */\n  buttonTitle: string;\n  /**\n   * Object which, if provided, will result in a button that prompts the user for a text response.\n   */\n  textInput?: {\n    /**\n     * A string which will be used as the title for the button used for submitting the text response.\n     * @platform ios\n     */\n    submitButtonTitle: string;\n    /**\n     * A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n     */\n    placeholder: string;\n  };\n  /**\n   * Object representing the additional configuration options.\n   */\n  options?: {\n    /**\n     * Boolean indicating whether the button title will be highlighted a different color (usually red).\n     * This usually signifies a destructive action such as deleting data.\n     * @platform ios\n     */\n    isDestructive?: boolean;\n    /**\n     * Boolean indicating whether triggering the action will require authentication from the user.\n     * @platform ios\n     */\n    isAuthenticationRequired?: boolean;\n    /**\n     * Boolean indicating whether triggering this action foregrounds the app.\n     * If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener)\n     * will not be triggered when a user selects this action.\n     * @default true\n     */\n    opensAppToForeground?: boolean;\n  };\n}\n\n// @docsMissing\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options?: NotificationCategoryOptions;\n}\n\n/**\n * @platform ios\n */\nexport type NotificationCategoryOptions = {\n  /**\n   * Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app.\n   * Defaults to the localized iOS system default placeholder (`Notification`).\n   */\n  previewPlaceholder?: string;\n  /**\n   * Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered,\n   * the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri.\n   * @default []\n   */\n  intentIdentifiers?: string[];\n  /**\n   * A format string for the summary description used when the system groups the category’s notifications.\n   */\n  categorySummaryFormat?: string;\n  /**\n   * A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss\n   * the notification interface - ignoring a notification or flicking away a notification banner does not trigger this action).\n   * @default false\n   */\n  customDismissAction?: boolean;\n  /**\n   * A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.**\n   * @default false\n   */\n  allowInCarPlay?: boolean;\n  /**\n   * A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app.\n   * @default false\n   */\n  showTitle?: boolean;\n  /**\n   * A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app.\n   * @default false\n   */\n  showSubtitle?: boolean;\n  /**\n   * A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods.\n   * @default false\n   */\n  allowAnnouncement?: boolean;\n};\n\nexport type { Subscription, PermissionResponse, PermissionStatus, PermissionExpiration };\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts b/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts
index 03ac0f4..c5fd57d 100644
--- a/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts
+++ b/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts
@@ -1,4 +1,4 @@
-import { NotificationTriggerInput as NativeNotificationTriggerInput } from './NotificationScheduler.types';
+import { NativeNotificationTriggerInput } from './NotificationScheduler.types';
 import { NotificationRequestInput, NotificationTriggerInput } from './Notifications.types';
 /**
  * Schedules a notification to be triggered in the future.
diff --git a/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts.map b/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts.map
index 004b820..e5a3f45 100644
--- a/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts.map
+++ b/node_modules/expo-notifications/build/scheduleNotificationAsync.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"scheduleNotificationAsync.d.ts","sourceRoot":"","sources":["../src/scheduleNotificationAsync.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,wBAAwB,IAAI,8BAA8B,EAAE,MAAM,+BAA+B,CAAC;AAC3G,OAAO,EACL,wBAAwB,EACxB,wBAAwB,EASzB,MAAM,uBAAuB,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsDG;AACH,wBAA8B,yBAAyB,CACrD,OAAO,EAAE,wBAAwB,GAChC,OAAO,CAAC,MAAM,CAAC,CAUjB;AAoBD,wBAAgB,YAAY,CAC1B,iBAAiB,EAAE,wBAAwB,GAC1C,8BAA8B,CA4DhC"}
\ No newline at end of file
+{"version":3,"file":"scheduleNotificationAsync.d.ts","sourceRoot":"","sources":["../src/scheduleNotificationAsync.ts"],"names":[],"mappings":"AAGA,OAAO,EAIL,8BAA8B,EAK/B,MAAM,+BAA+B,CAAC;AACvC,OAAO,EACL,wBAAwB,EACxB,wBAAwB,EAEzB,MAAM,uBAAuB,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsDG;AACH,wBAA8B,yBAAyB,CACrD,OAAO,EAAE,wBAAwB,GAChC,OAAO,CAAC,MAAM,CAAC,CAUjB;AAID,wBAAgB,YAAY,CAC1B,iBAAiB,EAAE,wBAAwB,GAC1C,8BAA8B,CAmDhC"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/scheduleNotificationAsync.js b/node_modules/expo-notifications/build/scheduleNotificationAsync.js
index 52ef103..954ea00 100644
--- a/node_modules/expo-notifications/build/scheduleNotificationAsync.js
+++ b/node_modules/expo-notifications/build/scheduleNotificationAsync.js
@@ -1,5 +1,6 @@
 import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';
 import NotificationScheduler from './NotificationScheduler';
+import { SchedulableTriggerInputTypes, } from './Notifications.types';
 /**
  * Schedules a notification to be triggered in the future.
  * > **Note:** Please note that this does not mean that the notification will be presented when it is triggered.
@@ -61,21 +62,6 @@ export default async function scheduleNotificationAsync(request) {
     }
     return await NotificationScheduler.scheduleNotificationAsync(request.identifier ?? uuid.v4(), request.content, parseTrigger(request.trigger));
 }
-const DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS = [
-    'hour',
-    'minute',
-];
-const WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS = [
-    'weekday',
-    'hour',
-    'minute',
-];
-const YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS = [
-    'day',
-    'month',
-    'hour',
-    'minute',
-];
 export function parseTrigger(userFacingTrigger) {
     if (userFacingTrigger === null) {
         return null;
@@ -83,75 +69,78 @@ export function parseTrigger(userFacingTrigger) {
     if (userFacingTrigger === undefined) {
         throw new TypeError('Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.');
     }
-    if (isDateTrigger(userFacingTrigger)) {
-        return parseDateTrigger(userFacingTrigger);
+    const dateTrigger = parseDateTrigger(userFacingTrigger);
+    if (dateTrigger) {
+        return dateTrigger;
     }
-    else if (isDailyTriggerInput(userFacingTrigger)) {
-        validateDateComponentsInTrigger(userFacingTrigger, DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-        return {
-            type: 'daily',
-            channelId: userFacingTrigger.channelId,
-            hour: userFacingTrigger.hour,
-            minute: userFacingTrigger.minute,
-        };
-    }
-    else if (isWeeklyTriggerInput(userFacingTrigger)) {
-        validateDateComponentsInTrigger(userFacingTrigger, WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-        return {
-            type: 'weekly',
-            channelId: userFacingTrigger.channelId,
-            weekday: userFacingTrigger.weekday,
-            hour: userFacingTrigger.hour,
-            minute: userFacingTrigger.minute,
-        };
+    const calendarTrigger = parseCalendarTrigger(userFacingTrigger);
+    if (calendarTrigger) {
+        return calendarTrigger;
     }
-    else if (isYearlyTriggerInput(userFacingTrigger)) {
-        validateDateComponentsInTrigger(userFacingTrigger, YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-        return {
-            type: 'yearly',
-            channelId: userFacingTrigger.channelId,
-            day: userFacingTrigger.day,
-            month: userFacingTrigger.month,
-            hour: userFacingTrigger.hour,
-            minute: userFacingTrigger.minute,
-        };
+    const dailyTrigger = parseDailyTrigger(userFacingTrigger);
+    if (dailyTrigger) {
+        return dailyTrigger;
     }
-    else if (isSecondsPropertyMisusedInCalendarTriggerInput(userFacingTrigger)) {
-        throw new TypeError('Could not have inferred the notification trigger type: if you want to use a time interval trigger, pass in only `seconds` with or without `repeats` property; if you want to use calendar-based trigger, pass in `second`.');
+    const weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);
+    if (weeklyTrigger) {
+        return weeklyTrigger;
     }
-    else if ('seconds' in userFacingTrigger) {
-        return {
-            type: 'timeInterval',
-            channelId: userFacingTrigger.channelId,
-            seconds: userFacingTrigger.seconds,
-            repeats: userFacingTrigger.repeats ?? false,
-        };
+    const monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);
+    if (monthlyTrigger) {
+        return monthlyTrigger;
     }
-    else if (isCalendarTrigger(userFacingTrigger)) {
-        const { repeats, ...calendarTrigger } = userFacingTrigger;
-        return { type: 'calendar', value: calendarTrigger, repeats };
+    const yearlyTrigger = parseYearlyTrigger(userFacingTrigger);
+    if (yearlyTrigger) {
+        return yearlyTrigger;
     }
-    else {
-        return Platform.select({
-            default: null,
-            android: { type: 'channel', channelId: userFacingTrigger.channelId },
-        });
+    const timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);
+    if (timeIntervalTrigger) {
+        return timeIntervalTrigger;
     }
+    return Platform.select({
+        default: null,
+        android: {
+            type: 'channel',
+            channelId: typeof userFacingTrigger === 'object' &&
+                userFacingTrigger !== null &&
+                !(userFacingTrigger instanceof Date)
+                ? userFacingTrigger?.channelId
+                : undefined,
+        },
+    });
 }
-function isCalendarTrigger(trigger) {
-    const { channelId, ...triggerWithoutChannelId } = trigger;
-    return Object.keys(triggerWithoutChannelId).length > 0;
-}
-function isDateTrigger(trigger) {
-    return (trigger instanceof Date ||
-        typeof trigger === 'number' ||
-        (typeof trigger === 'object' && 'date' in trigger));
+function parseCalendarTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.CALENDAR) {
+        const { repeats, ...calendarTrigger } = trigger;
+        return { type: 'calendar', value: calendarTrigger, repeats };
+    }
+    return undefined;
 }
 function parseDateTrigger(trigger) {
     if (trigger instanceof Date || typeof trigger === 'number') {
         return { type: 'date', timestamp: toTimestamp(trigger) };
     }
-    return { type: 'date', timestamp: toTimestamp(trigger.date), channelId: trigger.channelId };
+    else if (typeof trigger === 'object' &&
+        trigger !== null &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.DATE &&
+        'date' in trigger &&
+        trigger.date instanceof Date) {
+        const result = {
+            type: 'date',
+            timestamp: toTimestamp(trigger.date),
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    else {
+        return undefined;
+    }
 }
 function toTimestamp(date) {
     if (date instanceof Date) {
@@ -159,48 +148,103 @@ function toTimestamp(date) {
     }
     return date;
 }
-function isDailyTriggerInput(trigger) {
-    if (typeof trigger !== 'object')
-        return false;
-    const { channelId, ...triggerWithoutChannelId } = trigger;
-    return (Object.keys(triggerWithoutChannelId).length ===
-        DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-        DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.every((component) => component in triggerWithoutChannelId) &&
-        'repeats' in triggerWithoutChannelId &&
-        triggerWithoutChannelId.repeats === true);
+function parseDailyTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.DAILY) {
+        validateDateComponentsInTrigger(trigger, ['hour', 'minute']);
+        const result = {
+            type: 'daily',
+            hour: trigger.hour ?? placeholderDateComponentValue,
+            minute: trigger.minute ?? placeholderDateComponentValue,
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    return undefined;
+}
+function parseWeeklyTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.WEEKLY) {
+        validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);
+        const result = {
+            type: 'weekly',
+            weekday: trigger.weekday ?? placeholderDateComponentValue,
+            hour: trigger.hour ?? placeholderDateComponentValue,
+            minute: trigger.minute ?? placeholderDateComponentValue,
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    return undefined;
 }
-function isWeeklyTriggerInput(trigger) {
-    if (typeof trigger !== 'object')
-        return false;
-    const { channelId, ...triggerWithoutChannelId } = trigger;
-    return (Object.keys(triggerWithoutChannelId).length ===
-        WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-        WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every((component) => component in triggerWithoutChannelId) &&
-        'repeats' in triggerWithoutChannelId &&
-        triggerWithoutChannelId.repeats === true);
+function parseMonthlyTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.MONTHLY) {
+        validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);
+        const result = {
+            type: 'monthly',
+            day: trigger.day ?? placeholderDateComponentValue,
+            hour: trigger.hour ?? placeholderDateComponentValue,
+            minute: trigger.minute ?? placeholderDateComponentValue,
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    return undefined;
 }
-function isYearlyTriggerInput(trigger) {
-    if (typeof trigger !== 'object')
-        return false;
-    const { channelId, ...triggerWithoutChannelId } = trigger;
-    return (Object.keys(triggerWithoutChannelId).length ===
-        YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-        YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every((component) => component in triggerWithoutChannelId) &&
-        'repeats' in triggerWithoutChannelId &&
-        triggerWithoutChannelId.repeats === true);
+function parseYearlyTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.YEARLY) {
+        validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);
+        const result = {
+            type: 'yearly',
+            month: trigger.month ?? placeholderDateComponentValue,
+            day: trigger.day ?? placeholderDateComponentValue,
+            hour: trigger.hour ?? placeholderDateComponentValue,
+            minute: trigger.minute ?? placeholderDateComponentValue,
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    return undefined;
 }
-function isSecondsPropertyMisusedInCalendarTriggerInput(trigger) {
-    const { channelId, ...triggerWithoutChannelId } = trigger;
-    return (
-    // eg. { seconds: ..., repeats: ..., hour: ... }
-    ('seconds' in triggerWithoutChannelId &&
-        'repeats' in triggerWithoutChannelId &&
-        Object.keys(triggerWithoutChannelId).length > 2) ||
-        // eg. { seconds: ..., hour: ... }
-        ('seconds' in triggerWithoutChannelId &&
-            !('repeats' in triggerWithoutChannelId) &&
-            Object.keys(triggerWithoutChannelId).length > 1));
+function parseTimeIntervalTrigger(trigger) {
+    if (trigger !== null &&
+        typeof trigger === 'object' &&
+        'type' in trigger &&
+        trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL &&
+        'seconds' in trigger &&
+        typeof trigger.seconds === 'number') {
+        const result = {
+            type: 'timeInterval',
+            seconds: trigger.seconds,
+            repeats: trigger.repeats ?? false,
+        };
+        if (trigger.channelId) {
+            result.channelId = trigger.channelId;
+        }
+        return result;
+    }
+    return undefined;
 }
+// Needed only to satisfy Typescript types for validated date components
+const placeholderDateComponentValue = -9999;
 function validateDateComponentsInTrigger(trigger, components) {
     const anyTriggerType = trigger;
     components.forEach((component) => {
@@ -219,7 +263,8 @@ function validateDateComponentsInTrigger(trigger, components) {
                 break;
             }
             case 'day': {
-                const { day, month } = anyTriggerType;
+                const day = anyTriggerType.day;
+                const month = anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();
                 const daysInGivenMonth = daysInMonth(month);
                 if (day < 1 || day > daysInGivenMonth) {
                     throw new RangeError(`The day parameter for month ${month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`);
diff --git a/node_modules/expo-notifications/build/scheduleNotificationAsync.js.map b/node_modules/expo-notifications/build/scheduleNotificationAsync.js.map
index 3de0f28..edd3e0f 100644
--- a/node_modules/expo-notifications/build/scheduleNotificationAsync.js.map
+++ b/node_modules/expo-notifications/build/scheduleNotificationAsync.js.map
@@ -1 +1 @@
-{"version":3,"file":"scheduleNotificationAsync.js","sourceRoot":"","sources":["../src/scheduleNotificationAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';\n\nimport NotificationScheduler from './NotificationScheduler';\nimport { NotificationTriggerInput as NativeNotificationTriggerInput } from './NotificationScheduler.types';\nimport {\n  NotificationRequestInput,\n  NotificationTriggerInput,\n  DailyTriggerInput,\n  WeeklyTriggerInput,\n  YearlyTriggerInput,\n  CalendarTriggerInput,\n  TimeIntervalTriggerInput,\n  DateTriggerInput,\n  ChannelAwareTriggerInput,\n  SchedulableNotificationTriggerInput,\n} from './Notifications.types';\n\n/**\n * Schedules a notification to be triggered in the future.\n * > **Note:** Please note that this does not mean that the notification will be presented when it is triggered.\n * For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#notificationssetnotificationhandlerhandler)\n * that will return an appropriate notification behavior. For more information see the example below.\n * @param request An object describing the notification to be triggered.\n * @return Returns a Promise resolving to a string which is a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n * @example\n * # Schedule the notification that will trigger once, in one minute from now\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: \"Time's up!\",\n *     body: 'Change sides!',\n *   },\n *   trigger: {\n *     seconds: 60,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger repeatedly, every 20 minutes\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Remember to drink water!',\n *   },\n *   trigger: {\n *     seconds: 60 * 20,\n *     repeats: true,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger once, at the beginning of next hour\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * const trigger = new Date(Date.now() + 60 * 60 * 1000);\n * trigger.setMinutes(0);\n * trigger.setSeconds(0);\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Happy new hour!',\n *   },\n *   trigger,\n * });\n * ```\n * @header schedule\n */\nexport default async function scheduleNotificationAsync(\n  request: NotificationRequestInput\n): Promise<string> {\n  if (!NotificationScheduler.scheduleNotificationAsync) {\n    throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n  }\n\n  return await NotificationScheduler.scheduleNotificationAsync(\n    request.identifier ?? uuid.v4(),\n    request.content,\n    parseTrigger(request.trigger)\n  );\n}\n\ntype ValidTriggerDateComponents = 'month' | 'day' | 'weekday' | 'hour' | 'minute';\n\nconst DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [\n  'hour',\n  'minute',\n];\nconst WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [\n  'weekday',\n  'hour',\n  'minute',\n];\nconst YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [\n  'day',\n  'month',\n  'hour',\n  'minute',\n];\n\nexport function parseTrigger(\n  userFacingTrigger: NotificationTriggerInput\n): NativeNotificationTriggerInput {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n\n  if (userFacingTrigger === undefined) {\n    throw new TypeError(\n      'Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.'\n    );\n  }\n\n  if (isDateTrigger(userFacingTrigger)) {\n    return parseDateTrigger(userFacingTrigger);\n  } else if (isDailyTriggerInput(userFacingTrigger)) {\n    validateDateComponentsInTrigger(userFacingTrigger, DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS);\n    return {\n      type: 'daily',\n      channelId: userFacingTrigger.channelId,\n      hour: userFacingTrigger.hour,\n      minute: userFacingTrigger.minute,\n    };\n  } else if (isWeeklyTriggerInput(userFacingTrigger)) {\n    validateDateComponentsInTrigger(userFacingTrigger, WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS);\n    return {\n      type: 'weekly',\n      channelId: userFacingTrigger.channelId,\n      weekday: userFacingTrigger.weekday,\n      hour: userFacingTrigger.hour,\n      minute: userFacingTrigger.minute,\n    };\n  } else if (isYearlyTriggerInput(userFacingTrigger)) {\n    validateDateComponentsInTrigger(userFacingTrigger, YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS);\n    return {\n      type: 'yearly',\n      channelId: userFacingTrigger.channelId,\n      day: userFacingTrigger.day,\n      month: userFacingTrigger.month,\n      hour: userFacingTrigger.hour,\n      minute: userFacingTrigger.minute,\n    };\n  } else if (isSecondsPropertyMisusedInCalendarTriggerInput(userFacingTrigger)) {\n    throw new TypeError(\n      'Could not have inferred the notification trigger type: if you want to use a time interval trigger, pass in only `seconds` with or without `repeats` property; if you want to use calendar-based trigger, pass in `second`.'\n    );\n  } else if ('seconds' in userFacingTrigger) {\n    return {\n      type: 'timeInterval',\n      channelId: userFacingTrigger.channelId,\n      seconds: userFacingTrigger.seconds,\n      repeats: userFacingTrigger.repeats ?? false,\n    };\n  } else if (isCalendarTrigger(userFacingTrigger)) {\n    const { repeats, ...calendarTrigger } = userFacingTrigger;\n    return { type: 'calendar', value: calendarTrigger, repeats };\n  } else {\n    return Platform.select({\n      default: null, // There's no notion of channels on platforms other than Android.\n      android: { type: 'channel', channelId: userFacingTrigger.channelId },\n    });\n  }\n}\n\nfunction isCalendarTrigger(\n  trigger: CalendarTriggerInput | ChannelAwareTriggerInput\n): trigger is CalendarTriggerInput {\n  const { channelId, ...triggerWithoutChannelId } = trigger;\n  return Object.keys(triggerWithoutChannelId).length > 0;\n}\n\nfunction isDateTrigger(\n  trigger:\n    | DateTriggerInput\n    | WeeklyTriggerInput\n    | DailyTriggerInput\n    | CalendarTriggerInput\n    | TimeIntervalTriggerInput\n): trigger is DateTriggerInput {\n  return (\n    trigger instanceof Date ||\n    typeof trigger === 'number' ||\n    (typeof trigger === 'object' && 'date' in trigger)\n  );\n}\n\nfunction parseDateTrigger(trigger: DateTriggerInput): NativeNotificationTriggerInput {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    return { type: 'date', timestamp: toTimestamp(trigger) };\n  }\n  return { type: 'date', timestamp: toTimestamp(trigger.date), channelId: trigger.channelId };\n}\n\nfunction toTimestamp(date: number | Date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\n\nfunction isDailyTriggerInput(\n  trigger: SchedulableNotificationTriggerInput\n): trigger is DailyTriggerInput {\n  if (typeof trigger !== 'object') return false;\n  const { channelId, ...triggerWithoutChannelId } = trigger as DailyTriggerInput;\n  return (\n    Object.keys(triggerWithoutChannelId).length ===\n      DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&\n    DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(\n      (component) => component in triggerWithoutChannelId\n    ) &&\n    'repeats' in triggerWithoutChannelId &&\n    triggerWithoutChannelId.repeats === true\n  );\n}\n\nfunction isWeeklyTriggerInput(\n  trigger: SchedulableNotificationTriggerInput\n): trigger is WeeklyTriggerInput {\n  if (typeof trigger !== 'object') return false;\n  const { channelId, ...triggerWithoutChannelId } = trigger as WeeklyTriggerInput;\n  return (\n    Object.keys(triggerWithoutChannelId).length ===\n      WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&\n    WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(\n      (component) => component in triggerWithoutChannelId\n    ) &&\n    'repeats' in triggerWithoutChannelId &&\n    triggerWithoutChannelId.repeats === true\n  );\n}\n\nfunction isYearlyTriggerInput(\n  trigger: SchedulableNotificationTriggerInput\n): trigger is YearlyTriggerInput {\n  if (typeof trigger !== 'object') return false;\n  const { channelId, ...triggerWithoutChannelId } = trigger as YearlyTriggerInput;\n  return (\n    Object.keys(triggerWithoutChannelId).length ===\n      YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&\n    YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(\n      (component) => component in triggerWithoutChannelId\n    ) &&\n    'repeats' in triggerWithoutChannelId &&\n    triggerWithoutChannelId.repeats === true\n  );\n}\n\nfunction isSecondsPropertyMisusedInCalendarTriggerInput(\n  trigger: TimeIntervalTriggerInput | CalendarTriggerInput\n) {\n  const { channelId, ...triggerWithoutChannelId } = trigger;\n  return (\n    // eg. { seconds: ..., repeats: ..., hour: ... }\n    ('seconds' in triggerWithoutChannelId &&\n      'repeats' in triggerWithoutChannelId &&\n      Object.keys(triggerWithoutChannelId).length > 2) ||\n    // eg. { seconds: ..., hour: ... }\n    ('seconds' in triggerWithoutChannelId &&\n      !('repeats' in triggerWithoutChannelId) &&\n      Object.keys(triggerWithoutChannelId).length > 1)\n  );\n}\n\nfunction validateDateComponentsInTrigger(\n  trigger: NonNullable<NotificationTriggerInput>,\n  components: readonly ValidTriggerDateComponents[]\n) {\n  const anyTriggerType = trigger as any;\n  components.forEach((component) => {\n    if (!(component in anyTriggerType)) {\n      throw new TypeError(`The ${component} parameter needs to be present`);\n    }\n    if (typeof anyTriggerType[component] !== 'number') {\n      throw new TypeError(`The ${component} parameter should be a number`);\n    }\n    switch (component) {\n      case 'month': {\n        const { month } = anyTriggerType;\n        if (month < 0 || month > 11) {\n          throw new RangeError(`The month parameter needs to be between 0 and 11. Found: ${month}`);\n        }\n        break;\n      }\n      case 'day': {\n        const { day, month } = anyTriggerType;\n        const daysInGivenMonth = daysInMonth(month);\n        if (day < 1 || day > daysInGivenMonth) {\n          throw new RangeError(\n            `The day parameter for month ${month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`\n          );\n        }\n        break;\n      }\n      case 'weekday': {\n        const { weekday } = anyTriggerType;\n        if (weekday < 1 || weekday > 7) {\n          throw new RangeError(\n            `The weekday parameter needs to be between 1 and 7. Found: ${weekday}`\n          );\n        }\n        break;\n      }\n      case 'hour': {\n        const { hour } = anyTriggerType;\n        if (hour < 0 || hour > 23) {\n          throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n        }\n        break;\n      }\n      case 'minute': {\n        const { minute } = anyTriggerType;\n        if (minute < 0 || minute > 59) {\n          throw new RangeError(\n            `The minute parameter needs to be between 0 and 59. Found: ${minute}`\n          );\n        }\n        break;\n      }\n    }\n  });\n}\n\n/**\n * Determines the number of days in the given month (or January if omitted).\n * If year is specified, it will include leap year logic, else it will always assume a leap year\n */\nfunction daysInMonth(month: number = 0, year?: number) {\n  return new Date(year ?? 2000, month + 1, 0).getDate();\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"scheduleNotificationAsync.js","sourceRoot":"","sources":["../src/scheduleNotificationAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';\n\nimport NotificationScheduler from './NotificationScheduler';\nimport {\n  NativeCalendarTriggerInput,\n  NativeDailyTriggerInput,\n  NativeDateTriggerInput,\n  NativeNotificationTriggerInput,\n  NativeTimeIntervalTriggerInput,\n  NativeWeeklyTriggerInput,\n  NativeMonthlyTriggerInput,\n  NativeYearlyTriggerInput,\n} from './NotificationScheduler.types';\nimport {\n  NotificationRequestInput,\n  NotificationTriggerInput,\n  SchedulableTriggerInputTypes,\n} from './Notifications.types';\n\n/**\n * Schedules a notification to be triggered in the future.\n * > **Note:** Please note that this does not mean that the notification will be presented when it is triggered.\n * For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#notificationssetnotificationhandlerhandler)\n * that will return an appropriate notification behavior. For more information see the example below.\n * @param request An object describing the notification to be triggered.\n * @return Returns a Promise resolving to a string which is a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n * @example\n * # Schedule the notification that will trigger once, in one minute from now\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: \"Time's up!\",\n *     body: 'Change sides!',\n *   },\n *   trigger: {\n *     seconds: 60,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger repeatedly, every 20 minutes\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Remember to drink water!',\n *   },\n *   trigger: {\n *     seconds: 60 * 20,\n *     repeats: true,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger once, at the beginning of next hour\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * const trigger = new Date(Date.now() + 60 * 60 * 1000);\n * trigger.setMinutes(0);\n * trigger.setSeconds(0);\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Happy new hour!',\n *   },\n *   trigger,\n * });\n * ```\n * @header schedule\n */\nexport default async function scheduleNotificationAsync(\n  request: NotificationRequestInput\n): Promise<string> {\n  if (!NotificationScheduler.scheduleNotificationAsync) {\n    throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n  }\n\n  return await NotificationScheduler.scheduleNotificationAsync(\n    request.identifier ?? uuid.v4(),\n    request.content,\n    parseTrigger(request.trigger)\n  );\n}\n\ntype ValidTriggerDateComponents = 'month' | 'day' | 'weekday' | 'hour' | 'minute';\n\nexport function parseTrigger(\n  userFacingTrigger: NotificationTriggerInput\n): NativeNotificationTriggerInput {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n\n  if (userFacingTrigger === undefined) {\n    throw new TypeError(\n      'Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.'\n    );\n  }\n\n  const dateTrigger = parseDateTrigger(userFacingTrigger);\n  if (dateTrigger) {\n    return dateTrigger;\n  }\n  const calendarTrigger = parseCalendarTrigger(userFacingTrigger);\n  if (calendarTrigger) {\n    return calendarTrigger;\n  }\n  const dailyTrigger = parseDailyTrigger(userFacingTrigger);\n  if (dailyTrigger) {\n    return dailyTrigger;\n  }\n  const weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);\n  if (weeklyTrigger) {\n    return weeklyTrigger;\n  }\n  const monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);\n  if (monthlyTrigger) {\n    return monthlyTrigger;\n  }\n  const yearlyTrigger = parseYearlyTrigger(userFacingTrigger);\n  if (yearlyTrigger) {\n    return yearlyTrigger;\n  }\n  const timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);\n  if (timeIntervalTrigger) {\n    return timeIntervalTrigger;\n  }\n  return Platform.select({\n    default: null, // There's no notion of channels on platforms other than Android.\n    android: {\n      type: 'channel',\n      channelId:\n        typeof userFacingTrigger === 'object' &&\n        userFacingTrigger !== null &&\n        !(userFacingTrigger instanceof Date)\n          ? userFacingTrigger?.channelId\n          : undefined,\n    },\n  });\n}\n\nfunction parseCalendarTrigger(\n  trigger: NotificationTriggerInput\n): NativeCalendarTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.CALENDAR\n  ) {\n    const { repeats, ...calendarTrigger } = trigger;\n    return { type: 'calendar', value: calendarTrigger, repeats };\n  }\n  return undefined;\n}\n\nfunction parseDateTrigger(trigger: NotificationTriggerInput): NativeDateTriggerInput | undefined {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    return { type: 'date', timestamp: toTimestamp(trigger) };\n  } else if (\n    typeof trigger === 'object' &&\n    trigger !== null &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DATE &&\n    'date' in trigger &&\n    trigger.date instanceof Date\n  ) {\n    const result: NativeDateTriggerInput = {\n      type: 'date',\n      timestamp: toTimestamp(trigger.date),\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  } else {\n    return undefined;\n  }\n}\n\nfunction toTimestamp(date: number | Date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\n\nfunction parseDailyTrigger(trigger: NotificationTriggerInput): NativeDailyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DAILY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['hour', 'minute']);\n    const result: NativeDailyTriggerInput = {\n      type: 'daily',\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseWeeklyTrigger(\n  trigger: NotificationTriggerInput\n): NativeWeeklyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.WEEKLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);\n    const result: NativeWeeklyTriggerInput = {\n      type: 'weekly',\n      weekday: trigger.weekday ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseMonthlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeMonthlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.MONTHLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);\n    const result: NativeMonthlyTriggerInput = {\n      type: 'monthly',\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseYearlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeYearlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.YEARLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);\n    const result: NativeYearlyTriggerInput = {\n      type: 'yearly',\n      month: trigger.month ?? placeholderDateComponentValue,\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseTimeIntervalTrigger(\n  trigger: NotificationTriggerInput\n): NativeTimeIntervalTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL &&\n    'seconds' in trigger &&\n    typeof trigger.seconds === 'number'\n  ) {\n    const result: NativeTimeIntervalTriggerInput = {\n      type: 'timeInterval',\n      seconds: trigger.seconds,\n      repeats: trigger.repeats ?? false,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\n// Needed only to satisfy Typescript types for validated date components\nconst placeholderDateComponentValue = -9999;\n\nfunction validateDateComponentsInTrigger(\n  trigger: NonNullable<NotificationTriggerInput>,\n  components: readonly ValidTriggerDateComponents[]\n) {\n  const anyTriggerType = trigger as any;\n  components.forEach((component) => {\n    if (!(component in anyTriggerType)) {\n      throw new TypeError(`The ${component} parameter needs to be present`);\n    }\n    if (typeof anyTriggerType[component] !== 'number') {\n      throw new TypeError(`The ${component} parameter should be a number`);\n    }\n    switch (component) {\n      case 'month': {\n        const { month } = anyTriggerType;\n        if (month < 0 || month > 11) {\n          throw new RangeError(`The month parameter needs to be between 0 and 11. Found: ${month}`);\n        }\n        break;\n      }\n      case 'day': {\n        const day = anyTriggerType.day;\n        const month =\n          anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();\n        const daysInGivenMonth = daysInMonth(month);\n        if (day < 1 || day > daysInGivenMonth) {\n          throw new RangeError(\n            `The day parameter for month ${month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`\n          );\n        }\n        break;\n      }\n      case 'weekday': {\n        const { weekday } = anyTriggerType;\n        if (weekday < 1 || weekday > 7) {\n          throw new RangeError(\n            `The weekday parameter needs to be between 1 and 7. Found: ${weekday}`\n          );\n        }\n        break;\n      }\n      case 'hour': {\n        const { hour } = anyTriggerType;\n        if (hour < 0 || hour > 23) {\n          throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n        }\n        break;\n      }\n      case 'minute': {\n        const { minute } = anyTriggerType;\n        if (minute < 0 || minute > 59) {\n          throw new RangeError(\n            `The minute parameter needs to be between 0 and 59. Found: ${minute}`\n          );\n        }\n        break;\n      }\n    }\n  });\n}\n\n/**\n * Determines the number of days in the given month (or January if omitted).\n * If year is specified, it will include leap year logic, else it will always assume a leap year\n */\nfunction daysInMonth(month: number = 0, year?: number) {\n  return new Date(year ?? 2000, month + 1, 0).getDate();\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
index 5754f03..49e7453 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
@@ -22,6 +22,11 @@ static NSString * const weeklyNotificationTriggerWeekdayKey = @"weekday";
 static NSString * const weeklyNotificationTriggerHourKey = @"hour";
 static NSString * const weeklyNotificationTriggerMinuteKey = @"minute";
 
+static NSString * const monthlyNotificationTriggerType = @"monthly";
+static NSString * const monthlyNotificationTriggerDayKey = @"day";
+static NSString * const monthlyNotificationTriggerHourKey = @"hour";
+static NSString * const monthlyNotificationTriggerMinuteKey = @"minute";
+
 static NSString * const yearlyNotificationTriggerType = @"yearly";
 static NSString * const yearlyNotificationTriggerDayKey = @"day";
 static NSString * const yearlyNotificationTriggerMonthKey = @"month";
@@ -182,6 +187,17 @@ EX_EXPORT_METHOD_AS(getNextTriggerDateAsync,
     dateComponents.hour = [hour integerValue];
     dateComponents.minute = [minute integerValue];
 
+    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
+                                                                    repeats:YES];
+  } else if ([monthlyNotificationTriggerType isEqualToString:triggerType]) {
+    NSNumber *day = [params objectForKey:monthlyNotificationTriggerDayKey verifyingClass:[NSNumber class]];
+    NSNumber *hour = [params objectForKey:monthlyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
+    NSNumber *minute = [params objectForKey:monthlyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
+    NSDateComponents *dateComponents = [NSDateComponents new];
+    dateComponents.day = [day integerValue];
+    dateComponents.hour = [hour integerValue];
+    dateComponents.minute = [minute integerValue];
+
     return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
                                                                     repeats:YES];
   } else if ([yearlyNotificationTriggerType isEqualToString:triggerType]) {
diff --git a/node_modules/expo-notifications/src/NotificationScheduler.types.ts b/node_modules/expo-notifications/src/NotificationScheduler.types.ts
index 85231bc..b2509d2 100644
--- a/node_modules/expo-notifications/src/NotificationScheduler.types.ts
+++ b/node_modules/expo-notifications/src/NotificationScheduler.types.ts
@@ -1,51 +1,61 @@
 import { ProxyNativeModule } from 'expo-modules-core';
 
-import {
-  NotificationRequest,
-  NotificationContentInput,
-  CalendarTriggerInputValue,
-} from './Notifications.types';
+import { NotificationRequest, NotificationContentInput } from './Notifications.types';
+
+type CalendarTriggerInputValue = {
+  timezone?: string;
+  year?: number;
+  month?: number;
+  weekday?: number;
+  weekOfMonth?: number;
+  weekOfYear?: number;
+  weekdayOrdinal?: number;
+  day?: number;
+  hour?: number;
+  minute?: number;
+  second?: number;
+};
 
 export interface NotificationSchedulerModule extends ProxyNativeModule {
   getAllScheduledNotificationsAsync?: () => Promise<NotificationRequest[]>;
   scheduleNotificationAsync?: (
     identifier: string,
     notificationContent: NotificationContentInput,
-    trigger: NotificationTriggerInput
+    trigger: NativeNotificationTriggerInput
   ) => Promise<string>;
   cancelScheduledNotificationAsync?: (identifier: string) => Promise<void>;
   cancelAllScheduledNotificationsAsync?: () => Promise<void>;
-  getNextTriggerDateAsync?: (trigger: NotificationTriggerInput) => Promise<number>;
+  getNextTriggerDateAsync?: (trigger: NativeNotificationTriggerInput) => Promise<number>;
 }
 
-export interface ChannelAwareTriggerInput {
+export interface NativeChannelAwareTriggerInput {
   type: 'channel';
   channelId?: string;
 }
 
 // ISO8601 calendar pattern-matching
-export interface CalendarTriggerInput {
+export interface NativeCalendarTriggerInput {
   type: 'calendar';
   channelId?: string;
   repeats?: boolean;
   value: CalendarTriggerInputValue;
 }
 
-export interface TimeIntervalTriggerInput {
+export interface NativeTimeIntervalTriggerInput {
   type: 'timeInterval';
   channelId?: string;
   repeats: boolean;
   seconds: number;
 }
 
-export interface DailyTriggerInput {
+export interface NativeDailyTriggerInput {
   type: 'daily';
   channelId?: string;
   hour: number;
   minute: number;
 }
 
-export interface WeeklyTriggerInput {
+export interface NativeWeeklyTriggerInput {
   type: 'weekly';
   channelId?: string;
   weekday: number;
@@ -53,7 +63,7 @@ export interface WeeklyTriggerInput {
   minute: number;
 }
 
-export interface YearlyTriggerInput {
+export interface NativeYearlyTriggerInput {
   type: 'yearly';
   channelId?: string;
   day: number;
@@ -62,18 +72,27 @@ export interface YearlyTriggerInput {
   minute: number;
 }
 
-export interface DateTriggerInput {
+export interface NativeMonthlyTriggerInput {
+  type: 'monthly';
+  channelId?: string;
+  day: number;
+  hour: number;
+  minute: number;
+}
+
+export interface NativeDateTriggerInput {
   type: 'date';
   channelId?: string;
   timestamp: number; // seconds since 1970
 }
 
-export type NotificationTriggerInput =
+export type NativeNotificationTriggerInput =
   | null
-  | ChannelAwareTriggerInput
-  | DateTriggerInput
-  | CalendarTriggerInput
-  | TimeIntervalTriggerInput
-  | DailyTriggerInput
-  | WeeklyTriggerInput
-  | YearlyTriggerInput;
+  | NativeChannelAwareTriggerInput
+  | NativeDateTriggerInput
+  | NativeCalendarTriggerInput
+  | NativeTimeIntervalTriggerInput
+  | NativeDailyTriggerInput
+  | NativeWeeklyTriggerInput
+  | NativeMonthlyTriggerInput
+  | NativeYearlyTriggerInput;
diff --git a/node_modules/expo-notifications/src/Notifications.types.ts b/node_modules/expo-notifications/src/Notifications.types.ts
index d8c9cb9..b934ebd 100644
--- a/node_modules/expo-notifications/src/Notifications.types.ts
+++ b/node_modules/expo-notifications/src/Notifications.types.ts
@@ -165,6 +165,18 @@ export interface WeeklyNotificationTrigger {
   minute: number;
 }
 
+/**
+ * A trigger related to a monthly notification.
+ * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.
+ * @platform android
+ */
+export interface MonthlyNotificationTrigger {
+  type: 'monthly';
+  day: number;
+  hour: number;
+  minute: number;
+}
+
 /**
  * A trigger related to a yearly notification.
  * > The same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.
@@ -243,6 +255,7 @@ export type NotificationTrigger =
   | TimeIntervalNotificationTrigger
   | DailyNotificationTrigger
   | WeeklyNotificationTrigger
+  | MonthlyNotificationTrigger
   | YearlyNotificationTrigger
   | UnknownNotificationTrigger;
 
@@ -253,8 +266,33 @@ export type ChannelAwareTriggerInput = {
   channelId: string;
 };
 
-// @docsMissing
-export type CalendarTriggerInputValue = {
+/**
+ * Schedulable trigger inputs (that are not a plain date value or time value)
+ * must have the "type" property set to one of these values.
+ */
+export enum SchedulableTriggerInputTypes {
+  CALENDAR = 'calendar',
+  DAILY = 'daily',
+  WEEKLY = 'weekly',
+  MONTHLY = 'monthly',
+  YEARLY = 'yearly',
+  DATE = 'date',
+  TIME_INTERVAL = 'timeInterval',
+}
+
+/**
+ * This trigger input will cause the notification to be delivered once or many times
+ * (controlled by the value of `repeats`)
+ * when the date components match the specified values.
+ * Corresponds to native
+ * [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).
+ * @platform ios
+ */
+export type CalendarTriggerInput = {
+  type: SchedulableTriggerInputTypes.CALENDAR;
+  channelId?: string;
+  repeats?: boolean;
+  seconds?: number;
   timezone?: string;
   year?: number;
   month?: number;
@@ -269,77 +307,99 @@ export type CalendarTriggerInputValue = {
 };
 
 /**
- * A trigger that will cause the notification to be delivered once or many times when the date components match the specified values.
- * Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).
- * @platform ios
+ * This trigger input will cause the notification to be delivered once per day
+ * when the `hour` and `minute` date components match the specified values.
  */
-export type CalendarTriggerInput = CalendarTriggerInputValue & {
+export type DailyTriggerInput = {
+  type: SchedulableTriggerInputTypes.DAILY;
   channelId?: string;
-  repeats?: boolean;
+  hour: number;
+  minute: number;
 };
 
 /**
- * A trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.
- * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater. Otherwise, the notification won't be triggered.
- */
-export interface TimeIntervalTriggerInput {
-  channelId?: string;
-  repeats?: boolean;
-  seconds: number;
-}
-
-/**
- * A trigger that will cause the notification to be delivered once per day.
+ * This trigger input will cause the notification to be delivered once every week
+ * when the `weekday`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.
  */
-export interface DailyTriggerInput {
+export type WeeklyTriggerInput = {
+  type: SchedulableTriggerInputTypes.WEEKLY;
   channelId?: string;
+  weekday: number;
   hour: number;
   minute: number;
-  repeats: true;
-}
+};
 
 /**
- * A trigger that will cause the notification to be delivered once every week.
- * > **Note:** Weekdays are specified with a number from `1` through `7`, with `1` indicating Sunday.
+ * This trigger input will cause the notification to be delivered once per month
+ * when the `day`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** All properties are specified in JavaScript `Date` object's ranges.
  */
-export interface WeeklyTriggerInput {
+export type MonthlyTriggerInput = {
+  type: SchedulableTriggerInputTypes.MONTHLY;
   channelId?: string;
-  weekday: number;
+  day: number;
   hour: number;
   minute: number;
-  repeats: true;
-}
+};
 
 /**
- * A trigger that will cause the notification to be delivered once every year.
- * > **Note:** all properties are specified in JavaScript Date's ranges.
+ * This trigger input will cause the notification to be delivered once every year
+ * when the `day`, `month`, `hour`, and `minute` date components match the specified values.
+ * > **Note:** All properties are specified in JavaScript `Date` object's ranges.
  */
-export interface YearlyTriggerInput {
+export type YearlyTriggerInput = {
+  type: SchedulableTriggerInputTypes.YEARLY;
   channelId?: string;
   day: number;
   month: number;
   hour: number;
   minute: number;
-  repeats: true;
-}
+};
+
+/**
+ * This trigger input will cause the notification to be delivered once
+ * on the specified value of the `date` property. The value of `repeats` will be ignored
+ * for this trigger type.
+ */
+export type DateTriggerInput =
+  | Date
+  | number
+  | { type: SchedulableTriggerInputTypes.DATE; channelId?: string; date: Date | number };
 
 /**
- * A trigger that will cause the notification to be delivered once at the specified `Date`.
- * If you pass in a `number` it will be interpreted as a Unix timestamp.
+ * This trigger input will cause the notification to be delivered once or many times
+ * (depends on the `repeats` field) after `seconds` time elapse.
+ * > **On iOS**, when `repeats` is `true`, the time interval must be 60 seconds or greater.
+ * Otherwise, the notification won't be triggered.
  */
-export type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };
+export type TimeIntervalTriggerInput = {
+  type: SchedulableTriggerInputTypes.TIME_INTERVAL;
+  channelId?: string;
+  repeats?: boolean;
+  seconds: number;
+};
 
 /**
- * A type represents time-based, schedulable triggers. For these triggers you can check the next trigger date
+ * Input for time-based, schedulable triggers.
+ * For these triggers you can check the next trigger date
  * with [`getNextTriggerDateAsync`](#notificationsgetnexttriggerdateasynctrigger).
+ * If you pass in a `number` (Unix timestamp) or `Date`, it will be processed as a
+ * trigger input of type [`CalendarTriggerTypes.DATE`](#date). Otherwise, the input must be
+ * an object, with a `type` value set to one of the allowed values in
+ * [`CalendarTriggerTypes`](#calendartriggertypes).
+ * If the input is an object, date components passed in will be validated, and
+ * an error is thrown if they are outside their allowed range (for example, the `minute` and
+ * `second` components must be between 0 and 59 inclusive).
  */
 export type SchedulableNotificationTriggerInput =
-  | DateTriggerInput
+  | CalendarTriggerInput
   | TimeIntervalTriggerInput
   | DailyTriggerInput
   | WeeklyTriggerInput
+  | MonthlyTriggerInput
   | YearlyTriggerInput
-  | CalendarTriggerInput;
+  | DateTriggerInput;
 
 /**
  * A type represents possible triggers with which you can schedule notifications.
diff --git a/node_modules/expo-notifications/src/scheduleNotificationAsync.ts b/node_modules/expo-notifications/src/scheduleNotificationAsync.ts
index d8b66cc..46fd101 100644
--- a/node_modules/expo-notifications/src/scheduleNotificationAsync.ts
+++ b/node_modules/expo-notifications/src/scheduleNotificationAsync.ts
@@ -1,18 +1,20 @@
 import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';
 
 import NotificationScheduler from './NotificationScheduler';
-import { NotificationTriggerInput as NativeNotificationTriggerInput } from './NotificationScheduler.types';
+import {
+  NativeCalendarTriggerInput,
+  NativeDailyTriggerInput,
+  NativeDateTriggerInput,
+  NativeNotificationTriggerInput,
+  NativeTimeIntervalTriggerInput,
+  NativeWeeklyTriggerInput,
+  NativeMonthlyTriggerInput,
+  NativeYearlyTriggerInput,
+} from './NotificationScheduler.types';
 import {
   NotificationRequestInput,
   NotificationTriggerInput,
-  DailyTriggerInput,
-  WeeklyTriggerInput,
-  YearlyTriggerInput,
-  CalendarTriggerInput,
-  TimeIntervalTriggerInput,
-  DateTriggerInput,
-  ChannelAwareTriggerInput,
-  SchedulableNotificationTriggerInput,
+  SchedulableTriggerInputTypes,
 } from './Notifications.types';
 
 /**
@@ -86,22 +88,6 @@ export default async function scheduleNotificationAsync(
 
 type ValidTriggerDateComponents = 'month' | 'day' | 'weekday' | 'hour' | 'minute';
 
-const DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [
-  'hour',
-  'minute',
-];
-const WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [
-  'weekday',
-  'hour',
-  'minute',
-];
-const YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS: readonly ValidTriggerDateComponents[] = [
-  'day',
-  'month',
-  'hour',
-  'minute',
-];
-
 export function parseTrigger(
   userFacingTrigger: NotificationTriggerInput
 ): NativeNotificationTriggerInput {
@@ -115,84 +101,85 @@ export function parseTrigger(
     );
   }
 
-  if (isDateTrigger(userFacingTrigger)) {
-    return parseDateTrigger(userFacingTrigger);
-  } else if (isDailyTriggerInput(userFacingTrigger)) {
-    validateDateComponentsInTrigger(userFacingTrigger, DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-    return {
-      type: 'daily',
-      channelId: userFacingTrigger.channelId,
-      hour: userFacingTrigger.hour,
-      minute: userFacingTrigger.minute,
-    };
-  } else if (isWeeklyTriggerInput(userFacingTrigger)) {
-    validateDateComponentsInTrigger(userFacingTrigger, WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-    return {
-      type: 'weekly',
-      channelId: userFacingTrigger.channelId,
-      weekday: userFacingTrigger.weekday,
-      hour: userFacingTrigger.hour,
-      minute: userFacingTrigger.minute,
-    };
-  } else if (isYearlyTriggerInput(userFacingTrigger)) {
-    validateDateComponentsInTrigger(userFacingTrigger, YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS);
-    return {
-      type: 'yearly',
-      channelId: userFacingTrigger.channelId,
-      day: userFacingTrigger.day,
-      month: userFacingTrigger.month,
-      hour: userFacingTrigger.hour,
-      minute: userFacingTrigger.minute,
-    };
-  } else if (isSecondsPropertyMisusedInCalendarTriggerInput(userFacingTrigger)) {
-    throw new TypeError(
-      'Could not have inferred the notification trigger type: if you want to use a time interval trigger, pass in only `seconds` with or without `repeats` property; if you want to use calendar-based trigger, pass in `second`.'
-    );
-  } else if ('seconds' in userFacingTrigger) {
-    return {
-      type: 'timeInterval',
-      channelId: userFacingTrigger.channelId,
-      seconds: userFacingTrigger.seconds,
-      repeats: userFacingTrigger.repeats ?? false,
-    };
-  } else if (isCalendarTrigger(userFacingTrigger)) {
-    const { repeats, ...calendarTrigger } = userFacingTrigger;
-    return { type: 'calendar', value: calendarTrigger, repeats };
-  } else {
-    return Platform.select({
-      default: null, // There's no notion of channels on platforms other than Android.
-      android: { type: 'channel', channelId: userFacingTrigger.channelId },
-    });
+  const dateTrigger = parseDateTrigger(userFacingTrigger);
+  if (dateTrigger) {
+    return dateTrigger;
   }
+  const calendarTrigger = parseCalendarTrigger(userFacingTrigger);
+  if (calendarTrigger) {
+    return calendarTrigger;
+  }
+  const dailyTrigger = parseDailyTrigger(userFacingTrigger);
+  if (dailyTrigger) {
+    return dailyTrigger;
+  }
+  const weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);
+  if (weeklyTrigger) {
+    return weeklyTrigger;
+  }
+  const monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);
+  if (monthlyTrigger) {
+    return monthlyTrigger;
+  }
+  const yearlyTrigger = parseYearlyTrigger(userFacingTrigger);
+  if (yearlyTrigger) {
+    return yearlyTrigger;
+  }
+  const timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);
+  if (timeIntervalTrigger) {
+    return timeIntervalTrigger;
+  }
+  return Platform.select({
+    default: null, // There's no notion of channels on platforms other than Android.
+    android: {
+      type: 'channel',
+      channelId:
+        typeof userFacingTrigger === 'object' &&
+        userFacingTrigger !== null &&
+        !(userFacingTrigger instanceof Date)
+          ? userFacingTrigger?.channelId
+          : undefined,
+    },
+  });
 }
 
-function isCalendarTrigger(
-  trigger: CalendarTriggerInput | ChannelAwareTriggerInput
-): trigger is CalendarTriggerInput {
-  const { channelId, ...triggerWithoutChannelId } = trigger;
-  return Object.keys(triggerWithoutChannelId).length > 0;
-}
-
-function isDateTrigger(
-  trigger:
-    | DateTriggerInput
-    | WeeklyTriggerInput
-    | DailyTriggerInput
-    | CalendarTriggerInput
-    | TimeIntervalTriggerInput
-): trigger is DateTriggerInput {
-  return (
-    trigger instanceof Date ||
-    typeof trigger === 'number' ||
-    (typeof trigger === 'object' && 'date' in trigger)
-  );
+function parseCalendarTrigger(
+  trigger: NotificationTriggerInput
+): NativeCalendarTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.CALENDAR
+  ) {
+    const { repeats, ...calendarTrigger } = trigger;
+    return { type: 'calendar', value: calendarTrigger, repeats };
+  }
+  return undefined;
 }
 
-function parseDateTrigger(trigger: DateTriggerInput): NativeNotificationTriggerInput {
+function parseDateTrigger(trigger: NotificationTriggerInput): NativeDateTriggerInput | undefined {
   if (trigger instanceof Date || typeof trigger === 'number') {
     return { type: 'date', timestamp: toTimestamp(trigger) };
+  } else if (
+    typeof trigger === 'object' &&
+    trigger !== null &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.DATE &&
+    'date' in trigger &&
+    trigger.date instanceof Date
+  ) {
+    const result: NativeDateTriggerInput = {
+      type: 'date',
+      timestamp: toTimestamp(trigger.date),
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  } else {
+    return undefined;
   }
-  return { type: 'date', timestamp: toTimestamp(trigger.date), channelId: trigger.channelId };
 }
 
 function toTimestamp(date: number | Date) {
@@ -202,70 +189,127 @@ function toTimestamp(date: number | Date) {
   return date;
 }
 
-function isDailyTriggerInput(
-  trigger: SchedulableNotificationTriggerInput
-): trigger is DailyTriggerInput {
-  if (typeof trigger !== 'object') return false;
-  const { channelId, ...triggerWithoutChannelId } = trigger as DailyTriggerInput;
-  return (
-    Object.keys(triggerWithoutChannelId).length ===
-      DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-    DAILY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(
-      (component) => component in triggerWithoutChannelId
-    ) &&
-    'repeats' in triggerWithoutChannelId &&
-    triggerWithoutChannelId.repeats === true
-  );
+function parseDailyTrigger(trigger: NotificationTriggerInput): NativeDailyTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.DAILY
+  ) {
+    validateDateComponentsInTrigger(trigger, ['hour', 'minute']);
+    const result: NativeDailyTriggerInput = {
+      type: 'daily',
+      hour: trigger.hour ?? placeholderDateComponentValue,
+      minute: trigger.minute ?? placeholderDateComponentValue,
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  }
+  return undefined;
 }
 
-function isWeeklyTriggerInput(
-  trigger: SchedulableNotificationTriggerInput
-): trigger is WeeklyTriggerInput {
-  if (typeof trigger !== 'object') return false;
-  const { channelId, ...triggerWithoutChannelId } = trigger as WeeklyTriggerInput;
-  return (
-    Object.keys(triggerWithoutChannelId).length ===
-      WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-    WEEKLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(
-      (component) => component in triggerWithoutChannelId
-    ) &&
-    'repeats' in triggerWithoutChannelId &&
-    triggerWithoutChannelId.repeats === true
-  );
+function parseWeeklyTrigger(
+  trigger: NotificationTriggerInput
+): NativeWeeklyTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.WEEKLY
+  ) {
+    validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);
+    const result: NativeWeeklyTriggerInput = {
+      type: 'weekly',
+      weekday: trigger.weekday ?? placeholderDateComponentValue,
+      hour: trigger.hour ?? placeholderDateComponentValue,
+      minute: trigger.minute ?? placeholderDateComponentValue,
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  }
+  return undefined;
 }
 
-function isYearlyTriggerInput(
-  trigger: SchedulableNotificationTriggerInput
-): trigger is YearlyTriggerInput {
-  if (typeof trigger !== 'object') return false;
-  const { channelId, ...triggerWithoutChannelId } = trigger as YearlyTriggerInput;
-  return (
-    Object.keys(triggerWithoutChannelId).length ===
-      YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.length + 1 &&
-    YEARLY_TRIGGER_EXPECTED_DATE_COMPONENTS.every(
-      (component) => component in triggerWithoutChannelId
-    ) &&
-    'repeats' in triggerWithoutChannelId &&
-    triggerWithoutChannelId.repeats === true
-  );
+function parseMonthlyTrigger(
+  trigger: NotificationTriggerInput
+): NativeMonthlyTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.MONTHLY
+  ) {
+    validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);
+    const result: NativeMonthlyTriggerInput = {
+      type: 'monthly',
+      day: trigger.day ?? placeholderDateComponentValue,
+      hour: trigger.hour ?? placeholderDateComponentValue,
+      minute: trigger.minute ?? placeholderDateComponentValue,
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  }
+  return undefined;
 }
 
-function isSecondsPropertyMisusedInCalendarTriggerInput(
-  trigger: TimeIntervalTriggerInput | CalendarTriggerInput
-) {
-  const { channelId, ...triggerWithoutChannelId } = trigger;
-  return (
-    // eg. { seconds: ..., repeats: ..., hour: ... }
-    ('seconds' in triggerWithoutChannelId &&
-      'repeats' in triggerWithoutChannelId &&
-      Object.keys(triggerWithoutChannelId).length > 2) ||
-    // eg. { seconds: ..., hour: ... }
-    ('seconds' in triggerWithoutChannelId &&
-      !('repeats' in triggerWithoutChannelId) &&
-      Object.keys(triggerWithoutChannelId).length > 1)
-  );
+function parseYearlyTrigger(
+  trigger: NotificationTriggerInput
+): NativeYearlyTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.YEARLY
+  ) {
+    validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);
+    const result: NativeYearlyTriggerInput = {
+      type: 'yearly',
+      month: trigger.month ?? placeholderDateComponentValue,
+      day: trigger.day ?? placeholderDateComponentValue,
+      hour: trigger.hour ?? placeholderDateComponentValue,
+      minute: trigger.minute ?? placeholderDateComponentValue,
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  }
+  return undefined;
 }
 
+function parseTimeIntervalTrigger(
+  trigger: NotificationTriggerInput
+): NativeTimeIntervalTriggerInput | undefined {
+  if (
+    trigger !== null &&
+    typeof trigger === 'object' &&
+    'type' in trigger &&
+    trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL &&
+    'seconds' in trigger &&
+    typeof trigger.seconds === 'number'
+  ) {
+    const result: NativeTimeIntervalTriggerInput = {
+      type: 'timeInterval',
+      seconds: trigger.seconds,
+      repeats: trigger.repeats ?? false,
+    };
+    if (trigger.channelId) {
+      result.channelId = trigger.channelId;
+    }
+    return result;
+  }
+  return undefined;
+}
+
+// Needed only to satisfy Typescript types for validated date components
+const placeholderDateComponentValue = -9999;
+
 function validateDateComponentsInTrigger(
   trigger: NonNullable<NotificationTriggerInput>,
   components: readonly ValidTriggerDateComponents[]
@@ -287,7 +331,9 @@ function validateDateComponentsInTrigger(
         break;
       }
       case 'day': {
-        const { day, month } = anyTriggerType;
+        const day = anyTriggerType.day;
+        const month =
+          anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();
         const daysInGivenMonth = daysInMonth(month);
         if (day < 1 || day > daysInGivenMonth) {
           throw new RangeError(
