diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
index 07f3a3d..3dcc0a4 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
@@ -1,6 +1,7 @@
 package expo.modules.notifications.notifications.emitting
 
 import android.os.Bundle
+import android.util.Log
 import expo.modules.kotlin.modules.Module
 import expo.modules.kotlin.modules.ModuleDefinition
 import expo.modules.notifications.notifications.NotificationSerializer
@@ -49,7 +50,10 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @param notification Notification received
    */
   override fun onNotificationReceived(notification: Notification) {
-    sendEvent(NEW_MESSAGE_EVENT_NAME, NotificationSerializer.toBundle(notification))
+    Log.i("ReactNativeJS", "onNotificationReceived:")
+    val bundle = NotificationSerializer.toBundle(notification)
+    logBundle(bundle)
+    sendEvent(NEW_MESSAGE_EVENT_NAME, bundle)
   }
 
   /**
@@ -60,13 +64,19 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @return Whether notification has been handled
    */
   override fun onNotificationResponseReceived(response: NotificationResponse): Boolean {
-    lastNotificationResponseBundle = NotificationSerializer.toBundle(response)
+    Log.i("ReactNativeJS", "onNotificationResponseReceived:")
+    val bundle = NotificationSerializer.toBundle(response)
+    logBundle(bundle);
+    lastNotificationResponseBundle = bundle
     sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
     return true
   }
 
   override fun onNotificationResponseIntentReceived(extras: Bundle?) {
-    lastNotificationResponseBundle = NotificationSerializer.toResponseBundleFromExtras(extras)
+    Log.i("ReactNativeJS", "onNotificationResponseIntentReceived:")
+    val bundle = NotificationSerializer.toResponseBundleFromExtras(extras)
+    logBundle(bundle);
+    lastNotificationResponseBundle = bundle
     sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
   }
 
@@ -77,4 +87,29 @@ open class NotificationsEmitter : Module(), NotificationListener {
   override fun onNotificationsDropped() {
     sendEvent(MESSAGES_DELETED_EVENT_NAME, Bundle.EMPTY)
   }
+
+  private fun logBundle(bundleToLog: Bundle) {
+    return logBundle("", bundleToLog)
+  }
+
+  private fun logBundle(indent: String, bundleToLog: Bundle) {
+    if (indent.equals("        ")) {
+      return;
+    }
+    bundleToLog.keySet().forEach {
+      val value = bundleToLog.get(it)
+      if (value is Bundle) {
+        val childIndent = "${indent}  "
+        Log.i("ReactNativeJS", "${indent}${it}:")
+        logBundle(childIndent, value)
+      } else {
+        val stringValue = when (value) {
+          null -> "(null)"
+          else -> "${value}"
+        }
+        Log.i("ReactNativeJS", "${indent}${it}: ${stringValue}")
+      }
+    }
+  }
 }
+
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
index 55b3a8d..f9207fc 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
@@ -1,6 +1,8 @@
 package expo.modules.notifications.service.delegates
 
 import android.content.Context
+import android.os.Bundle
+import android.util.Log
 import com.google.firebase.messaging.RemoteMessage
 import expo.modules.notifications.notifications.JSONNotificationContentBuilder
 import expo.modules.notifications.notifications.RemoteMessageSerializer
@@ -89,12 +91,25 @@ open class FirebaseMessagingDelegate(protected val context: Context) : FirebaseM
   fun getBackgroundTasks() = sBackgroundTaskConsumerReferences.values.mapNotNull { it.get() }
 
   override fun onMessageReceived(remoteMessage: RemoteMessage) {
+    Log.i("ReactNativeJS", "FirebaseMessagingDelegate.onMessageReceived")
+    logMessage(remoteMessage)
+
     NotificationsService.receive(context, createNotification(remoteMessage))
     getBackgroundTasks().forEach {
       it.scheduleJob(RemoteMessageSerializer.toBundle(remoteMessage))
     }
   }
 
+  private fun logMessage(message: RemoteMessage) {
+    Log.i("ReactNativeJS", "  notification.channelId: ${message.notification?.channelId}")
+    Log.i("ReactNativeJS", "  notification.vibrateTimings: ${message.notification?.vibrateTimings?.contentToString()}")
+    Log.i("ReactNativeJS", "  notification.body: ${message.notification?.body}")
+    Log.i("ReactNativeJS", "  data: ${message.data}")
+    Log.i("ReactNativeJS", "  notification.color: ${message.notification?.color}")
+    Log.i("ReactNativeJS", "  notification.sound: ${message.notification?.sound}")
+  }
+
+
   protected fun createNotification(remoteMessage: RemoteMessage): Notification {
     val identifier = getNotificationIdentifier(remoteMessage)
     val payload = JSONObject(remoteMessage.data as Map<*, *>)
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.js b/node_modules/expo-notifications/build/NotificationsEmitter.js
index 18cd3a4..40f59a9 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.js
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.js
@@ -94,6 +94,8 @@ export async function getLastNotificationResponseAsync() {
     if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {
         throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');
     }
-    return await NotificationsEmitterModule.getLastNotificationResponseAsync();
+    const response = await NotificationsEmitterModule.getLastNotificationResponseAsync();
+    const mappedResponse = response ? mapNotificationResponse(response) : response;
+    return mappedResponse;
 }
 //# sourceMappingURL=NotificationsEmitter.js.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/useLastNotificationResponse.js b/node_modules/expo-notifications/build/useLastNotificationResponse.js
index 34d22ab..6f38d08 100644
--- a/node_modules/expo-notifications/build/useLastNotificationResponse.js
+++ b/node_modules/expo-notifications/build/useLastNotificationResponse.js
@@ -55,11 +55,7 @@ export default function useLastNotificationResponse() {
     // and always returns the most recent response.
     useEffect(() => {
         NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {
-            // We only update the state with the resolved value if it's empty,
-            // because if it's not empty it must have been populated by the `useLayoutEffect`
-            // listener which returns "live" values.
-            const mappedResponse = response ? mapNotificationResponse(response) : response;
-            setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);
+            setLastNotificationResponse(response);
         });
     }, []);
     return lastNotificationResponse;
diff --git a/node_modules/expo-notifications/src/NotificationsEmitter.ts b/node_modules/expo-notifications/src/NotificationsEmitter.ts
index 50f9678..83f9857 100644
--- a/node_modules/expo-notifications/src/NotificationsEmitter.ts
+++ b/node_modules/expo-notifications/src/NotificationsEmitter.ts
@@ -111,5 +111,7 @@ export async function getLastNotificationResponseAsync(): Promise<NotificationRe
   if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {
     throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');
   }
-  return await NotificationsEmitterModule.getLastNotificationResponseAsync();
+  const response = await NotificationsEmitterModule.getLastNotificationResponseAsync();
+  const mappedResponse = response ? mapNotificationResponse(response) : response;
+  return mappedResponse;
 }
diff --git a/node_modules/expo-notifications/src/useLastNotificationResponse.ts b/node_modules/expo-notifications/src/useLastNotificationResponse.ts
index 0df3389..de57781 100644
--- a/node_modules/expo-notifications/src/useLastNotificationResponse.ts
+++ b/node_modules/expo-notifications/src/useLastNotificationResponse.ts
@@ -62,11 +62,7 @@ export default function useLastNotificationResponse() {
   // and always returns the most recent response.
   useEffect(() => {
     NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {
-      // We only update the state with the resolved value if it's empty,
-      // because if it's not empty it must have been populated by the `useLayoutEffect`
-      // listener which returns "live" values.
-      const mappedResponse = response ? mapNotificationResponse(response) : response;
-      setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);
+      setLastNotificationResponse(response);
     });
   }, []);
 
