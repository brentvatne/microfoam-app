diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
index 7f8133c..6d99b8a 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/NotificationSerializer.java
@@ -2,11 +2,15 @@ package expo.modules.notifications.notifications;
 
 import android.os.Build;
 import android.os.Bundle;
+import android.util.Log;
 
 import androidx.annotation.Nullable;
 
+import com.google.firebase.messaging.RemoteMessage;
+
 import org.jetbrains.annotations.NotNull;
 import org.json.JSONArray;
+import org.json.JSONException;
 import org.json.JSONObject;
 import expo.modules.core.arguments.MapArguments;
 
@@ -16,6 +20,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import expo.modules.notifications.notifications.interfaces.NotificationTrigger;
 import expo.modules.notifications.notifications.model.Notification;
@@ -52,11 +58,34 @@ public class NotificationSerializer {
   public static Bundle toBundle(NotificationRequest request) {
     Bundle serializedRequest = new Bundle();
     serializedRequest.putString("identifier", request.getIdentifier());
-    serializedRequest.putBundle("content", toBundle(request.getContent()));
     serializedRequest.putBundle("trigger", toBundle(request.getTrigger()));
+    Bundle content = toBundle(request.getContent());
+    Bundle existingContentData = content.getBundle("data");
+    if (existingContentData == null) {
+      FirebaseNotificationTrigger trigger = (FirebaseNotificationTrigger) request.getTrigger();
+      RemoteMessage message = trigger.getRemoteMessage();
+      Map<String, String> data = message.getData();
+      if (data != null) {
+        String dataBody = data.get("body");
+        if (isValidJSONString(dataBody)) {
+          content.putString("dataString", dataBody);
+        } else {
+          content.putBundle("data", toBundle(data));
+        }
+      }
+    }
+    serializedRequest.putBundle("content", content);
     return serializedRequest;
   }
 
+  public static Bundle toBundle(Map<String, String> map) {
+    Bundle result = new Bundle();
+    for (String key: map.keySet()) {
+      result.putString(key, map.get(key));
+    }
+    return result;
+  }
+
   public static Bundle toBundle(NotificationContent content) {
     Bundle serializedContent = new Bundle();
     serializedContent.putString("title", content.getTitle());
@@ -65,7 +94,7 @@ public class NotificationSerializer {
     if (content.getColor() != null) {
       serializedContent.putString("color", String.format("#%08X", content.getColor().intValue()));
     }
-    serializedContent.putBundle("data", toBundle(content.getBody()));
+
     if (content.getBadgeCount() != null) {
       serializedContent.putInt("badge", content.getBadgeCount().intValue());
     } else {
@@ -192,30 +221,75 @@ public class NotificationSerializer {
     return null;
   }
 
-    @NotNull
-    public static Bundle toResponseBundleFromExtras(Bundle extras) {
-      Bundle serializedContent = new Bundle();
-      serializedContent.putString("title", extras.getString("title"));
+  @NotNull
+  public static Bundle toResponseBundleFromExtras(Bundle extras) {
+    Bundle serializedContent = new Bundle();
+    serializedContent.putString("title", extras.getString("title"));
+    String body = extras.getString("body");
+    if (isValidJSONString(body)) {
+      // If body is a JSON string, the notification was probably sent by the Expo
+      // notification service, so we do the expected remapping of fields
+      serializedContent.putString("dataString", body);
       serializedContent.putString("body", extras.getString("message"));
-      serializedContent.putString("dataString", extras.getString("body"));
+    } else {
+      // TODO: make sure the mapping is correct
+      // For now we just set the content.data to the entire bundle
+      serializedContent.putBundle("data", extras);
+    }
+
+    Bundle serializedTrigger = new Bundle();
+    serializedTrigger.putString("type", "push");
+    serializedTrigger.putString("channelId", extras.getString("channelId"));
+
+    Bundle serializedRequest = new Bundle();
+    serializedRequest.putString("identifier", extras.getString("google.message_id"));
+    serializedRequest.putBundle("trigger", serializedTrigger);
+    serializedRequest.putBundle("content", serializedContent);
 
-      Bundle serializedTrigger = new Bundle();
-      serializedTrigger.putString("type", "push");
-      serializedTrigger.putString("channelId", extras.getString("channelId"));
+    Bundle serializedNotification = new Bundle();
+    serializedNotification.putLong("date", extras.getLong("google.sent_time"));
+    serializedNotification.putBundle("request", serializedRequest);
 
-      Bundle serializedRequest = new Bundle();
-      serializedRequest.putString("identifier", extras.getString("google.message_id"));
-      serializedRequest.putBundle("trigger", serializedTrigger);
-      serializedRequest.putBundle("content", serializedContent);
+    Bundle serializedResponse = new Bundle();
+    serializedResponse.putString("actionIdentifier", "expo.modules.notifications.actions.DEFAULT");
+    serializedResponse.putBundle("notification", serializedNotification);
 
-      Bundle serializedNotification = new Bundle();
-      serializedNotification.putLong("date", extras.getLong("google.sent_time"));
-      serializedNotification.putBundle("request", serializedRequest);
+    return serializedResponse;
+  }
+
+  public static boolean isValidJSONString(String test) {
+    try {
+      new JSONObject(test);
+    } catch (JSONException objectEx) {
+      try {
+        new JSONArray(test);
+      } catch (JSONException arrayEx) {
+        return false;
+      }
+    }
+    return true;
+  }
 
-      Bundle serializedResponse = new Bundle();
-      serializedResponse.putString("actionIdentifier", "expo.modules.notifications.actions.DEFAULT");
-      serializedResponse.putBundle("notification", serializedNotification);
+  public static void logBundle(Bundle bundleToLog) {
+    logBundle("", bundleToLog);
+  }
 
-      return serializedResponse;
+  public static void logBundle(String indent, Bundle bundleToLog) {
+    if (indent.equals("        ")) {
+      return;
     }
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+      bundleToLog.keySet().forEach(it -> {
+        Object value = bundleToLog.get(it);
+        if (value instanceof Bundle) {
+          String childIndent = indent + "  ";
+          Log.i("ReactNativeJS", indent + it);
+          logBundle(childIndent, (Bundle)value);
+        } else {
+          String stringValue = value != null ? value.toString() : "(null)";
+          Log.i("ReactNativeJS", indent + it + ": " + stringValue);
+        }
+      });
+    }
+  }
 }
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
index 07f3a3d..19b597f 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/notifications/emitting/NotificationsEmitter.kt
@@ -1,6 +1,7 @@
 package expo.modules.notifications.notifications.emitting
 
 import android.os.Bundle
+import android.util.Log
 import expo.modules.kotlin.modules.Module
 import expo.modules.kotlin.modules.ModuleDefinition
 import expo.modules.notifications.notifications.NotificationSerializer
@@ -49,7 +50,10 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @param notification Notification received
    */
   override fun onNotificationReceived(notification: Notification) {
-    sendEvent(NEW_MESSAGE_EVENT_NAME, NotificationSerializer.toBundle(notification))
+    Log.i("ReactNativeJS", "onNotificationReceived:")
+    val bundle = NotificationSerializer.toBundle(notification)
+    NotificationSerializer.logBundle(bundle)
+    sendEvent(NEW_MESSAGE_EVENT_NAME, bundle)
   }
 
   /**
@@ -60,13 +64,19 @@ open class NotificationsEmitter : Module(), NotificationListener {
    * @return Whether notification has been handled
    */
   override fun onNotificationResponseReceived(response: NotificationResponse): Boolean {
-    lastNotificationResponseBundle = NotificationSerializer.toBundle(response)
+    Log.i("ReactNativeJS", "onNotificationResponseReceived:")
+    val bundle = NotificationSerializer.toBundle(response)
+    NotificationSerializer.logBundle(bundle);
+    lastNotificationResponseBundle = bundle
     sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
     return true
   }
 
   override fun onNotificationResponseIntentReceived(extras: Bundle?) {
-    lastNotificationResponseBundle = NotificationSerializer.toResponseBundleFromExtras(extras)
+    Log.i("ReactNativeJS", "onNotificationResponseIntentReceived:")
+    val bundle = NotificationSerializer.toResponseBundleFromExtras(extras)
+    NotificationSerializer.logBundle(bundle);
+    lastNotificationResponseBundle = bundle
     sendEvent(NEW_RESPONSE_EVENT_NAME, lastNotificationResponseBundle)
   }
 
@@ -77,4 +87,6 @@ open class NotificationsEmitter : Module(), NotificationListener {
   override fun onNotificationsDropped() {
     sendEvent(MESSAGES_DELETED_EVENT_NAME, Bundle.EMPTY)
   }
+
 }
+
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt
index c957a9e..2a4ff82 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt
@@ -645,6 +645,7 @@ open class NotificationsService : BroadcastReceiver() {
         receiver?.send(SUCCESS_CODE, resultData)
       } catch (e: Exception) {
         Log.e("expo-notifications", "Action ${intent.action} failed: ${e.message}")
+        Log.e("ReactNativeJS", "Action ${intent.action} failed: ${e.message}\n${e.stackTraceToString()}")
         e.printStackTrace()
 
         receiver?.send(ERROR_CODE, Bundle().also { it.putSerializable(EXCEPTION_KEY, e) })
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.orig b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.orig
new file mode 100644
index 0000000..c957a9e
--- /dev/null
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.orig
@@ -0,0 +1,779 @@
+package expo.modules.notifications.service
+
+import android.app.PendingIntent
+import android.content.BroadcastReceiver
+import android.content.ComponentName
+import android.content.Context
+import android.content.Intent
+import android.content.pm.ActivityInfo
+import android.net.Uri
+import android.os.*
+import android.util.Log
+import androidx.core.app.RemoteInput
+import expo.modules.notifications.notifications.model.*
+import expo.modules.notifications.service.delegates.ExpoCategoriesDelegate
+import expo.modules.notifications.service.delegates.ExpoHandlingDelegate
+import expo.modules.notifications.service.delegates.ExpoPresentationDelegate
+import expo.modules.notifications.service.delegates.ExpoSchedulingDelegate
+import expo.modules.notifications.service.interfaces.CategoriesDelegate
+import expo.modules.notifications.service.interfaces.HandlingDelegate
+import expo.modules.notifications.service.interfaces.PresentationDelegate
+import expo.modules.notifications.service.interfaces.SchedulingDelegate
+import kotlin.concurrent.thread
+
+/**
+ * Subclass of FirebaseMessagingService, central dispatcher for all the notifications-related actions.
+ */
+open class NotificationsService : BroadcastReceiver() {
+  companion object {
+    const val NOTIFICATION_EVENT_ACTION = "expo.modules.notifications.NOTIFICATION_EVENT"
+    val SETUP_ACTIONS = listOf(
+      Intent.ACTION_BOOT_COMPLETED,
+      Intent.ACTION_REBOOT,
+      Intent.ACTION_MY_PACKAGE_REPLACED,
+      "android.intent.action.QUICKBOOT_POWERON",
+      "com.htc.intent.action.QUICKBOOT_POWERON"
+    )
+    const val USER_TEXT_RESPONSE_KEY = "userTextResponse"
+
+    // Event types
+    private const val GET_ALL_DISPLAYED_TYPE = "getAllDisplayed"
+    private const val PRESENT_TYPE = "present"
+    private const val DISMISS_SELECTED_TYPE = "dismissSelected"
+    private const val DISMISS_ALL_TYPE = "dismissAll"
+    private const val RECEIVE_TYPE = "receive"
+    private const val RECEIVE_RESPONSE_TYPE = "receiveResponse"
+    private const val DROPPED_TYPE = "dropped"
+    private const val GET_CATEGORIES_TYPE = "getCategories"
+    private const val SET_CATEGORY_TYPE = "setCategory"
+    private const val DELETE_CATEGORY_TYPE = "deleteCategory"
+    private const val SCHEDULE_TYPE = "schedule"
+    private const val TRIGGER_TYPE = "trigger"
+    private const val GET_ALL_SCHEDULED_TYPE = "getAllScheduled"
+    private const val GET_SCHEDULED_TYPE = "getScheduled"
+    private const val REMOVE_SELECTED_TYPE = "removeSelected"
+    private const val REMOVE_ALL_TYPE = "removeAll"
+
+    // Messages parts
+    const val SUCCESS_CODE = 0
+    const val ERROR_CODE = 1
+    const val EVENT_TYPE_KEY = "type"
+    const val EXCEPTION_KEY = "exception"
+    const val RECEIVER_KEY = "receiver"
+
+    // Specific messages parts
+    const val NOTIFICATION_KEY = "notification"
+    const val NOTIFICATION_RESPONSE_KEY = "notificationResponse"
+    const val TEXT_INPUT_NOTIFICATION_RESPONSE_KEY = "textInputNotificationResponse"
+    const val SUCCEEDED_KEY = "succeeded"
+    const val IDENTIFIERS_KEY = "identifiers"
+    const val IDENTIFIER_KEY = "identifier"
+    const val NOTIFICATION_BEHAVIOR_KEY = "notificationBehavior"
+    const val NOTIFICATIONS_KEY = "notifications"
+    const val NOTIFICATION_CATEGORY_KEY = "notificationCategory"
+    const val NOTIFICATION_CATEGORIES_KEY = "notificationCategories"
+    const val NOTIFICATION_REQUEST_KEY = "notificationRequest"
+    const val NOTIFICATION_REQUESTS_KEY = "notificationRequests"
+    const val NOTIFICATION_ACTION_KEY = "notificationAction"
+
+    /**
+     * A helper function for dispatching a "fetch all displayed notifications" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param receiver A receiver to which send the notifications
+     */
+    fun getAllPresented(context: Context, receiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION, getUriBuilder().build()).also {
+          it.putExtra(EVENT_TYPE_KEY, GET_ALL_DISPLAYED_TYPE)
+          it.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "present notification" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param notification Notification to present
+     * @param behavior Allowed notification behavior
+     * @param receiver A receiver to which send the result of presenting the notification
+     */
+    fun present(context: Context, notification: Notification, behavior: NotificationBehavior? = null, receiver: ResultReceiver? = null) {
+      val data = getUriBuilderForIdentifier(notification.notificationRequest.identifier).appendPath("present").build()
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION, data).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, PRESENT_TYPE)
+          intent.putExtra(NOTIFICATION_KEY, notification)
+          intent.putExtra(NOTIFICATION_BEHAVIOR_KEY, behavior)
+          intent.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "notification received" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param notification Notification received
+     * @param receiver Result receiver
+     */
+    fun receive(context: Context, notification: Notification, receiver: ResultReceiver? = null) {
+      val data = getUriBuilderForIdentifier(notification.notificationRequest.identifier).appendPath("receive").build()
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION, data).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, RECEIVE_TYPE)
+          intent.putExtra(NOTIFICATION_KEY, notification)
+          intent.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "dismiss notification" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param identifier Notification identifier
+     * @param receiver A receiver to which send the result of the action
+     */
+    fun dismiss(context: Context, identifiers: Array<String>, receiver: ResultReceiver? = null) {
+      val data = getUriBuilder().appendPath("dismiss").build()
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION, data).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, DISMISS_SELECTED_TYPE)
+          intent.putExtra(IDENTIFIERS_KEY, identifiers)
+          intent.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "dismiss notification" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param receiver A receiver to which send the result of the action
+     */
+    fun dismissAll(context: Context, receiver: ResultReceiver? = null) {
+      val data = getUriBuilder().appendPath("dismiss").build()
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION, data).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, DISMISS_ALL_TYPE)
+          intent.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "notifications dropped" command to the service.
+     *
+     * @param context Context where to start the service.
+     */
+    fun handleDropped(context: Context) {
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, DROPPED_TYPE)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "get notification categories" command to the service.
+     *
+     * @param context Context where to start the service.
+     */
+    fun getCategories(context: Context, receiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("categories")
+            .build()
+        ).also {
+          it.putExtra(EVENT_TYPE_KEY, GET_CATEGORIES_TYPE)
+          it.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "set notification category" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param category Notification category to be set
+     */
+    fun setCategory(context: Context, category: NotificationCategory, receiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("categories")
+            .appendPath(category.identifier)
+            .build()
+        ).also {
+          it.putExtra(EVENT_TYPE_KEY, SET_CATEGORY_TYPE)
+          it.putExtra(NOTIFICATION_CATEGORY_KEY, category as Parcelable)
+          it.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * A helper function for dispatching a "delete notification category" command to the service.
+     *
+     * @param context Context where to start the service.
+     * @param identifier Category Identifier
+     */
+    fun deleteCategory(context: Context, identifier: String, receiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("categories")
+            .appendPath(identifier)
+            .build()
+        ).also {
+          it.putExtra(EVENT_TYPE_KEY, DELETE_CATEGORY_TYPE)
+          it.putExtra(IDENTIFIER_KEY, identifier)
+          it.putExtra(RECEIVER_KEY, receiver)
+        }
+      )
+    }
+
+    /**
+     * Fetches all scheduled notifications asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param resultReceiver Receiver to be called with the results
+     */
+    fun getAllScheduledNotifications(context: Context, resultReceiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, GET_ALL_SCHEDULED_TYPE)
+          intent.putExtra(RECEIVER_KEY, resultReceiver)
+        }
+      )
+    }
+
+    /**
+     * Fetches scheduled notification asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param identifier Identifier of the notification to be fetched
+     * @param resultReceiver Receiver to be called with the results
+     */
+    fun getScheduledNotification(context: Context, identifier: String, resultReceiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("scheduled")
+            .appendPath(identifier)
+            .build()
+        ).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, GET_SCHEDULED_TYPE)
+          intent.putExtra(IDENTIFIER_KEY, identifier)
+          intent.putExtra(RECEIVER_KEY, resultReceiver)
+        }
+      )
+    }
+
+    /**
+     * Schedule notification asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param notificationRequest Notification request to schedule
+     * @param resultReceiver Receiver to be called with the result
+     */
+    fun schedule(context: Context, notificationRequest: NotificationRequest, resultReceiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("scheduled")
+            .appendPath(notificationRequest.identifier)
+            .build()
+        ).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, SCHEDULE_TYPE)
+          intent.putExtra(NOTIFICATION_REQUEST_KEY, notificationRequest as Parcelable)
+          intent.putExtra(RECEIVER_KEY, resultReceiver)
+        }
+      )
+    }
+
+    /**
+     * Cancel selected scheduled notification and remove it from the storage asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param identifier Identifier of the notification to be removed
+     * @param resultReceiver Receiver to be called with the result
+     */
+    fun removeScheduledNotification(context: Context, identifier: String, resultReceiver: ResultReceiver? = null) =
+      removeScheduledNotifications(context, listOf(identifier), resultReceiver)
+
+    /**
+     * Cancel selected scheduled notifications and remove them from the storage asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param identifiers Identifiers of selected notifications to be removed
+     * @param resultReceiver Receiver to be called with the result
+     */
+    fun removeScheduledNotifications(context: Context, identifiers: Collection<String>, resultReceiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(
+          NOTIFICATION_EVENT_ACTION,
+          getUriBuilder()
+            .appendPath("scheduled")
+            .build()
+        ).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, REMOVE_SELECTED_TYPE)
+          intent.putExtra(IDENTIFIERS_KEY, identifiers.toTypedArray())
+          intent.putExtra(RECEIVER_KEY, resultReceiver)
+        }
+      )
+    }
+
+    /**
+     * Cancel all scheduled notifications and remove them from the storage asynchronously.
+     *
+     * @param context Context this is being called from
+     * @param resultReceiver Receiver to be called with the result
+     */
+    fun removeAllScheduledNotifications(context: Context, resultReceiver: ResultReceiver? = null) {
+      doWork(
+        context,
+        Intent(NOTIFICATION_EVENT_ACTION).also { intent ->
+          intent.putExtra(EVENT_TYPE_KEY, REMOVE_ALL_TYPE)
+          intent.putExtra(RECEIVER_KEY, resultReceiver)
+        }
+      )
+    }
+
+    /**
+     * Sends the intent to the best service to handle the {@link #NOTIFICATION_EVENT_ACTION} intent
+     * or handles the intent immediately if the service is already up.
+     *
+     * @param context Context where to start the service
+     * @param intent Intent to dispatch
+     */
+    fun doWork(context: Context, intent: Intent) {
+      findDesignatedBroadcastReceiver(context, intent)?.let {
+        intent.component = ComponentName(it.packageName, it.name)
+        context.sendBroadcast(intent)
+        return
+      }
+      Log.e("expo-notifications", "No service capable of handling notifications found (intent = ${intent.action}). Ensure that you have configured your AndroidManifest.xml properly.")
+    }
+
+    protected fun getUriBuilder(): Uri.Builder {
+      return Uri.parse("expo-notifications://notifications/").buildUpon()
+    }
+
+    protected fun getUriBuilderForIdentifier(identifier: String): Uri.Builder {
+      return getUriBuilder().appendPath(identifier)
+    }
+
+    fun findDesignatedBroadcastReceiver(context: Context, intent: Intent): ActivityInfo? {
+      val searchIntent = Intent(intent.action).setPackage(context.packageName)
+      return context.packageManager.queryBroadcastReceivers(searchIntent, 0).firstOrNull()?.activityInfo
+    }
+
+    /**
+     * Creates and returns a pending intent that will trigger [NotificationsService],
+     * which hands off the work to this class. The intent triggers notification of the given identifier.
+     *
+     * @param context Context this is being called from
+     * @param identifier Notification identifier
+     * @return [PendingIntent] triggering [NotificationsService], triggering notification of given ID.
+     */
+    fun createNotificationTrigger(context: Context, identifier: String): PendingIntent {
+      val intent = Intent(
+        NOTIFICATION_EVENT_ACTION,
+        getUriBuilder()
+          .appendPath("scheduled")
+          .appendPath(identifier)
+          .appendPath("trigger")
+          .build()
+      ).also { intent ->
+        findDesignatedBroadcastReceiver(context, intent)?.let {
+          intent.component = ComponentName(it.packageName, it.name)
+        }
+        intent.putExtra(EVENT_TYPE_KEY, TRIGGER_TYPE)
+        intent.putExtra(IDENTIFIER_KEY, identifier)
+      }
+
+      // We're defaulting to the behaviour prior API 31 (mutable) even though Android recommends immutability
+      val mutableFlag = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) PendingIntent.FLAG_MUTABLE else 0
+      return PendingIntent.getBroadcast(
+        context,
+        intent.component?.className?.hashCode() ?: NotificationsService::class.java.hashCode(),
+        intent,
+        PendingIntent.FLAG_UPDATE_CURRENT or mutableFlag
+      )
+    }
+
+    /**
+     * Creates and returns a pending intent that will trigger [NotificationsService]'s "response received"
+     * event.
+     *
+     * @param context Context this is being called from
+     * @param notification Notification being responded to
+     * @param action Notification action being undertaken
+     * @return [PendingIntent] triggering [NotificationsService], triggering "response received" event
+     */
+    fun createNotificationResponseIntent(context: Context, notification: Notification, action: NotificationAction): PendingIntent {
+      val intent = Intent(
+        NOTIFICATION_EVENT_ACTION,
+        getUriBuilder()
+          .appendPath(notification.notificationRequest.identifier)
+          .appendPath("actions")
+          .appendPath(action.identifier)
+          .build()
+      ).also { intent ->
+        findDesignatedBroadcastReceiver(context, intent)?.let {
+          intent.component = ComponentName(it.packageName, it.name)
+        }
+        intent.putExtra(EVENT_TYPE_KEY, RECEIVE_RESPONSE_TYPE)
+        intent.putExtra(NOTIFICATION_KEY, notification)
+        intent.putExtra(NOTIFICATION_ACTION_KEY, action as Parcelable)
+      }
+
+      // Starting from Android 12,
+      // [notification trampolines](https://developer.android.com/about/versions/12/behavior-changes-12#identify-notification-trampolines)
+      // are not allowed. If the notification wants to open foreground app,
+      // we should use the dedicated Activity pendingIntent.
+      if (action.opensAppToForeground()) {
+        val notificationResponse = getNotificationResponseFromBroadcastIntent(intent)
+        return ExpoHandlingDelegate.createPendingIntentForOpeningApp(context, intent, notificationResponse)
+      }
+
+      // We're defaulting to the behaviour prior API 31 (mutable) even though Android recommends immutability
+      val mutableFlag = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) PendingIntent.FLAG_MUTABLE else 0
+      return PendingIntent.getBroadcast(
+        context,
+        intent.component?.className?.hashCode() ?: NotificationsService::class.java.hashCode(),
+        intent,
+        PendingIntent.FLAG_UPDATE_CURRENT or mutableFlag
+      )
+    }
+
+    /**
+     * Recreate an Intent from [createNotificationResponseIntent] extras
+     * for [NotificationForwarderActivity] to send broadcasts
+     */
+    fun createNotificationResponseBroadcastIntent(context: Context, extras: Bundle?): Intent {
+      val notification = extras?.getParcelable<Notification>(NOTIFICATION_KEY)
+      val action = extras?.getParcelable<NotificationAction>(NOTIFICATION_ACTION_KEY)
+      if (notification == null || action == null) {
+        throw IllegalArgumentException("notification and action should not be null")
+      }
+      val backgroundAction = NotificationAction(action.identifier, action.title, false)
+      val intent = Intent(
+        NOTIFICATION_EVENT_ACTION,
+        getUriBuilder()
+          .appendPath(notification.notificationRequest.identifier)
+          .appendPath("actions")
+          .appendPath(backgroundAction.identifier)
+          .build()
+      ).also { intent ->
+        findDesignatedBroadcastReceiver(context, intent)?.let {
+          intent.component = ComponentName(it.packageName, it.name)
+        }
+        intent.putExtra(EVENT_TYPE_KEY, RECEIVE_RESPONSE_TYPE)
+        intent.putExtra(NOTIFICATION_KEY, notification)
+        intent.putExtra(NOTIFICATION_ACTION_KEY, backgroundAction as Parcelable)
+      }
+      return intent
+    }
+
+    fun getNotificationResponseFromBroadcastIntent(intent: Intent): NotificationResponse {
+      val notification = intent.getParcelableExtra<Notification>(NOTIFICATION_KEY) ?: throw IllegalArgumentException("$NOTIFICATION_KEY not found in the intent extras.")
+      val action = intent.getParcelableExtra<NotificationAction>(NOTIFICATION_ACTION_KEY) ?: throw IllegalArgumentException("$NOTIFICATION_ACTION_KEY not found in the intent extras.")
+      val response = if (action is TextInputNotificationAction) {
+        val userText = action.placeholder ?: RemoteInput.getResultsFromIntent(intent)?.getString(USER_TEXT_RESPONSE_KEY) ?: ""
+        TextInputNotificationResponse(action, notification, userText)
+      } else {
+        NotificationResponse(action, notification)
+      }
+      return response
+    }
+
+    fun getNotificationResponseFromOpenIntent(intent: Intent): NotificationResponse? {
+      intent.getByteArrayExtra(NOTIFICATION_RESPONSE_KEY)?.let { return unmarshalObject(NotificationResponse.CREATOR, it) }
+      intent.getByteArrayExtra(TEXT_INPUT_NOTIFICATION_RESPONSE_KEY)?.let { return unmarshalObject(TextInputNotificationResponse.CREATOR, it) }
+      return null
+    }
+
+    // Class loader used in BaseBundle when unmarshalling notification extras
+    // cannot handle expo.modules.notifications.….NotificationResponse
+    // so we go around it by marshalling and unmarshalling the object ourselves.
+    fun setNotificationResponseToIntent(intent: Intent, notificationResponse: NotificationResponse) {
+      try {
+        val keyToPutResponseUnder = if (notificationResponse is TextInputNotificationResponse) {
+          TEXT_INPUT_NOTIFICATION_RESPONSE_KEY
+        } else {
+          NOTIFICATION_RESPONSE_KEY
+        }
+        intent.putExtra(keyToPutResponseUnder, marshalObject(notificationResponse))
+      } catch (e: Exception) {
+        // If we couldn't marshal the request, let's not fail the whole build process.
+        Log.e("expo-notifications", "Could not marshal notification response: ${notificationResponse.actionIdentifier}.")
+        e.printStackTrace()
+      }
+    }
+
+    /**
+     * Marshals [Parcelable] into to a byte array.
+     *
+     * @param notificationResponse Notification response to marshall
+     * @return Given request marshalled to a byte array or null if the process failed.
+     */
+    private fun marshalObject(objectToMarshal: Parcelable): ByteArray? {
+      val parcel: Parcel = Parcel.obtain()
+      objectToMarshal.writeToParcel(parcel, 0)
+      val bytes: ByteArray = parcel.marshall()
+      parcel.recycle()
+      return bytes
+    }
+
+    /**
+     * UNmarshals [Parcelable] object from a byte array given a [Parcelable.Creator].
+     * @return Object instance or null if the process failed.
+     */
+    private fun <T> unmarshalObject(creator: Parcelable.Creator<T>, byteArray: ByteArray?): T? {
+      byteArray?.let {
+        try {
+          val parcel = Parcel.obtain()
+          parcel.unmarshall(it, 0, it.size)
+          parcel.setDataPosition(0)
+          val unmarshaledObject = creator.createFromParcel(parcel)
+          parcel.recycle()
+          return unmarshaledObject
+        } catch (e: Exception) {
+          Log.e("expo-notifications", "Could not unmarshall NotificationResponse from Intent.extra.", e)
+        }
+      }
+      return null
+    }
+  }
+
+  protected open fun getPresentationDelegate(context: Context): PresentationDelegate =
+    ExpoPresentationDelegate(context)
+
+  protected open fun getHandlingDelegate(context: Context): HandlingDelegate =
+    ExpoHandlingDelegate(context)
+
+  protected open fun getCategoriesDelegate(context: Context): CategoriesDelegate =
+    ExpoCategoriesDelegate(context)
+
+  protected open fun getSchedulingDelegate(context: Context): SchedulingDelegate =
+    ExpoSchedulingDelegate(context)
+
+  override fun onReceive(context: Context, intent: Intent?) {
+    val pendingIntent = goAsync()
+    thread {
+      try {
+        handleIntent(context, intent)
+      } finally {
+        pendingIntent.finish()
+      }
+    }
+  }
+
+  open fun handleIntent(context: Context, intent: Intent?) {
+    if (intent != null && SETUP_ACTIONS.contains(intent.action)) {
+      onSetupScheduledNotifications(context, intent)
+    } else if (intent?.action === NOTIFICATION_EVENT_ACTION) {
+      val receiver: ResultReceiver? = intent.extras?.get(RECEIVER_KEY) as? ResultReceiver
+      try {
+        var resultData: Bundle? = null
+        when (val eventType = intent.getStringExtra(EVENT_TYPE_KEY)) {
+          GET_ALL_DISPLAYED_TYPE ->
+            resultData = onGetAllPresentedNotifications(context, intent)
+
+          RECEIVE_TYPE -> onReceiveNotification(context, intent)
+
+          RECEIVE_RESPONSE_TYPE -> onReceiveNotificationResponse(context, intent)
+
+          DROPPED_TYPE -> onNotificationsDropped(context, intent)
+
+          PRESENT_TYPE -> onPresentNotification(context, intent)
+
+          DISMISS_SELECTED_TYPE -> onDismissNotifications(context, intent)
+
+          DISMISS_ALL_TYPE -> onDismissAllNotifications(context, intent)
+
+          GET_CATEGORIES_TYPE ->
+            resultData = onGetCategories(context, intent)
+
+          SET_CATEGORY_TYPE ->
+            resultData = onSetCategory(context, intent)
+
+          DELETE_CATEGORY_TYPE ->
+            resultData = onDeleteCategory(context, intent)
+
+          GET_ALL_SCHEDULED_TYPE ->
+            resultData = onGetAllScheduledNotifications(context, intent)
+
+          GET_SCHEDULED_TYPE ->
+            resultData = onGetScheduledNotification(context, intent)
+
+          SCHEDULE_TYPE -> onScheduleNotification(context, intent)
+
+          REMOVE_SELECTED_TYPE -> onRemoveScheduledNotifications(context, intent)
+
+          REMOVE_ALL_TYPE -> onRemoveAllScheduledNotifications(context, intent)
+
+          TRIGGER_TYPE -> onNotificationTriggered(context, intent)
+
+          else -> throw IllegalArgumentException("Received event of unrecognized type: $eventType. Ignoring.")
+        }
+
+        // If we ended up here, the callbacks must have completed successfully
+        receiver?.send(SUCCESS_CODE, resultData)
+      } catch (e: Exception) {
+        Log.e("expo-notifications", "Action ${intent.action} failed: ${e.message}")
+        e.printStackTrace()
+
+        receiver?.send(ERROR_CODE, Bundle().also { it.putSerializable(EXCEPTION_KEY, e) })
+      }
+    } else {
+      throw IllegalArgumentException("Received intent of unrecognized action: ${intent?.action}. Ignoring.")
+    }
+  }
+
+  //region Presenting notifications
+
+  open fun onPresentNotification(context: Context, intent: Intent) =
+    getPresentationDelegate(context).presentNotification(
+      intent.extras?.getParcelable(NOTIFICATION_KEY)!!,
+      intent.extras?.getParcelable(NOTIFICATION_BEHAVIOR_KEY)
+    )
+
+  open fun onGetAllPresentedNotifications(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putParcelableArrayList(
+        NOTIFICATIONS_KEY,
+        ArrayList(
+          getPresentationDelegate(context).getAllPresentedNotifications()
+        )
+      )
+    }
+
+  open fun onDismissNotifications(context: Context, intent: Intent) =
+    getPresentationDelegate(context).dismissNotifications(
+      intent.extras?.getStringArray(IDENTIFIERS_KEY)!!.asList()
+    )
+
+  open fun onDismissAllNotifications(context: Context, intent: Intent) =
+    getPresentationDelegate(context).dismissAllNotifications()
+
+  //endregion
+
+  //region Handling notifications
+
+  open fun onReceiveNotification(context: Context, intent: Intent) =
+    getHandlingDelegate(context).handleNotification(
+      intent.getParcelableExtra(NOTIFICATION_KEY)!!
+    )
+
+  open fun onReceiveNotificationResponse(context: Context, intent: Intent) {
+    val response = getNotificationResponseFromBroadcastIntent(intent)
+    getHandlingDelegate(context).handleNotificationResponse(response)
+  }
+
+  open fun onNotificationsDropped(context: Context, intent: Intent) =
+    getHandlingDelegate(context).handleNotificationsDropped()
+
+  //endregion
+
+  //region Category handling
+
+  open fun onGetCategories(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putParcelableArrayList(
+        NOTIFICATION_CATEGORIES_KEY,
+        ArrayList(
+          getCategoriesDelegate(context).getCategories()
+        )
+      )
+    }
+
+  open fun onSetCategory(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putParcelable(
+        NOTIFICATION_CATEGORY_KEY,
+        getCategoriesDelegate(context).setCategory(
+          intent.getParcelableExtra(NOTIFICATION_CATEGORY_KEY)!!
+        )
+      )
+    }
+
+  open fun onDeleteCategory(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putBoolean(
+        SUCCEEDED_KEY,
+        getCategoriesDelegate(context).deleteCategory(
+          intent.extras?.getString(IDENTIFIER_KEY)!!
+        )
+      )
+    }
+  //endregion
+
+  //region Scheduling notifications
+
+  open fun onGetAllScheduledNotifications(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putParcelableArrayList(
+        NOTIFICATION_REQUESTS_KEY,
+        ArrayList(
+          getSchedulingDelegate(context).getAllScheduledNotifications()
+        )
+      )
+    }
+
+  open fun onGetScheduledNotification(context: Context, intent: Intent) =
+    Bundle().also {
+      it.putParcelable(
+        NOTIFICATION_REQUEST_KEY,
+        getSchedulingDelegate(context).getScheduledNotification(
+          intent.extras?.getString(IDENTIFIER_KEY)!!
+        )
+      )
+    }
+
+  open fun onScheduleNotification(context: Context, intent: Intent) =
+    getSchedulingDelegate(context).scheduleNotification(
+      intent.extras?.getParcelable(NOTIFICATION_REQUEST_KEY)!!
+    )
+
+  open fun onNotificationTriggered(context: Context, intent: Intent) =
+    getSchedulingDelegate(context).triggerNotification(
+      intent.extras?.getString(IDENTIFIER_KEY)!!
+    )
+
+  open fun onRemoveScheduledNotifications(context: Context, intent: Intent) =
+    getSchedulingDelegate(context).removeScheduledNotifications(
+      intent.extras?.getStringArray(IDENTIFIERS_KEY)!!.asList()
+    )
+
+  open fun onRemoveAllScheduledNotifications(context: Context, intent: Intent) =
+    getSchedulingDelegate(context).removeAllScheduledNotifications()
+
+  open fun onSetupScheduledNotifications(context: Context, intent: Intent) =
+    getSchedulingDelegate(context).setupScheduledNotifications()
+
+  //endregion
+}
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.rej b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.rej
new file mode 100644
index 0000000..b3a2f89
--- /dev/null
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/NotificationsService.kt.rej
@@ -0,0 +1,18 @@
+@@ -454,7 +454,7 @@
+       // [notification trampolines](https://developer.android.com/about/versions/12/behavior-changes-12#identify-notification-trampolines)
+       // are not allowed. If the notification wants to open foreground app,
+       // we should use the dedicated Activity pendingIntent.
+-      if (action.opensAppToForeground() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
++      if (action.opensAppToForeground() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+         val notificationResponse = getNotificationResponseFromBroadcastIntent(intent)
+         return ExpoHandlingDelegate.createPendingIntentForOpeningApp(context, intent, notificationResponse)
+       }
+@@ -502,7 +502,7 @@
+       val notification = intent.getParcelableExtra<Notification>(NOTIFICATION_KEY) ?: throw IllegalArgumentException("$NOTIFICATION_KEY not found in the intent extras.")
+       val action = intent.getParcelableExtra<NotificationAction>(NOTIFICATION_ACTION_KEY) ?: throw IllegalArgumentException("$NOTIFICATION_ACTION_KEY not found in the intent extras.")
+       val response = if (action is TextInputNotificationAction) {
+-        val userText = RemoteInput.getResultsFromIntent(intent)?.getString(USER_TEXT_RESPONSE_KEY) ?: ""
++        val userText = RemoteInput.getResultsFromIntent(intent)?.getString(USER_TEXT_RESPONSE_KEY) ?: ""
+         TextInputNotificationResponse(action, notification, userText)
+       } else {
+         NotificationResponse(action, notification)
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java
index 77591a5..cde3f33 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/ExpoNotificationLifecycleListener.java
@@ -1,22 +1,14 @@
 package expo.modules.notifications.service.delegates;
 
 import android.app.Activity;
-import android.app.NotificationChannel;
-import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
-import android.os.Parcel;
 import android.util.Log;
 
-import androidx.core.app.NotificationCompat;
-
-import java.util.Objects;
-
 import expo.modules.core.interfaces.ReactActivityLifecycleListener;
 import expo.modules.notifications.notifications.NotificationManager;
-import expo.modules.notifications.notifications.model.Notification;
-import expo.modules.notifications.notifications.model.NotificationResponse;
+import expo.modules.notifications.notifications.NotificationSerializer;
 
 public class ExpoNotificationLifecycleListener implements ReactActivityLifecycleListener {
 
@@ -37,6 +29,7 @@ public class ExpoNotificationLifecycleListener implements ReactActivityLifecycle
      */
     @Override
     public void onCreate(Activity activity, Bundle savedInstanceState) {
+        Log.i("ReactNativeJS", "ExpoNotificationLifeCycleListener.onCreate:");
         Intent intent = activity.getIntent();
         if (intent != null) {
             Bundle extras = intent.getExtras();
@@ -45,6 +38,7 @@ public class ExpoNotificationLifecycleListener implements ReactActivityLifecycle
                     Log.d("ReactNativeJS", "[native] ExpoNotificationLifecycleListener contains an unmarshaled notification response. Skipping.");
                     return;
                 }
+                NotificationSerializer.logBundle(extras);
                 mNotificationManager.onNotificationResponseFromExtras(extras);
             }
         }
@@ -62,12 +56,14 @@ public class ExpoNotificationLifecycleListener implements ReactActivityLifecycle
     @Override
     public boolean onNewIntent(Intent intent) {
         Bundle extras = intent.getExtras();
+        Log.i("ReactNativeJS", "ExpoNotificationLifeCycleListener.onNewIntent:");
         if (extras != null) {
             if (extras.containsKey("notificationResponse")) {
                 Log.d("ReactNativeJS", "[native] ExpoNotificationLifecycleListener contains an unmarshaled notification response. Skipping.");
                 intent.removeExtra("notificationResponse");
                 return ReactActivityLifecycleListener.super.onNewIntent(intent);
             }
+            NotificationSerializer.logBundle(extras);
             mNotificationManager.onNotificationResponseFromExtras(extras);
         }
         return ReactActivityLifecycleListener.super.onNewIntent(intent);
diff --git a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
index 954cd01..122a93a 100644
--- a/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
+++ b/node_modules/expo-notifications/android/src/main/java/expo/modules/notifications/service/delegates/FirebaseMessagingDelegate.kt
@@ -1,6 +1,10 @@
 package expo.modules.notifications.service.delegates
 
 import android.content.Context
+import android.os.Build
+import android.os.Bundle
+import android.util.Log
+import androidx.annotation.RequiresApi
 import com.google.firebase.messaging.RemoteMessage
 import expo.modules.notifications.notifications.JSONNotificationContentBuilder
 import expo.modules.notifications.notifications.RemoteMessageSerializer
@@ -73,6 +77,32 @@ open class FirebaseMessagingDelegate(protected val context: Context) : FirebaseM
       }
       sBackgroundTaskConsumerReferences[taskConsumer] = WeakReference(taskConsumer)
     }
+
+    fun logMessage(caller: String, message: RemoteMessage) {
+      Log.i("ReactNativeJS", "${caller}:")
+      Log.i("ReactNativeJS", "  notification.channelId: ${message.notification?.channelId}")
+      Log.i("ReactNativeJS", "  notification.vibrateTimings: ${message.notification?.vibrateTimings?.contentToString()}")
+      Log.i("ReactNativeJS", "  notification.body: ${message.notification?.body}")
+      Log.i("ReactNativeJS", "  notification.color: ${message.notification?.color}")
+      Log.i("ReactNativeJS", "  notification.sound: ${message.notification?.sound}")
+      Log.i("ReactNativeJS", "  notification.title: ${message.notification?.title}")
+      Log.i("ReactNativeJS", "  notification.collapseKey: ${message.collapseKey}")
+      Log.i("ReactNativeJS", "  data: ${message.data}")
+    }
+
+    @RequiresApi(Build.VERSION_CODES.O)
+    fun logNotification(caller: String, notification: Notification) {
+      Log.i("ReactNativeJS", "${caller}:")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.title: ${notification.notificationRequest.content.title}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.subtitle: ${notification.notificationRequest.content.subtitle}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.text: ${notification.notificationRequest.content.text}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.sound: ${notification.notificationRequest.content.sound}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.body: ${notification.notificationRequest.content.body}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.color: ${notification.notificationRequest.content.color}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.content.vibrationPattern: ${notification.notificationRequest.content.vibrationPattern.contentToString()}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.trigger.notificationChannel: ${notification.notificationRequest.trigger.notificationChannel}")
+      Log.i("ReactNativeJS", "  notification.notificationRequest.identifier: ${notification.notificationRequest.identifier}")
+    }
   }
 
   /**
@@ -90,7 +120,12 @@ open class FirebaseMessagingDelegate(protected val context: Context) : FirebaseM
   fun getBackgroundTasks() = sBackgroundTaskConsumerReferences.values.mapNotNull { it.get() }
 
   override fun onMessageReceived(remoteMessage: RemoteMessage) {
-    NotificationsService.receive(context, createNotification(remoteMessage))
+    logMessage("FirebaseMessagingDelegate.onMessageReceived: message", remoteMessage)
+    val notification = createNotification(remoteMessage)
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      logNotification("FirebaseMessagingDelegate.onMessageReceived: notification", notification)
+    }
+    NotificationsService.receive(context, notification)
     getBackgroundTasks().forEach {
       it.scheduleJob(RemoteMessageSerializer.toBundle(remoteMessage))
     }
@@ -103,7 +138,7 @@ open class FirebaseMessagingDelegate(protected val context: Context) : FirebaseM
     if (vibrationPattern != null) {
       val jsonVibrationTimings = JSONArray()
       vibrationPattern.forEach {
-        jsonVibrationTimings.put(it.toInt())
+        jsonVibrationTimings.put(it.toInt() )
       }
       payload.put("vibrate", jsonVibrationTimings)
     }
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map b/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
index 493dc6a..1121fe4 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationsEmitter.d.ts","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,YAAY,EAAuB,MAAM,mBAAmB,CAAC;AAEpF,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAY3E,eAAO,MAAM,yBAAyB,+CAA+C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,wBAAgB,+BAA+B,CAC7C,QAAQ,EAAE,CAAC,KAAK,EAAE,YAAY,KAAK,IAAI,GACtC,YAAY,CAEd;AAED;;;;;;;GAOG;AACH,wBAAgB,+BAA+B,CAAC,QAAQ,EAAE,MAAM,IAAI,GAAG,YAAY,CAElF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,wBAAgB,uCAAuC,CACrD,QAAQ,EAAE,CAAC,KAAK,EAAE,oBAAoB,KAAK,IAAI,GAC9C,YAAY,CAQd;AAED;;;;GAIG;AACH,wBAAgB,8BAA8B,CAAC,YAAY,EAAE,YAAY,QAExE;AAGD;;GAEG;AACH,wBAAsB,gCAAgC,IAAI,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC,CAO7F"}
\ No newline at end of file
+{"version":3,"file":"NotificationsEmitter.d.ts","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,YAAY,EAAuB,MAAM,mBAAmB,CAAC;AAEpF,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAY3E,eAAO,MAAM,yBAAyB,+CAA+C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,wBAAgB,+BAA+B,CAC7C,QAAQ,EAAE,CAAC,KAAK,EAAE,YAAY,KAAK,IAAI,GACtC,YAAY,CAQd;AAED;;;;;;;GAOG;AACH,wBAAgB,+BAA+B,CAAC,QAAQ,EAAE,MAAM,IAAI,GAAG,YAAY,CAElF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,wBAAgB,uCAAuC,CACrD,QAAQ,EAAE,CAAC,KAAK,EAAE,oBAAoB,KAAK,IAAI,GAC9C,YAAY,CAQd;AAED;;;;GAIG;AACH,wBAAgB,8BAA8B,CAAC,YAAY,EAAE,YAAY,QAExE;AAGD;;GAEG;AACH,wBAAsB,gCAAgC,IAAI,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC,CAO7F"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.js b/node_modules/expo-notifications/build/NotificationsEmitter.js
index 40f59a9..e027c06 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.js
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.js
@@ -1,6 +1,6 @@
 import { EventEmitter, UnavailabilityError } from 'expo-modules-core';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
-import { mapNotificationResponse } from './utils/mapNotificationResponse';
+import { mapNotification, mapNotificationResponse } from './utils/mapNotificationResponse';
 // Web uses SyntheticEventEmitter
 const emitter = new EventEmitter(NotificationsEmitterModule);
 const didReceiveNotificationEventName = 'onDidReceiveNotification';
@@ -33,7 +33,10 @@ export const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEF
  * @header listen
  */
 export function addNotificationReceivedListener(listener) {
-    return emitter.addListener(didReceiveNotificationEventName, listener);
+    return emitter.addListener(didReceiveNotificationEventName, (notification) => {
+        const mappedNotification = mapNotification(notification);
+        listener(mappedNotification);
+    });
 }
 /**
  * Listeners registered by this method will be called whenever some notifications have been dropped by the server.
diff --git a/node_modules/expo-notifications/build/NotificationsEmitter.js.map b/node_modules/expo-notifications/build/NotificationsEmitter.js.map
index 6424444..db81215 100644
--- a/node_modules/expo-notifications/build/NotificationsEmitter.js.map
+++ b/node_modules/expo-notifications/build/NotificationsEmitter.js.map
@@ -1 +1 @@
-{"version":3,"file":"NotificationsEmitter.js","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAgB,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAGpF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AACtE,OAAO,EAAE,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAE1E,iCAAiC;AACjC,MAAM,OAAO,GAAG,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAE7D,MAAM,+BAA+B,GAAG,0BAA0B,CAAC;AACnE,MAAM,6BAA6B,GAAG,wBAAwB,CAAC;AAC/D,MAAM,uCAAuC,GAAG,kCAAkC,CAAC;AAEnF,eAAe;AACf,MAAM,CAAC,MAAM,yBAAyB,GAAG,4CAA4C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,+BAA+B,CAC7C,QAAuC;IAEvC,OAAO,OAAO,CAAC,WAAW,CAAe,+BAA+B,EAAE,QAAQ,CAAC,CAAC;AACtF,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,+BAA+B,CAAC,QAAoB;IAClE,OAAO,OAAO,CAAC,WAAW,CAAO,6BAA6B,EAAE,QAAQ,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,UAAU,uCAAuC,CACrD,QAA+C;IAE/C,OAAO,OAAO,CAAC,WAAW,CACxB,uCAAuC,EACvC,CAAC,QAA8B,EAAE,EAAE;QACjC,MAAM,cAAc,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QACzD,QAAQ,CAAC,cAAc,CAAC,CAAC;IAC3B,CAAC,CACF,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,8BAA8B,CAAC,YAA0B;IACvE,OAAO,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;AAC3C,CAAC;AAED,eAAe;AACf;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,gCAAgC;IACpD,IAAI,CAAC,0BAA0B,CAAC,gCAAgC,EAAE;QAChE,MAAM,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,kCAAkC,CAAC,CAAC;KACxF;IACD,MAAM,QAAQ,GAAG,MAAM,0BAA0B,CAAC,gCAAgC,EAAE,CAAC;IACrF,MAAM,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IAC/E,OAAO,cAAc,CAAC;AACxB,CAAC","sourcesContent":["import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationResponse } from './Notifications.types';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotificationResponse } from './utils/mapNotificationResponse';\n\n// Web uses SyntheticEventEmitter\nconst emitter = new EventEmitter(NotificationsEmitterModule);\n\nconst didReceiveNotificationEventName = 'onDidReceiveNotification';\nconst didDropNotificationsEventName = 'onNotificationsDeleted';\nconst didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\n\n// @docsMissing\nexport const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\n\n/**\n * Listeners registered by this method will be called whenever a notification is received while the app is running.\n * @param listener A function accepting a notification ([`Notification`](#notification)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Registering a notification listener using a React hook:\n * ```jsx\n * import React from 'react';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function App() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationReceivedListener(notification => {\n *       console.log(notification);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationReceivedListener(\n  listener: (event: Notification) => void\n): Subscription {\n  return emitter.addListener<Notification>(didReceiveNotificationEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever some notifications have been dropped by the server.\n * Applicable only to Firebase Cloud Messaging which we use as a notifications service on Android. It corresponds to `onDeletedMessages()` callback.\n * More information can be found in [Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n * @param listener A callback function.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @header listen\n */\nexport function addNotificationsDroppedListener(listener: () => void): Subscription {\n  return emitter.addListener<void>(didDropNotificationsEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever a user interacts with a notification (for example, taps on it).\n * @param listener A function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Register a notification responder listener:\n * ```jsx\n * import React from 'react';\n * import { Linking } from 'react-native';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function Container() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n *       const url = response.notification.request.content.data.url;\n *       Linking.openURL(url);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationResponseReceivedListener(\n  listener: (event: NotificationResponse) => void\n): Subscription {\n  return emitter.addListener<NotificationResponse>(\n    didReceiveNotificationResponseEventName,\n    (response: NotificationResponse) => {\n      const mappedResponse = mapNotificationResponse(response);\n      listener(mappedResponse);\n    }\n  );\n}\n\n/**\n * Removes a notification subscription returned by an `addNotificationListener` call.\n * @param subscription A subscription returned by `addNotificationListener` method.\n * @header listen\n */\nexport function removeNotificationSubscription(subscription: Subscription) {\n  emitter.removeSubscription(subscription);\n}\n\n// @docsMissing\n/**\n * @header listen\n */\nexport async function getLastNotificationResponseAsync(): Promise<NotificationResponse | null> {\n  if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');\n  }\n  const response = await NotificationsEmitterModule.getLastNotificationResponseAsync();\n  const mappedResponse = response ? mapNotificationResponse(response) : response;\n  return mappedResponse;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NotificationsEmitter.js","sourceRoot":"","sources":["../src/NotificationsEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAgB,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAGpF,OAAO,0BAA0B,MAAM,8BAA8B,CAAC;AACtE,OAAO,EAAE,eAAe,EAAE,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAE3F,iCAAiC;AACjC,MAAM,OAAO,GAAG,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAE7D,MAAM,+BAA+B,GAAG,0BAA0B,CAAC;AACnE,MAAM,6BAA6B,GAAG,wBAAwB,CAAC;AAC/D,MAAM,uCAAuC,GAAG,kCAAkC,CAAC;AAEnF,eAAe;AACf,MAAM,CAAC,MAAM,yBAAyB,GAAG,4CAA4C,CAAC;AAEtF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,+BAA+B,CAC7C,QAAuC;IAEvC,OAAO,OAAO,CAAC,WAAW,CACxB,+BAA+B,EAC/B,CAAC,YAA0B,EAAE,EAAE;QAC7B,MAAM,kBAAkB,GAAG,eAAe,CAAC,YAAY,CAAC,CAAC;QACzD,QAAQ,CAAC,kBAAkB,CAAC,CAAC;IAC/B,CAAC,CACF,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,+BAA+B,CAAC,QAAoB;IAClE,OAAO,OAAO,CAAC,WAAW,CAAO,6BAA6B,EAAE,QAAQ,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,UAAU,uCAAuC,CACrD,QAA+C;IAE/C,OAAO,OAAO,CAAC,WAAW,CACxB,uCAAuC,EACvC,CAAC,QAA8B,EAAE,EAAE;QACjC,MAAM,cAAc,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QACzD,QAAQ,CAAC,cAAc,CAAC,CAAC;IAC3B,CAAC,CACF,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,8BAA8B,CAAC,YAA0B;IACvE,OAAO,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;AAC3C,CAAC;AAED,eAAe;AACf;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,gCAAgC;IACpD,IAAI,CAAC,0BAA0B,CAAC,gCAAgC,EAAE;QAChE,MAAM,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,kCAAkC,CAAC,CAAC;KACxF;IACD,MAAM,QAAQ,GAAG,MAAM,0BAA0B,CAAC,gCAAgC,EAAE,CAAC;IACrF,MAAM,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IAC/E,OAAO,cAAc,CAAC;AACxB,CAAC","sourcesContent":["import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationResponse } from './Notifications.types';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotification, mapNotificationResponse } from './utils/mapNotificationResponse';\n\n// Web uses SyntheticEventEmitter\nconst emitter = new EventEmitter(NotificationsEmitterModule);\n\nconst didReceiveNotificationEventName = 'onDidReceiveNotification';\nconst didDropNotificationsEventName = 'onNotificationsDeleted';\nconst didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\n\n// @docsMissing\nexport const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\n\n/**\n * Listeners registered by this method will be called whenever a notification is received while the app is running.\n * @param listener A function accepting a notification ([`Notification`](#notification)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Registering a notification listener using a React hook:\n * ```jsx\n * import React from 'react';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function App() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationReceivedListener(notification => {\n *       console.log(notification);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationReceivedListener(\n  listener: (event: Notification) => void\n): Subscription {\n  return emitter.addListener<Notification>(\n    didReceiveNotificationEventName,\n    (notification: Notification) => {\n      const mappedNotification = mapNotification(notification);\n      listener(mappedNotification);\n    }\n  );\n}\n\n/**\n * Listeners registered by this method will be called whenever some notifications have been dropped by the server.\n * Applicable only to Firebase Cloud Messaging which we use as a notifications service on Android. It corresponds to `onDeletedMessages()` callback.\n * More information can be found in [Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n * @param listener A callback function.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @header listen\n */\nexport function addNotificationsDroppedListener(listener: () => void): Subscription {\n  return emitter.addListener<void>(didDropNotificationsEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever a user interacts with a notification (for example, taps on it).\n * @param listener A function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n * @return A [`Subscription`](#subscription) object represents the subscription of the provided listener.\n * @example Register a notification responder listener:\n * ```jsx\n * import React from 'react';\n * import { Linking } from 'react-native';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function Container() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n *       const url = response.notification.request.content.data.url;\n *       Linking.openURL(url);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationResponseReceivedListener(\n  listener: (event: NotificationResponse) => void\n): Subscription {\n  return emitter.addListener<NotificationResponse>(\n    didReceiveNotificationResponseEventName,\n    (response: NotificationResponse) => {\n      const mappedResponse = mapNotificationResponse(response);\n      listener(mappedResponse);\n    }\n  );\n}\n\n/**\n * Removes a notification subscription returned by an `addNotificationListener` call.\n * @param subscription A subscription returned by `addNotificationListener` method.\n * @header listen\n */\nexport function removeNotificationSubscription(subscription: Subscription) {\n  emitter.removeSubscription(subscription);\n}\n\n// @docsMissing\n/**\n * @header listen\n */\nexport async function getLastNotificationResponseAsync(): Promise<NotificationResponse | null> {\n  if (!NotificationsEmitterModule.getLastNotificationResponseAsync) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponseAsync');\n  }\n  const response = await NotificationsEmitterModule.getLastNotificationResponseAsync();\n  const mappedResponse = response ? mapNotificationResponse(response) : response;\n  return mappedResponse;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts
index 3c8916e..7d36d83 100644
--- a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts
@@ -1,4 +1,4 @@
-import { NotificationResponse } from '../Notifications.types';
+import { Notification, NotificationResponse } from '../Notifications.types';
 /**
  * @hidden
  *
@@ -9,13 +9,31 @@ import { NotificationResponse } from '../Notifications.types';
  * @param response The raw response passed in from native code
  * @returns the mapped response.
  */
-export declare const mapNotificationResponse: (response: NotificationResponse) => NotificationResponse & {
-    notification: {
+export declare const mapNotificationResponse: (response: NotificationResponse) => {
+    notification: Notification & {
         request: {
             content: {
                 dataString?: string;
             };
         };
     };
+    actionIdentifier: string;
+    userText?: string | undefined;
+};
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification from native code
+ * before it is passed to a notification listener.
+ *
+ * @param response The raw notification passed in from native code
+ * @returns the mapped notification.
+ */
+export declare const mapNotification: (notification: Notification) => Notification & {
+    request: {
+        content: {
+            dataString?: string;
+        };
+    };
 };
 //# sourceMappingURL=mapNotificationResponse.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map
index b873283..4ae1f21 100644
--- a/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"mapNotificationResponse.d.ts","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAE9D;;;;;;;;;GASG;AACH,eAAO,MAAM,uBAAuB,aAAc,oBAAoB;kBAEpD;QAAE,OAAO,EAAE;YAAE,OAAO,EAAE;gBAAE,UAAU,CAAC,EAAE,MAAM,CAAA;aAAE,CAAA;SAAE,CAAA;KAAE;CAYlE,CAAC"}
\ No newline at end of file
+{"version":3,"file":"mapNotificationResponse.d.ts","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAE5E;;;;;;;;;GASG;AACH,eAAO,MAAM,uBAAuB,aAAc,oBAAoB;;iBAkBzD;YAAE,OAAO,EAAE;gBAAE,UAAU,CAAC,EAAE,MAAM,CAAA;aAAE,CAAA;SAAE;;;;CAbhD,CAAC;AAEF;;;;;;;;GAQG;AACH,eAAO,MAAM,eAAe,iBAAkB,YAAY;aAE7C;QAAE,OAAO,EAAE;YAAE,UAAU,CAAC,EAAE,MAAM,CAAA;SAAE,CAAA;KAAE;CAYhD,CAAC"}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js
index 4f421e3..dcf6c87 100644
--- a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js
@@ -9,17 +9,32 @@
  * @returns the mapped response.
  */
 export const mapNotificationResponse = (response) => {
-    const mappedResponse = { ...response };
+    return {
+        ...response,
+        notification: mapNotification(response.notification),
+    };
+};
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification from native code
+ * before it is passed to a notification listener.
+ *
+ * @param response The raw notification passed in from native code
+ * @returns the mapped notification.
+ */
+export const mapNotification = (notification) => {
+    const mappedNotification = { ...notification };
     try {
-        const dataString = mappedResponse?.notification?.request?.content['dataString'];
+        const dataString = mappedNotification?.request?.content['dataString'];
         if (typeof dataString === 'string') {
-            mappedResponse.notification.request.content.data = JSON.parse(dataString);
-            delete mappedResponse.notification.request.content.dataString;
+            mappedNotification.request.content.data = JSON.parse(dataString);
+            delete mappedNotification.request.content.dataString;
         }
     }
     catch (e) {
-        console.log(`Error in response: ${e}`);
+        console.log(`Error in notification: ${e}`);
     }
-    return mappedResponse;
+    return mappedNotification;
 };
 //# sourceMappingURL=mapNotificationResponse.js.map
\ No newline at end of file
diff --git a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map
index 4c49e80..3f48ac4 100644
--- a/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map
+++ b/node_modules/expo-notifications/build/utils/mapNotificationResponse.js.map
@@ -1 +1 @@
-{"version":3,"file":"mapNotificationResponse.js","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAEA;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,QAA8B,EAAE,EAAE;IACxE,MAAM,cAAc,GAEhB,EAAE,GAAG,QAAQ,EAAE,CAAC;IACpB,IAAI;QACF,MAAM,UAAU,GAAG,cAAc,EAAE,YAAY,EAAE,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;QAChF,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,cAAc,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YAC1E,OAAO,cAAc,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;SAC/D;KACF;IAAC,OAAO,CAAM,EAAE;QACf,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;KACxC;IACD,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC","sourcesContent":["import { NotificationResponse } from '../Notifications.types';\n\n/**\n * @hidden\n *\n * Does any required processing of a notification response from native code\n * before it is passed to a notification response listener, or to the\n * last notification response hook.\n *\n * @param response The raw response passed in from native code\n * @returns the mapped response.\n */\nexport const mapNotificationResponse = (response: NotificationResponse) => {\n  const mappedResponse: NotificationResponse & {\n    notification: { request: { content: { dataString?: string } } };\n  } = { ...response };\n  try {\n    const dataString = mappedResponse?.notification?.request?.content['dataString'];\n    if (typeof dataString === 'string') {\n      mappedResponse.notification.request.content.data = JSON.parse(dataString);\n      delete mappedResponse.notification.request.content.dataString;\n    }\n  } catch (e: any) {\n    console.log(`Error in response: ${e}`);\n  }\n  return mappedResponse;\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"mapNotificationResponse.js","sourceRoot":"","sources":["../../src/utils/mapNotificationResponse.ts"],"names":[],"mappings":"AAEA;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,QAA8B,EAAE,EAAE;IACxE,OAAO;QACL,GAAG,QAAQ;QACX,YAAY,EAAE,eAAe,CAAC,QAAQ,CAAC,YAAY,CAAC;KACrD,CAAC;AACJ,CAAC,CAAC;AAEF;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,YAA0B,EAAE,EAAE;IAC5D,MAAM,kBAAkB,GAEpB,EAAE,GAAG,YAAY,EAAE,CAAC;IACxB,IAAI;QACF,MAAM,UAAU,GAAG,kBAAkB,EAAE,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;QACtE,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,kBAAkB,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACjE,OAAO,kBAAkB,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;SACtD;KACF;IAAC,OAAO,CAAM,EAAE;QACf,OAAO,CAAC,GAAG,CAAC,0BAA0B,CAAC,EAAE,CAAC,CAAC;KAC5C;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC,CAAC","sourcesContent":["import { Notification, NotificationResponse } from '../Notifications.types';\n\n/**\n * @hidden\n *\n * Does any required processing of a notification response from native code\n * before it is passed to a notification response listener, or to the\n * last notification response hook.\n *\n * @param response The raw response passed in from native code\n * @returns the mapped response.\n */\nexport const mapNotificationResponse = (response: NotificationResponse) => {\n  return {\n    ...response,\n    notification: mapNotification(response.notification),\n  };\n};\n\n/**\n * @hidden\n *\n * Does any required processing of a notification from native code\n * before it is passed to a notification listener.\n *\n * @param response The raw notification passed in from native code\n * @returns the mapped notification.\n */\nexport const mapNotification = (notification: Notification) => {\n  const mappedNotification: Notification & {\n    request: { content: { dataString?: string } };\n  } = { ...notification };\n  try {\n    const dataString = mappedNotification?.request?.content['dataString'];\n    if (typeof dataString === 'string') {\n      mappedNotification.request.content.data = JSON.parse(dataString);\n      delete mappedNotification.request.content.dataString;\n    }\n  } catch (e: any) {\n    console.log(`Error in notification: ${e}`);\n  }\n  return mappedNotification;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-notifications/src/NotificationsEmitter.ts b/node_modules/expo-notifications/src/NotificationsEmitter.ts
index 83f9857..d071ba6 100644
--- a/node_modules/expo-notifications/src/NotificationsEmitter.ts
+++ b/node_modules/expo-notifications/src/NotificationsEmitter.ts
@@ -2,7 +2,7 @@ import { EventEmitter, Subscription, UnavailabilityError } from 'expo-modules-co
 
 import { Notification, NotificationResponse } from './Notifications.types';
 import NotificationsEmitterModule from './NotificationsEmitterModule';
-import { mapNotificationResponse } from './utils/mapNotificationResponse';
+import { mapNotification, mapNotificationResponse } from './utils/mapNotificationResponse';
 
 // Web uses SyntheticEventEmitter
 const emitter = new EventEmitter(NotificationsEmitterModule);
@@ -41,7 +41,13 @@ export const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEF
 export function addNotificationReceivedListener(
   listener: (event: Notification) => void
 ): Subscription {
-  return emitter.addListener<Notification>(didReceiveNotificationEventName, listener);
+  return emitter.addListener<Notification>(
+    didReceiveNotificationEventName,
+    (notification: Notification) => {
+      const mappedNotification = mapNotification(notification);
+      listener(mappedNotification);
+    }
+  );
 }
 
 /**
diff --git a/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts b/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts
index 424d0f2..64e327c 100644
--- a/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts
+++ b/node_modules/expo-notifications/src/utils/mapNotificationResponse.ts
@@ -1,4 +1,4 @@
-import { NotificationResponse } from '../Notifications.types';
+import { Notification, NotificationResponse } from '../Notifications.types';
 
 /**
  * @hidden
@@ -11,17 +11,33 @@ import { NotificationResponse } from '../Notifications.types';
  * @returns the mapped response.
  */
 export const mapNotificationResponse = (response: NotificationResponse) => {
-  const mappedResponse: NotificationResponse & {
-    notification: { request: { content: { dataString?: string } } };
-  } = { ...response };
+  return {
+    ...response,
+    notification: mapNotification(response.notification),
+  };
+};
+
+/**
+ * @hidden
+ *
+ * Does any required processing of a notification from native code
+ * before it is passed to a notification listener.
+ *
+ * @param response The raw notification passed in from native code
+ * @returns the mapped notification.
+ */
+export const mapNotification = (notification: Notification) => {
+  const mappedNotification: Notification & {
+    request: { content: { dataString?: string } };
+  } = { ...notification };
   try {
-    const dataString = mappedResponse?.notification?.request?.content['dataString'];
+    const dataString = mappedNotification?.request?.content['dataString'];
     if (typeof dataString === 'string') {
-      mappedResponse.notification.request.content.data = JSON.parse(dataString);
-      delete mappedResponse.notification.request.content.dataString;
+      mappedNotification.request.content.data = JSON.parse(dataString);
+      delete mappedNotification.request.content.dataString;
     }
   } catch (e: any) {
-    console.log(`Error in response: ${e}`);
+    console.log(`Error in notification: ${e}`);
   }
-  return mappedResponse;
+  return mappedNotification;
 };
